!(function (t, e) {
  typeof exports === 'object' && typeof module === 'object'
    ? (module.exports = e())
    : typeof define === 'function' && define.amd
    ? define([], e)
    : typeof exports === 'object'
    ? (exports.f6 = e())
    : (t.f6 = e());
})(this, () => {
  return (function (t) {
    const e = {};
    function n(r) {
      if (e[r]) return e[r].exports;
      const i = (e[r] = { i: r, l: !1, exports: {} });
      return t[r].call(i.exports, i, i.exports, n), (i.l = !0), i.exports;
    }
    return (
      (n.m = t),
      (n.c = e),
      (n.d = function (t, e, r) {
        n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: r });
      }),
      (n.r = function (t) {
        typeof Symbol !== 'undefined' &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(t, '__esModule', { value: !0 });
      }),
      (n.t = function (t, e) {
        if ((1 & e && (t = n(t)), 8 & e)) return t;
        if (4 & e && typeof t === 'object' && t && t.__esModule) return t;
        const r = Object.create(null);
        if (
          (n.r(r),
          Object.defineProperty(r, 'default', { enumerable: !0, value: t }),
          2 & e && typeof t !== 'string')
        )
          for (const i in t)
            n.d(
              r,
              i,
              ((e) => {
                return t[e];
              }).bind(null, i),
            );
        return r;
      }),
      (n.n = function (t) {
        const e =
          t && t.__esModule
            ? function () {
                return t.default;
              }
            : function () {
                return t;
              };
        return n.d(e, 'a', e), e;
      }),
      (n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }),
      (n.p = ''),
      n((n.s = 235))
    );
  })([
    function (t, e, n) {
      'use strict';
      n.d(e, 'e', () => {
        return x;
      }),
        n.d(e, 'x', () => {
          return M;
        }),
        n.d(e, 'l', () => {
          return w;
        }),
        n.d(e, 'p', () => {
          return g;
        }),
        n.d(e, 'q', () => {
          return v;
        }),
        n.d(e, 's', () => {
          return O;
        }),
        n.d(e, 'u', () => {
          return E;
        }),
        n.d(e, 'w', () => {
          return T;
        }),
        n.d(e, 'f', () => {
          return u;
        }),
        n.d(e, 'g', () => {
          return P;
        }),
        n.d(e, 'i', () => {
          return a;
        }),
        n.d(e, 'j', () => {
          return s;
        }),
        n.d(e, 'k', () => {
          return S;
        }),
        n.d(e, 'm', () => {
          return h;
        }),
        n.d(e, 'n', () => {
          return p;
        }),
        n.d(e, 'o', () => {
          return m;
        }),
        n.d(e, 'a', () => {
          return N;
        }),
        n.d(e, 'b', () => {
          return B;
        }),
        n.d(e, 'c', () => {
          return l;
        }),
        n.d(e, 'h', () => {
          return L;
        }),
        n.d(e, 'r', () => {
          return A;
        }),
        n.d(e, 'd', () => {
          return D;
        }),
        n.d(e, 'v', () => {
          return Y;
        }),
        n.d(e, 't', () => {
          return F;
        });
      const r = function (t) {
        return t !== null && typeof t !== 'function' && isFinite(t.length);
      };
      const i = {}.toString;
      const o = function (t, e) {
        return i.call(t) === `[object ${e}]`;
      };
      var a = function (t) {
        return o(t, 'Function');
      };
      var s = function (t) {
        return t == null;
      };
      var u = function (t) {
        return Array.isArray ? Array.isArray(t) : o(t, 'Array');
      };
      function c(t) {
        return (c =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var h = function (t) {
        const e = c(t);
        return (t !== null && e === 'object') || e === 'function';
      };
      var l = function (t, e) {
        if (t)
          if (u(t)) for (let n = 0, r = t.length; n < r && !1 !== e(t[n], n); n++);
          else if (h(t)) for (const i in t) if (t.hasOwnProperty(i) && !1 === e(t[i], i)) break;
      };
      Object.keys;
      function f(t) {
        return (f =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const d = function (t) {
        return f(t) === 'object' && t !== null;
      };
      var p = function (t) {
        if (!d(t) || !o(t, 'Object')) return !1;
        if (Object.getPrototypeOf(t) === null) return !0;
        for (var e = t; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
        return Object.getPrototypeOf(t) === e;
      };
      var g = function (t) {
        if (u(t))
          return t.reduce((t, e) => {
            return Math.max(t, e);
          }, t[0]);
      };
      var v = function (t) {
        if (u(t))
          return t.reduce((t, e) => {
            return Math.min(t, e);
          }, t[0]);
      };
      const y = Array.prototype;
      var m =
        (y.splice,
        y.indexOf,
        Array.prototype.splice,
        function (t) {
          return o(t, 'String');
        });
      const b = Object.prototype.hasOwnProperty;
      var x = function (t, e) {
        if (!e || !u(t)) return {};
        for (
          var n,
            r = {},
            i = a(e)
              ? e
              : function (t) {
                  return t[e];
                },
            o = 0;
          o < t.length;
          o++
        ) {
          const s = t[o];
          (n = i(s)), b.call(r, n) ? r[n].push(s) : (r[n] = [s]);
        }
        return r;
      };
      var M = function (t, e) {
        if (t[`_wrap_${e}`]) return t[`_wrap_${e}`];
        const n = function (n) {
          t[e](n);
        };
        return (t[`_wrap_${e}`] = n), n;
      };
      var S = function (t) {
        return o(t, 'Number');
      };
      Number.isInteger && Number.isInteger;
      function w(t, e, n) {
        return void 0 === n && (n = 1e-5), Math.abs(t - e) < n;
      }
      var O = function (t, e) {
        return ((t % e) + e) % e;
      };
      const C = (Math.PI, parseInt, Math.PI / 180);
      var E = function (t) {
        return C * t;
      };
      const k =
        (Object.values,
        function (t) {
          return s(t) ? '' : t.toString();
        });
      var T = function (t) {
        const e = k(t);
        return e.charAt(0).toUpperCase() + e.substring(1);
      };
      var P = function (t) {
        return o(t, 'Boolean');
      };
      Object.prototype;
      function I(t, e) {
        for (const n in e)
          e.hasOwnProperty(n) && n !== 'constructor' && void 0 !== e[n] && (t[n] = e[n]);
      }
      function A(t, e, n, r) {
        return e && I(t, e), n && I(t, n), r && I(t, r), t;
      }
      function j(t) {
        return (j =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var N = function t(e) {
        if (j(e) !== 'object' || e === null) return e;
        let n;
        if (u(e)) {
          n = [];
          for (let r = 0, i = e.length; r < i; r++)
            j(e[r]) === 'object' && e[r] != null ? (n[r] = t(e[r])) : (n[r] = e[r]);
        } else
          for (const o in ((n = {}), e))
            j(e[o]) === 'object' && e[o] != null ? (n[o] = t(e[o])) : (n[o] = e[o]);
        return n;
      };
      function _(t, e, n, r) {
        for (const i in ((n = n || 0), (r = r || 5), e))
          if (e.hasOwnProperty(i)) {
            const o = e[i];
            o !== null && p(o)
              ? (p(t[i]) || (t[i] = {}), n < r ? _(t[i], o, n + 1, r) : (t[i] = e[i]))
              : u(o)
              ? ((t[i] = []), (t[i] = t[i].concat(o)))
              : void 0 !== o && (t[i] = o);
          }
      }
      var B = function (t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        for (let r = 0; r < e.length; r += 1) _(t, e[r]);
        return t;
      };
      Object.prototype.hasOwnProperty;
      var L = function t(e, n) {
        if (e === n) return !0;
        if (!e || !n) return !1;
        if (m(e) || m(n)) return !1;
        if (r(e) || r(n)) {
          if (e.length !== n.length) return !1;
          for (var i = !0, o = 0; o < e.length && (i = t(e[o], n[o])); o++);
          return i;
        }
        if (d(e) || d(n)) {
          const a = Object.keys(e);
          const s = Object.keys(n);
          if (a.length !== s.length) return !1;
          for (i = !0, o = 0; o < a.length && (i = t(e[a[o]], n[a[o]])); o++);
          return i;
        }
        return !1;
      };
      var D = function (t, e, n) {
        for (var r = 0, i = m(e) ? e.split('.') : e; t && r < i.length; ) t = t[i[r++]];
        return void 0 === t || r < i.length ? n : t;
      };
      const R = (Object.prototype.hasOwnProperty, {});
      var Y = function (t) {
        return R[(t = t || 'g')] ? (R[t] += 1) : (R[t] = 1), t + R[t];
      };
      var F = function () {};
      !(function () {
        function t() {
          this.map = {};
        }
        (t.prototype.has = function (t) {
          return void 0 !== this.map[t];
        }),
          (t.prototype.get = function (t, e) {
            const n = this.map[t];
            return void 0 === n ? e : n;
          }),
          (t.prototype.set = function (t, e) {
            this.map[t] = e;
          }),
          (t.prototype.clear = function () {
            this.map = {};
          }),
          (t.prototype.delete = function (t) {
            delete this.map[t];
          }),
          (t.prototype.size = function () {
            return Object.keys(this.map).length;
          });
      })();
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'c', () => {
        return i;
      }),
        n.d(e, 'a', () => {
          return o;
        }),
        n.d(e, 'e', () => {
          return a;
        }),
        n.d(e, 'b', () => {
          return s;
        }),
        n.d(e, 'd', () => {
          return u;
        }),
        n.d(e, 'g', () => {
          return c;
        }),
        n.d(e, 'f', () => {
          return h;
        });
      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
      var r = function (t, e) {
        return (r =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, e) {
              t.__proto__ = e;
            }) ||
          function (t, e) {
            for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
          })(t, e);
      };
      function i(t, e) {
        if (typeof e !== 'function' && e !== null)
          throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`);
        function n() {
          this.constructor = t;
        }
        r(t, e),
          (t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n()));
      }
      var o = function () {
        return (o =
          Object.assign ||
          function (t) {
            for (var e, n = 1, r = arguments.length; n < r; n++)
              for (const i in (e = arguments[n]))
                Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t;
          }).apply(this, arguments);
      };
      function a(t, e) {
        const n = {};
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (t != null && typeof Object.getOwnPropertySymbols === 'function') {
          let i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
              (n[r[i]] = t[r[i]]);
        }
        return n;
      }
      function s(t, e, n, r) {
        return new (n || (n = Promise))((i, o) => {
          function a(t) {
            try {
              u(r.next(t));
            } catch (t) {
              o(t);
            }
          }
          function s(t) {
            try {
              u(r.throw(t));
            } catch (t) {
              o(t);
            }
          }
          function u(t) {
            let e;
            t.done
              ? i(t.value)
              : ((e = t.value),
                e instanceof n
                  ? e
                  : new n((t) => {
                      t(e);
                    })).then(a, s);
          }
          u((r = r.apply(t, e || [])).next());
        });
      }
      function u(t, e) {
        let n;
        let r;
        let i;
        let o;
        let a = {
          label: 0,
          sent() {
            if (1 & i[0]) throw i[1];
            return i[1];
          },
          trys: [],
          ops: [],
        };
        return (
          (o = { next: s(0), throw: s(1), return: s(2) }),
          typeof Symbol === 'function' &&
            (o[Symbol.iterator] = function () {
              return this;
            }),
          o
        );
        function s(o) {
          return function (s) {
            return (function (o) {
              if (n) throw new TypeError('Generator is already executing.');
              for (; a; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (i =
                        2 & o[0]
                          ? r.return
                          : o[0]
                          ? r.throw || ((i = r.return) && i.call(r), 0)
                          : r.next) &&
                      !(i = i.call(r, o[1])).done)
                  )
                    return i;
                  switch (((r = 0), i && (o = [2 & o[0], i.value]), o[0])) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return a.label++, { value: o[1], done: !1 };
                    case 5:
                      a.label++, (r = o[1]), (o = [0]);
                      continue;
                    case 7:
                      (o = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !((i = a.trys),
                        (i = i.length > 0 && i[i.length - 1]) || (o[0] !== 6 && o[0] !== 2))
                      ) {
                        a = 0;
                        continue;
                      }
                      if (o[0] === 3 && (!i || (o[1] > i[0] && o[1] < i[3]))) {
                        a.label = o[1];
                        break;
                      }
                      if (o[0] === 6 && a.label < i[1]) {
                        (a.label = i[1]), (i = o);
                        break;
                      }
                      if (i && a.label < i[2]) {
                        (a.label = i[2]), a.ops.push(o);
                        break;
                      }
                      i[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  o = e.call(t, a);
                } catch (t) {
                  (o = [6, t]), (r = 0);
                } finally {
                  n = i = 0;
                }
              if (5 & o[0]) throw o[1];
              return { value: o[0] ? o[1] : void 0, done: !0 };
            })([o, s]);
          };
        }
      }
      Object.create;
      function c() {
        for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
        const r = Array(t);
        let i = 0;
        for (e = 0; e < n; e++)
          for (let o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];
        return r;
      }
      function h(t, e, n) {
        if (n || arguments.length === 2)
          for (var r, i = 0, o = e.length; i < o; i++)
            (!r && i in e) || (r || (r = Array.prototype.slice.call(e, 0, i)), (r[i] = e[i]));
        return t.concat(r || e);
      }
      Object.create;
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'i', () => {
        return kt;
      }),
        n.d(e, 'h', () => {
          return Le;
        }),
        n.d(e, 'd', () => {
          return De;
        }),
        n.d(e, 'm', () => {
          return Ye;
        }),
        n.d(e, 'l', () => {
          return Zt;
        }),
        n.d(e, 'g', () => {
          return Vt;
        }),
        n.d(e, 'f', () => {
          return Kt;
        }),
        n.d(e, 'j', () => {
          return Me;
        }),
        n.d(e, 'k', () => {
          return Re;
        }),
        n.d(e, 'r', () => {
          return Ue;
        }),
        n.d(e, 'p', () => {
          return qe;
        }),
        n.d(e, 'b', () => {
          return we;
        }),
        n.d(e, 'n', () => {
          return ze;
        }),
        n.d(e, 'q', () => {
          return He;
        }),
        n.d(e, 'o', () => {
          return Ve;
        }),
        n.d(e, 'c', () => {
          return We;
        }),
        n.d(e, 'a', () => {
          return Ge;
        }),
        n.d(e, 'e', () => {
          return Ze;
        });
      const r = {};
      n.r(r),
        n.d(r, 'compare', () => {
          return x;
        }),
        n.d(r, 'getLineIntersect', () => {
          return S;
        }),
        n.d(r, 'getRectIntersectByPoint', () => {
          return w;
        }),
        n.d(r, 'getCircleIntersectByPoint', () => {
          return O;
        }),
        n.d(r, 'getEllipseIntersectByPoint', () => {
          return C;
        }),
        n.d(r, 'applyMatrix', () => {
          return E;
        }),
        n.d(r, 'invertMatrix', () => {
          return k;
        }),
        n.d(r, 'getCircleCenterByPoints', () => {
          return T;
        }),
        n.d(r, 'distance', () => {
          return P;
        }),
        n.d(r, 'scaleMatrix', () => {
          return I;
        }),
        n.d(r, 'floydWarshall', () => {
          return A;
        }),
        n.d(r, 'getAdjMatrix', () => {
          return j;
        }),
        n.d(r, 'translate', () => {
          return N;
        }),
        n.d(r, 'move', () => {
          return _;
        }),
        n.d(r, 'scale', () => {
          return B;
        }),
        n.d(r, 'rotate', () => {
          return L;
        }),
        n.d(r, 'getDegree', () => {
          return D;
        }),
        n.d(r, 'isPointInPolygon', () => {
          return Y;
        }),
        n.d(r, 'intersectBBox', () => {
          return F;
        }),
        n.d(r, 'isPolygonsIntersect', () => {
          return X;
        }),
        n.d(r, 'Line', () => {
          return z;
        }),
        n.d(r, 'getBBoxBoundLine', () => {
          return W;
        }),
        n.d(r, 'itemIntersectByLine', () => {
          return U;
        }),
        n.d(r, 'fractionToLine', () => {
          return H;
        }),
        n.d(r, 'getPointsCenter', () => {
          return q;
        }),
        n.d(r, 'squareDist', () => {
          return V;
        }),
        n.d(r, 'pointLineSquareDist', () => {
          return Z;
        }),
        n.d(r, 'isPointsOverlap', () => {
          return K;
        }),
        n.d(r, 'pointRectSquareDist', () => {
          return $;
        }),
        n.d(r, 'pointLineDistance', () => {
          return Q;
        });
      const i = {};
      n.r(i),
        n.d(i, 'getBBox', () => {
          return lt;
        }),
        n.d(i, 'getLoopCfgs', () => {
          return ft;
        }),
        n.d(i, 'getLabelPosition', () => {
          return dt;
        }),
        n.d(i, 'traverseTree', () => {
          return gt;
        }),
        n.d(i, 'traverseTreeUp', () => {
          return vt;
        }),
        n.d(i, 'getLetterWidth', () => {
          return yt;
        }),
        n.d(i, 'getTextSize', () => {
          return mt;
        }),
        n.d(i, 'plainCombosToTrees', () => {
          return bt;
        }),
        n.d(i, 'reconstructTree', () => {
          return xt;
        }),
        n.d(i, 'getComboBBox', () => {
          return Mt;
        }),
        n.d(i, 'shouldRefreshEdge', () => {
          return St;
        }),
        n.d(i, 'cloneBesidesImg', () => {
          return wt;
        });
      const o = {};
      n.r(o),
        n.d(o, 'uniqueId', () => {
          return Tt;
        }),
        n.d(o, 'formatPadding', () => {
          return Pt;
        }),
        n.d(o, 'cloneEvent', () => {
          return It;
        }),
        n.d(o, 'isViewportChanged', () => {
          return At;
        }),
        n.d(o, 'isNaN', () => {
          return jt;
        }),
        n.d(o, 'calculationItemsBBox', () => {
          return Nt;
        }),
        n.d(o, 'processParallelEdges', () => {
          return _t;
        });
      const a = {};
      n.r(a),
        n.d(a, 'getSpline', () => {
          return ne;
        }),
        n.d(a, 'getControlPoint', () => {
          return re;
        }),
        n.d(a, 'pointsToPolygon', () => {
          return ie;
        }),
        n.d(a, 'pathToPoints', () => {
          return oe;
        }),
        n.d(a, 'getClosedSpline', () => {
          return ae;
        }),
        n.d(a, 'roundedHull', () => {
          return he;
        }),
        n.d(a, 'paddedHull', () => {
          return le;
        });
      const s = {};
      n.r(s),
        n.d(s, 'defaultSubjectColors', () => {
          return Fe;
        });
      const u = n(0);
      const c = {
        getDefaultCfg() {
          return {};
        },
        getEvents() {
          return {};
        },
        updateCfg(t) {
          return Object.assign(this, t), !0;
        },
        shouldBegin() {
          return !0;
        },
        shouldUpdate() {
          return !0;
        },
        shouldEnd() {
          return !0;
        },
        bind(t) {
          const e = this.events;
          (this.graph = t),
            (this.type !== 'drag-canvas' &&
              this.type !== 'brush-select' &&
              this.type !== 'lasso-select') ||
              t.get('canvas').set('draggable', !0),
            Object(u.c)(e, (e, n) => {
              t.on(n, e);
            });
        },
        unbind(t) {
          const e = this.events;
          (this.type !== 'drag-canvas' &&
            this.type !== 'brush-select' &&
            this.type !== 'lasso-select') ||
            t.get('canvas').set('draggable', !1),
            Object(u.c)(e, (e, n) => {
              t.off(n, e);
            });
        },
        get(t) {
          return this[t];
        },
        set(t, e) {
          return (this[t] = e), this;
        },
      };
      const h = (function () {
        function t() {}
        return (
          (t.registerBehavior = function (e, n) {
            if (!n) throw new Error(`please specify handler for this behavior: ${e}`);
            const r = Object(u.a)(c);
            Object.assign(r, n);
            const i = function (t) {
              const e = this;
              Object.assign(this, this.getDefaultCfg(), t);
              const n = this.getEvents();
              this.events = null;
              const r = {};
              n &&
                (Object(u.c)(n, (t, n) => {
                  r[n] = Object(u.x)(e, t);
                }),
                (this.events = r));
            };
            (i.prototype = r), (t.types[e] = i);
          }),
          (t.hasBehavior = function (e) {
            return !!t.types[e];
          }),
          (t.getBehavior = function (e) {
            return t.types[e];
          }),
          (t.types = {}),
          t
        );
      })();
      const l = h;
      const f = n(1);
      const d = n(89);
      function p(t) {
        return (p =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const g = {};
      function v(t) {
        return g.requestAnimationFrame
          ? g.requestAnimationFrame(t)
          : ((typeof window === 'undefined' ? 'undefined' : p(window)) === 'object' &&
              window.requestAnimationFrame
              ? window.requestAnimationFrame
              : function (t) {
                  return setTimeout(t, 16);
                })(t);
      }
      const y = n(4);
      const m = n(30);
      const b = y.a.transform;
      var x = function (t) {
        return function (e, n) {
          return e[t] - n[t];
        };
      };
      const M = function (t, e, n) {
        return t >= e && t <= n;
      };
      var S = function (t, e, n, r) {
        const i = n.x - t.x;
        const o = n.y - t.y;
        const a = e.x - t.x;
        const s = e.y - t.y;
        const u = r.x - n.x;
        const c = r.y - n.y;
        const h = a * c - s * u;
        const l = 1 / h;
        if (h * h > 1e-4 * (a * a + s * s) * (u * u + c * c)) {
          const f = (i * c - o * u) * l;
          const d = (i * s - o * a) * l;
          return M(f, 0, 1) && M(d, 0, 1) ? { x: t.x + f * a, y: t.y + f * s } : null;
        }
        return null;
      };
      var w = function (t, e) {
        const n = t.x;
        const r = t.y;
        const i = t.width;
        const o = t.height;
        const a = [];
        const s = { x: n + i / 2, y: r + o / 2 };
        a.push({ x: n, y: r }),
          a.push({ x: n + i, y: r }),
          a.push({ x: n + i, y: r + o }),
          a.push({ x: n, y: r + o }),
          a.push({ x: n, y: r });
        for (var u = null, c = 1; c < a.length && !(u = S(a[c - 1], a[c], s, e)); c++);
        return u;
      };
      var O = function (t, e) {
        const n = t.x;
        const r = t.y;
        const i = t.r;
        const o = e.x - n;
        const a = e.y - r;
        if (Math.sqrt(o * o + a * a) < i) return null;
        const s = Math.sign(o);
        const u = Math.sign(a);
        const c = Math.atan(a / o);
        return { x: n + Math.abs(i * Math.cos(c)) * s, y: r + Math.abs(i * Math.sin(c)) * u };
      };
      var C = function (t, e) {
        const n = t.rx;
        const r = t.ry;
        const i = t.x;
        const o = t.y;
        const a = e.x - i;
        const s = e.y - o;
        let u = Math.atan2(s / r, a / n);
        return u < 0 && (u += 2 * Math.PI), { x: i + n * Math.cos(u), y: o + r * Math.sin(u) };
      };
      var E = function (t, e, n) {
        void 0 === n && (n = 1);
        const r = [t.x, t.y, n];
        return (
          (e && !isNaN(e[0])) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          y.d.transformMat3(r, r, e),
          { x: r[0], y: r[1] }
        );
      };
      var k = function (t, e, n) {
        void 0 === n && (n = 1), (e && !isNaN(e[0])) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        let r = y.b.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], e);
        r || (r = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        const i = [t.x, t.y, n];
        return y.d.transformMat3(i, i, r), { x: i[0], y: i[1] };
      };
      var T = function (t, e, n) {
        const r = t.x - e.x;
        const i = t.y - e.y;
        const o = t.x - n.x;
        const a = t.y - n.y;
        const s = (t.x * t.x - e.x * e.x - e.y * e.y + t.y * t.y) / 2;
        const u = (t.x * t.x - n.x * n.x - n.y * n.y + t.y * t.y) / 2;
        const c = i * o - r * a;
        return { x: -(a * s - i * u) / c, y: -(r * u - o * s) / c };
      };
      var P = function (t, e) {
        const n = t.x - e.x;
        const r = t.y - e.y;
        return Math.sqrt(n * n + r * r);
      };
      var I = function (t, e) {
        const n = [];
        return (
          t.forEach((t) => {
            const r = [];
            t.forEach((t) => {
              r.push(t * e);
            }),
              n.push(r);
          }),
          n
        );
      };
      var A = function (t) {
        for (var e = [], n = t.length, r = 0; r < n; r += 1) {
          e[r] = [];
          for (var i = 0; i < n; i += 1)
            r === i
              ? (e[r][i] = 0)
              : t[r][i] !== 0 && t[r][i]
              ? (e[r][i] = t[r][i])
              : (e[r][i] = 1 / 0);
        }
        for (let o = 0; o < n; o += 1)
          for (r = 0; r < n; r += 1)
            for (i = 0; i < n; i += 1) e[r][i] > e[r][o] + e[o][i] && (e[r][i] = e[r][o] + e[o][i]);
        return e;
      };
      var j = function (t, e) {
        const n = t.nodes;
        const r = t.edges;
        const i = [];
        const o = {};
        if (!n) throw new Error('invalid nodes data!');
        return (
          n &&
            n.forEach((t, e) => {
              o[t.id] = e;
              i.push([]);
            }),
          r &&
            r.forEach((t) => {
              const n = t.source;
              const r = t.target;
              const a = o[n];
              const s = o[r];
              (i[a][s] = 1), e || (i[s][a] = 1);
            }),
          i
        );
      };
      var N = function (t, e) {
        t.translate(e.x, e.y);
      };
      var _ = function (t, e) {
        let n = t.getMatrix();
        n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        const r = t.getCanvasBBox();
        const i = e.x - r.minX;
        const o = e.y - r.minY;
        const a = b(n, [['t', i, o]]);
        t.setMatrix(a);
      };
      var B = function (t, e) {
        let n = t.getMatrix();
        n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        let r = e;
        Object(u.f)(e) || (r = [e, e]),
          Object(u.f)(e) && e.length === 1 && (r = [e[0], e[0]]),
          (n = b(n, [['s', r[0], r[1]]])),
          t.setMatrix(n);
      };
      var L = function (t, e) {
        let n = t.getMatrix();
        n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), (n = b(n, [['r', e]])), t.setMatrix(n);
      };
      var D = function (t, e, n) {
        for (var r = [], i = 0; i < t; i++) r[i] = 0;
        return (
          n.forEach((t) => {
            t.source && (r[e[t.source]] += 1), t.target && (r[e[t.target]] += 1);
          }),
          r
        );
      };
      function R(t, e, n) {
        return (
          (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]) &&
          Math.min(t[0], e[0]) <= n[0] &&
          n[0] <= Math.max(t[0], e[0]) &&
          Math.min(t[1], e[1]) <= n[1] &&
          n[1] <= Math.max(t[1], e[1])
        );
      }
      var Y = function (t, e, n) {
        let r = !1;
        const i = t.length;
        function o(t) {
          return Math.abs(t) < 1e-6 ? 0 : t < 0 ? -1 : 1;
        }
        if (i <= 2) return !1;
        for (let a = 0; a < i; a++) {
          const s = t[a];
          const u = t[(a + 1) % i];
          if (R(s, u, [e, n])) return !0;
          o(s[1] - n) > 0 != o(u[1] - n) > 0 &&
            o(e - ((n - s[1]) * (s[0] - u[0])) / (s[1] - u[1]) - s[0]) < 0 &&
            (r = !r);
        }
        return r;
      };
      var F = function (t, e) {
        return !(e.minX > t.maxX || e.maxX < t.minX || e.minY > t.maxY || e.maxY < t.minY);
      };
      var X = function (t, e) {
        const n = function (t) {
          const e = t.map((t) => {
            return t[0];
          });
          const n = t.map((t) => {
            return t[1];
          });
          return {
            minX: Math.min.apply(null, e),
            maxX: Math.max.apply(null, e),
            minY: Math.min.apply(null, n),
            maxY: Math.max.apply(null, n),
          };
        };
        const r = function (t) {
          for (var e = [], n = t.length, r = 0; r < n - 1; r++) {
            const i = t[r];
            const o = t[r + 1];
            e.push({ from: { x: i[0], y: i[1] }, to: { x: o[0], y: o[1] } });
          }
          if (e.length > 1) {
            const a = t[0];
            const s = t[n - 1];
            e.push({ from: { x: s[0], y: s[1] }, to: { x: a[0], y: a[1] } });
          }
          return e;
        };
        if (t.length < 2 || e.length < 2) return !1;
        const i = n(t);
        const o = n(e);
        if (!F(i, o)) return !1;
        let a = !1;
        if (
          (Object(u.c)(e, (e) => {
            if (Y(t, e[0], e[1])) return (a = !0), !1;
          }),
          a)
        )
          return !0;
        if (
          (Object(u.c)(t, (t) => {
            if (Y(e, t[0], t[1])) return (a = !0), !1;
          }),
          a)
        )
          return !0;
        const s = r(t);
        const c = r(e);
        let h = !1;
        return (
          Object(u.c)(c, (t) => {
            if (
              (function (t, e) {
                let n = !1;
                return (
                  Object(u.c)(t, (t) => {
                    if (S(t.from, t.to, e.from, e.to)) return (n = !0), !1;
                  }),
                  n
                );
              })(s, t)
            )
              return (h = !0), !1;
          }),
          h
        );
      };
      var z = (function () {
        function t(t, e, n, r) {
          (this.x1 = t), (this.y1 = e), (this.x2 = n), (this.y2 = r);
        }
        return (
          (t.prototype.getBBox = function () {
            const t = Math.min(this.x1, this.x2);
            const e = Math.min(this.y1, this.y2);
            const n = Math.max(this.x1, this.x2);
            const r = Math.max(this.y1, this.y2);
            return { x: t, y: e, minX: t, minY: e, maxX: n, maxY: r, width: n - t, height: r - e };
          }),
          t
        );
      })();
      var W = function (t, e) {
        return {
          top: [t.minX, t.minY, t.maxX, t.minY],
          left: [t.minX, t.minY, t.minX, t.maxY],
          bottom: [t.minX, t.maxY, t.maxX, t.maxY],
          right: [t.maxX, t.minY, t.maxX, t.maxY],
        }[e];
      };
      const G = function (t, e) {
        const n = (e.x2 - e.x1) * (t.y1 - e.y1) - (e.y2 - e.y1) * (t.x1 - e.x1);
        const r = (t.x2 - t.x1) * (t.y1 - e.y1) - (t.y2 - t.y1) * (t.x1 - e.x1);
        const i = (e.y2 - e.y1) * (t.x2 - t.x1) - (e.x2 - e.x1) * (t.y2 - t.y1);
        if (i) {
          const o = n / i;
          const a = r / i;
          if (o >= 0 && o <= 1 && a >= 0 && a <= 1) return o;
        }
        return Number.POSITIVE_INFINITY;
      };
      var U = function (t, e) {
        for (
          var n = ['top', 'left', 'bottom', 'right'], r = t.getBBox(), i = 0, o = [], a = 0;
          a < 4;
          a++
        ) {
          const s = W(r, n[a]);
          const u = s[0];
          const c = s[1];
          const h = s[2];
          const l = s[3];
          (o[a] = S({ x: e.x1, y: e.y1 }, { x: e.x2, y: e.y2 }, { x: u, y: c }, { x: h, y: l })),
            o[a] && (i += 1);
        }
        return [o, i];
      };
      var H = function (t, e) {
        for (
          var n = ['top', 'left', 'bottom', 'right'],
            r = t.getBBox(),
            i = Number.POSITIVE_INFINITY,
            o = 0,
            a = 0;
          a < 4;
          a++
        ) {
          const s = W(r, n[a]);
          const u = s[0];
          const c = s[1];
          const h = s[2];
          const l = s[3];
          let f = G(e, new z(u, c, h, l));
          (f = Math.abs(f - 0.5)) >= 0 && f <= 1 && ((o += 1), (i = f < i ? f : i));
        }
        return o === 0 ? -1 : i;
      };
      var q = function (t) {
        let e = 0;
        let n = 0;
        if (t.length > 0) {
          for (let r = 0, i = t; r < i.length; r++) {
            const o = i[r];
            (e += o.x), (n += o.y);
          }
          (e /= t.length), (n /= t.length);
        }
        return { x: e, y: n };
      };
      var V = function (t, e) {
        return Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2);
      };
      var Z = function (t, e) {
        let n;
        const r = e.x1;
        const i = e.y1;
        const o = e.x2 - r;
        const a = e.y2 - i;
        let s = t.x - r;
        let u = t.y - i;
        let c = s * o + u * a;
        n = c <= 0 || (c = (s = o - s) * o + (u = a - u) * a) <= 0 ? 0 : (c * c) / (o * o + a * a);
        let h = s * s + u * u - n;
        return h < 0 && (h = 0), h;
      };
      var K = function (t, e, n) {
        return (
          void 0 === n && (n = 0.001),
          Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2) < Math.pow(n, 2)
        );
      };
      var $ = function (t, e) {
        const n = t.x < e.x;
        const r = t.x > e.x + e.width;
        const i = t.y > e.y + e.height;
        const o = t.y < e.y;
        if (!(n || r || i || o)) return 0;
        if (i && !n && !r) return Math.pow(e.y + e.height - t.y, 2);
        if (o && !n && !r) return Math.pow(t.y - e.y, 2);
        if (n && !i && !o) return Math.pow(e.x - t.x, 2);
        if (r && !i && !o) return Math.pow(e.x + e.width - t.x, 2);
        const a = Math.min(Math.abs(e.x - t.x), Math.abs(e.x + e.width - t.x));
        const s = Math.min(Math.abs(e.y - t.y), Math.abs(e.y + e.height - t.y));
        return a * a + s * s;
      };
      var Q = function (t, e) {
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const o = t[3];
        const a = e.x;
        const s = e.y;
        const u = [i - n, o - r];
        if (y.c.exactEquals(u, [0, 0])) return NaN;
        const c = [-u[1], u[0]];
        y.c.normalize(c, c);
        const h = [a - n, s - r];
        return Math.abs(y.c.dot(h, c));
      };
      const J = 'rgb(95, 149, 255)';
      const tt = 'rgb(253, 253, 253)';
      const et = 'rgb(247, 250, 255)';
      const nt = 'rgb(224, 224, 224)';
      const rt = 'rgb(224, 224, 224)';
      const it = {
        version: '0.3.0',
        rootContainerClassName: 'root-container',
        nodeContainerClassName: 'node-container',
        edgeContainerClassName: 'edge-container',
        comboContainerClassName: 'combo-container',
        delegateContainerClassName: 'delegate-container',
        defaultLoopPosition: 'top',
        nodeLabel: {
          style: { fill: '#000', fontSize: 12, textAlign: 'center', textBaseline: 'middle' },
          offset: 4,
        },
        defaultNode: {
          type: 'circle',
          style: { lineWidth: 1, stroke: J, fill: 'rgb(239, 244, 255)' },
          size: 20,
          color: J,
          linkPoints: { size: 8, lineWidth: 1, fill: et, stroke: J },
        },
        nodeStateStyles: {
          active: { fill: et, stroke: J, lineWidth: 2, shadowColor: J, shadowBlur: 10 },
          selected: {
            fill: 'rgb(255, 255, 255)',
            stroke: J,
            lineWidth: 4,
            shadowColor: J,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: {
            fill: 'rgb(223, 234, 255)',
            stroke: '#4572d9',
            lineWidth: 2,
            'text-shape': { fontWeight: 500 },
          },
          inactive: { fill: 'rgb(247, 250, 255)', stroke: 'rgb(191, 213, 255)', lineWidth: 1 },
          disable: { fill: 'rgb(250, 250, 250)', stroke: 'rgb(224, 224, 224)', lineWidth: 1 },
        },
        edgeLabel: {
          style: {
            fill: 'rgb(0, 0, 0)',
            textAlign: 'center',
            textBaseline: 'middle',
            fontSize: 12,
          },
        },
        defaultEdge: {
          type: 'line',
          size: 1,
          style: { stroke: nt, lineAppendWidth: 2 },
          color: nt,
        },
        edgeStateStyles: {
          active: { stroke: J, lineWidth: 1 },
          selected: {
            stroke: J,
            lineWidth: 2,
            shadowColor: J,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: { stroke: J, lineWidth: 2, 'text-shape': { fontWeight: 500 } },
          inactive: { stroke: 'rgb(234, 234, 234)', lineWidth: 1 },
          disable: { stroke: 'rgb(245, 245, 245)', lineWidth: 1 },
        },
        comboLabel: {
          style: { fill: 'rgb(0, 0, 0)', textBaseline: 'middle', fontSize: 12 },
          refY: 10,
          refX: 10,
        },
        defaultCombo: {
          type: 'circle',
          style: { fill: tt, lineWidth: 1, stroke: rt, r: 5, width: 20, height: 10 },
          size: [20, 5],
          color: rt,
          padding: [25, 20, 15, 20],
        },
        comboStateStyles: {
          active: { stroke: J, lineWidth: 1, fill: 'rgb(247, 250, 255)' },
          selected: {
            stroke: J,
            lineWidth: 2,
            fill: tt,
            shadowColor: J,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: {
            stroke: '#4572d9',
            lineWidth: 2,
            fill: tt,
            'text-shape': { fontWeight: 500 },
          },
          inactive: { stroke: 'rgb(224, 224, 224)', fill: tt, lineWidth: 1 },
          disable: { stroke: 'rgb(234, 234, 234)', fill: 'rgb(250, 250, 250)', lineWidth: 1 },
        },
        delegateStyle: {
          fill: '#F3F9FF',
          fillOpacity: 0.5,
          stroke: '#1890FF',
          strokeOpacity: 0.9,
          lineDash: [5, 5],
        },
      };
      const ot = {
        ' ': 0.3329986572265625,
        a: 0.5589996337890625,
        A: 0.6569992065429687,
        b: 0.58599853515625,
        B: 0.6769989013671875,
        c: 0.5469985961914062,
        C: 0.7279998779296875,
        d: 0.58599853515625,
        D: 0.705999755859375,
        e: 0.554998779296875,
        E: 0.63699951171875,
        f: 0.37299957275390627,
        F: 0.5769989013671875,
        g: 0.5909988403320312,
        G: 0.7479995727539063,
        h: 0.555999755859375,
        H: 0.7199996948242188,
        i: 0.255999755859375,
        I: 0.23699951171875,
        j: 0.26699981689453123,
        J: 0.5169998168945312,
        k: 0.5289993286132812,
        K: 0.6899993896484375,
        l: 0.23499908447265624,
        L: 0.5879989624023437,
        m: 0.854998779296875,
        M: 0.8819992065429687,
        n: 0.5589996337890625,
        N: 0.7189987182617188,
        o: 0.58599853515625,
        O: 0.7669998168945312,
        p: 0.58599853515625,
        P: 0.6419998168945312,
        q: 0.58599853515625,
        Q: 0.7669998168945312,
        r: 0.3649993896484375,
        R: 0.6759994506835938,
        s: 0.504998779296875,
        S: 0.6319992065429687,
        t: 0.354998779296875,
        T: 0.6189987182617187,
        u: 0.5599990844726562,
        U: 0.7139999389648437,
        v: 0.48199920654296874,
        V: 0.6389999389648438,
        w: 0.754998779296875,
        W: 0.929998779296875,
        x: 0.5089996337890625,
        X: 0.63699951171875,
        y: 0.4959991455078125,
        Y: 0.66199951171875,
        z: 0.48699951171875,
        Z: 0.6239990234375,
        0: 0.6,
        1: 0.40099945068359377,
        2: 0.6,
        3: 0.6,
        4: 0.6,
        5: 0.6,
        6: 0.6,
        7: 0.5469985961914062,
        8: 0.6,
        9: 0.6,
        '[': 0.3329986572265625,
        ']': 0.3329986572265625,
        ',': 0.26399993896484375,
        '.': 0.26399993896484375,
        ';': 0.26399993896484375,
        ':': 0.26399993896484375,
        '{': 0.3329986572265625,
        '}': 0.3329986572265625,
        '\\': 0.5,
        '|': 0.19499969482421875,
        '=': 0.604998779296875,
        '+': 0.604998779296875,
        '-': 0.604998779296875,
        _: 0.5,
        '`': 0.3329986572265625,
        ' ~': 0.8329986572265625,
        '!': 0.3329986572265625,
        '@': 0.8579986572265625,
        '#': 0.6,
        $: 0.6,
        '%': 0.9699996948242188,
        '^': 0.517999267578125,
        '&': 0.7259994506835937,
        '*': 0.505999755859375,
        '(': 0.3329986572265625,
        ')': 0.3329986572265625,
        '<': 0.604998779296875,
        '>': 0.604998779296875,
        '/': 0.5,
        '?': 0.53699951171875,
      };
      const at = Math.PI;
      const st = Math.sin;
      const ut = Math.cos;
      const ct = st(at / 8);
      const ht = ut(at / 8);
      var lt = function (t, e) {
        const n = t.getBBox();
        let r = { x: n.minX, y: n.minY };
        let i = { x: n.maxX, y: n.maxY };
        if (e) {
          let o = e.getMatrix();
          o || (o = [1, 0, 0, 0, 1, 0, 0, 0, 1]), (r = E(r, o)), (i = E(i, o));
        }
        const a = r.x;
        const s = r.y;
        const u = i.x;
        const c = i.y;
        return { x: a, y: s, minX: a, minY: s, maxX: u, maxY: c, width: u - a, height: c - s };
      };
      var ft = function (t) {
        const e = t.sourceNode || t.targetNode;
        let n = e.get('group').getMatrix();
        n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
        const r = e.getKeyShape().getBBox();
        const i = t.loopCfg || {};
        const o = i.dist || 2 * Math.max(r.width, r.height);
        const a = i.position || it.defaultLoopPosition;
        const s = [n[6], n[7]];
        let u = [t.startPoint.x, t.startPoint.y];
        let c = [t.endPoint.x, t.endPoint.y];
        let h = r.height / 2;
        let l = r.height / 2;
        let f = h * ct;
        let d = h * ht;
        let p = l * ct;
        let g = l * ht;
        if (u[0] === c[0] && u[1] === c[1]) {
          switch (a) {
            case 'top':
              (u = [s[0] - f, s[1] - d]), (c = [s[0] + p, s[1] - g]);
              break;
            case 'top-right':
              (h = r.height / 2),
                (l = r.width / 2),
                (u = [s[0] + (f = h * ct), s[1] - (d = h * ht)]),
                (c = [s[0] + (g = l * ht), s[1] - (p = l * ct)]);
              break;
            case 'right':
              (h = r.width / 2),
                (l = r.width / 2),
                (u = [s[0] + (d = h * ht), s[1] - (f = h * ct)]),
                (c = [s[0] + (g = l * ht), s[1] + (p = l * ct)]);
              break;
            case 'bottom-right':
              (h = r.width / 2),
                (l = r.height / 2),
                (u = [s[0] + (d = h * ht), s[1] + (f = h * ct)]),
                (c = [s[0] + (p = l * ct), s[1] + (g = l * ht)]);
              break;
            case 'bottom':
              (h = r.height / 2),
                (l = r.height / 2),
                (u = [s[0] + (f = h * ct), s[1] + (d = h * ht)]),
                (c = [s[0] - (p = l * ct), s[1] + (g = l * ht)]);
              break;
            case 'bottom-left':
              (h = r.height / 2),
                (l = r.width / 2),
                (u = [s[0] - (f = h * ct), s[1] + (d = h * ht)]),
                (c = [s[0] - (g = l * ht), s[1] + (p = l * ct)]);
              break;
            case 'left':
              (h = r.width / 2),
                (l = r.width / 2),
                (u = [s[0] - (d = h * ht), s[1] + (f = h * ct)]),
                (c = [s[0] - (g = l * ht), s[1] - (p = l * ct)]);
              break;
            case 'top-left':
              (h = r.width / 2),
                (l = r.height / 2),
                (u = [s[0] - (d = h * ht), s[1] - (f = h * ct)]),
                (c = [s[0] - (p = l * ct), s[1] - (g = l * ht)]);
              break;
            default:
              (h = r.width / 2),
                (l = r.width / 2),
                (u = [s[0] - (f = h * ct), s[1] - (d = h * ht)]),
                (c = [s[0] + (p = l * ct), s[1] - (g = l * ht)]);
          }
          if (!1 === i.clockwise) {
            const v = [u[0], u[1]];
            (u = [c[0], c[1]]), (c = [v[0], v[1]]);
          }
        }
        const m = [u[0] - s[0], u[1] - s[1]];
        let b = (h + o) / h;
        let x = (l + o) / l;
        !1 === i.clockwise && ((b = (l + o) / l), (x = (h + o) / h));
        const M = y.c.scale([0, 0], m, b);
        const S = [s[0] + M[0], s[1] + M[1]];
        const w = [c[0] - s[0], c[1] - s[1]];
        const O = y.c.scale([0, 0], w, x);
        const C = [s[0] + O[0], s[1] + O[1]];
        return (
          (t.startPoint = { x: u[0], y: u[1] }),
          (t.endPoint = { x: c[0], y: c[1] }),
          (t.controlPoints = [
            { x: S[0], y: S[1] },
            { x: C[0], y: C[1] },
          ]),
          t
        );
      };
      var dt = function (t, e, n, r, i) {
        let o = [];
        const a = t.getPoint(e);
        if (a === null) return { x: 0, y: 0, angle: 0 };
        if (e < 1e-4) o = t.getStartTangent().reverse();
        else if (e > 0.9999) o = t.getEndTangent();
        else {
          const s = t.getPoint(e + 1e-4);
          o.push([a.x, a.y]), o.push([s.x, s.y]);
        }
        let u = Math.atan2(o[1][1] - o[0][1], o[1][0] - o[0][0]);
        if ((u < 0 && (u += 2 * at), n && ((a.x += ut(u) * n), (a.y += st(u) * n)), r)) {
          let c = u - at / 2;
          u > 0.5 * at && u < 1.5 * at && (c -= at), (a.x += ut(c) * r), (a.y += st(c) * r);
        }
        const h = { x: a.x, y: a.y, angle: u };
        return i ? (u > 0.5 * at && u < 1.5 * at && (u -= at), Object(f.a)({ rotate: u }, h)) : h;
      };
      const pt = function t(e, n) {
        if (!1 === n(e)) return !1;
        if (e && e.children)
          for (let r = e.children.length - 1; r >= 0; r--) if (!t(e.children[r], n)) return !1;
        return !0;
      };
      var gt = function (t, e) {
        typeof e === 'function' && pt(t, e);
      };
      var vt = function (t, e) {
        typeof e === 'function' &&
          (function t(e, n) {
            if (e && e.children)
              for (let r = e.children.length - 1; r >= 0; r--) if (!t(e.children[r], n)) return;
            return !1 !== n(e);
          })(t, e);
      };
      var yt = function (t, e) {
        return e * (ot[t] || 1);
      };
      var mt = function (t, e) {
        let n = 0;
        const r = new RegExp('[一-龥]+');
        return (
          t.split('').forEach((t) => {
            r.test(t) ? (n += e) : (n += yt(t, e));
          }),
          [n, e]
        );
      };
      var bt = function (t, e) {
        const n = [];
        const r = {};
        const i = {};
        t.forEach((t) => {
          i[t.id] = t;
        }),
          t.forEach((t, e) => {
            const o = Object(u.a)(t);
            (o.itemType = 'combo'),
              (o.children = void 0),
              o.parentId === o.id
                ? (console.warn(
                    `The parentId for combo ${o.id} can not be the same as the combo's id`,
                  ),
                  delete o.parentId)
                : o.parentId &&
                  !i[o.parentId] &&
                  (console.warn(`The parent combo for combo ${o.id} does not exist!`),
                  delete o.parentId);
            let a = r[o.id];
            if (a) {
              if (((o.children = a.children), (r[o.id] = o), !(a = o).parentId))
                return void n.push(a);
              const s = r[a.parentId];
              if (s) s.children ? s.children.push(o) : (s.children = [o]);
              else {
                const c = { id: a.parentId, children: [a] };
                (r[a.parentId] = c), (r[o.id] = o);
              }
            } else if (Object(u.o)(t.parentId)) {
              const h = r[t.parentId];
              if (h) h.children ? h.children.push(o) : (h.children = [o]), (r[o.id] = o);
              else {
                const l = { id: t.parentId, children: [o] };
                (r[l.id] = l), (r[o.id] = o);
              }
            } else n.push(o), (r[o.id] = o);
          });
        const o = {};
        (e || []).forEach((t) => {
          o[t.id] = t;
          const e = r[t.comboId];
          if (e) {
            const n = { id: t.id, comboId: t.comboId };
            e.children ? e.children.push(n) : (e.children = [n]),
              (n.itemType = 'node'),
              (r[t.id] = n);
          }
        });
        let a = 0;
        return (
          n.forEach((t) => {
            (t.depth = a + 10),
              pt(t, (t) => {
                let e;
                const n = r[t.id].itemType;
                (e = n === 'node' ? r[t.comboId] : r[t.parentId]),
                  (t.depth = e && n === 'node' ? a + 1 : a + 10),
                  a < t.depth && (a = t.depth);
                const i = o[t.id];
                return i && (i.depth = t.depth), !0;
              });
          }),
          n
        );
      };
      var xt = function (t, e, n) {
        let r;
        let i = t;
        const o = { root: { children: t } };
        let a = !1;
        let s = 'root';
        (t || []).forEach((t) => {
          if (!a)
            return t.id === e
              ? ((r = t),
                t.itemType === 'combo' ? (r.parentId = n) : (r.comboId = n),
                void (a = !0))
              : void gt(t, (t) => {
                  return (
                    (o[t.id] = { children: t.children }),
                    (i = o[t.parentId || t.comboId || 'root'].children),
                    !t ||
                      (!t.removed && e !== t.id) ||
                      !i ||
                      ((s = t.parentId || t.comboId || 'root'),
                      (r = t),
                      t.itemType === 'combo' ? (r.parentId = n) : (r.comboId = n),
                      (a = !0),
                      !1)
                  );
                });
        });
        const u = (i = o[s].children) ? i.indexOf(r) : -1;
        if (
          (u > -1 && i.splice(u, 1),
          a || ((r = { id: e, itemType: 'node', comboId: n }), (o[e] = { children: void 0 })),
          e)
        ) {
          let c = !1;
          if (n) {
            let h = 0;
            (t || []).forEach((t) => {
              c ||
                gt(t, (t) => {
                  return (
                    n !== t.id ||
                    ((c = !0),
                    t.children ? t.children.push(r) : (t.children = [r]),
                    (h = t.depth),
                    r.itemType === 'node' ? (r.depth = h + 2) : (r.depth = h + 1),
                    !1)
                  );
                });
            });
          } else (n && c) || r.itemType === 'node' || t.push(r);
          let l = r.depth;
          gt(r, (t) => {
            return t.itemType === 'node' ? (l += 2) : (l += 1), (t.depth = l), !0;
          });
        }
        return t;
      };
      var Mt = function (t, e) {
        const n = {
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0,
          x: void 0,
          y: void 0,
          width: void 0,
          height: void 0,
          centerX: void 0,
          centerY: void 0,
        };
        return t && t.length !== 0
          ? (t.forEach((t) => {
              const r = e.findById(t.id);
              if (r && r.isVisible()) {
                r.set('bboxCanvasCache', void 0);
                const i = r.getCanvasBBox();
                i.x && n.minX > i.minX && (n.minX = i.minX),
                  i.y && n.minY > i.minY && (n.minY = i.minY),
                  i.x && n.maxX < i.maxX && (n.maxX = i.maxX),
                  i.y && n.maxY < i.maxY && (n.maxY = i.maxY);
              }
            }),
            (n.x = (n.minX + n.maxX) / 2),
            (n.y = (n.minY + n.maxY) / 2),
            (n.width = n.maxX - n.minX),
            (n.height = n.maxY - n.minY),
            (n.centerX = (n.minX + n.maxX) / 2),
            (n.centerY = (n.minY + n.maxY) / 2),
            Object.keys(n).forEach((t) => {
              (n[t] !== 1 / 0 && n[t] !== -1 / 0) || (n[t] = void 0);
            }),
            n)
          : n;
      };
      var St = function (t) {
        let e = Object(u.k)(t.x) || Object(u.k)(t.y) || t.type || t.anchorPoints || t.size;
        return (
          t.style &&
            (e =
              e ||
              Object(u.k)(t.style.r) ||
              Object(u.k)(t.style.width) ||
              Object(u.k)(t.style.height) ||
              Object(u.k)(t.style.rx) ||
              Object(u.k)(t.style.ry)),
          e
        );
      };
      var wt = function (t) {
        const e = {};
        return (
          Object.keys(t).forEach((n) => {
            const r = t[n];
            if (Object(u.m)(r)) {
              const i = {};
              Object.keys(r).forEach((t) => {
                const e = r[t];
                (t !== 'img' || Object(u.o)(e)) && (i[t] = Object(u.a)(e));
              }),
                (e[n] = i);
            } else e[n] = Object(u.a)(r);
          }),
          e
        );
      };
      const Ot = function (t) {
        if (!t) return console.error('G6 Error Tips: the data must be defined'), !1;
        const e = t.nodes;
        const n = t.edges;
        const r = t.combos;
        const i = void 0 === r ? [] : r;
        if (!e && !n) {
          let o = !0;
          return (
            gt(t, (t) => {
              return !!Object(u.o)(t.id) || ((o = !1), !1);
            }),
            o
          );
        }
        const a = (e || []).find((t) => {
          return !Object(u.o)(t.id);
        });
        if (a)
          return (
            console.warn(
              `G6 Warning Tips: missing 'id' property, or %c${a.id}%c is not a string.`,
              'font-size: 20px; color: red;',
              '',
            ),
            !1
          );
        const s = (e || []).map((t) => {
          return t.id;
        });
        const c = i.map((t) => {
          return t.id;
        });
        const h = Object(f.f)(Object(f.f)([], s), c);
        const l = (n || []).find((t) => {
          return !h.includes(t.source) || !h.includes(t.target);
        });
        return (
          !l ||
          (console.warn(
            `G6 Warning Tips: The source %c${l.source}%c or the target %c${l.target}%c of the edge do not exist in the nodes or combos.`,
            'font-size: 20px; color: red;',
            '',
            'font-size: 20px; color: red;',
            '',
          ),
          !1)
        );
      };
      const Ct = (function () {
        function t(t) {
          (this.graph = t),
            (this.destroyed = !1),
            (this.modes = t.get('modes') || { default: [] }),
            this.formatModes(),
            (this.mode = t.get('defaultMode') || 'default'),
            (this.currentBehaves = []),
            this.setMode(this.mode);
        }
        return (
          (t.prototype.formatModes = function () {
            const t = this.modes;
            Object(u.c)(t, (t) => {
              Object(u.c)(t, (e, n) => {
                Object(u.o)(e) && (t[n] = { type: e });
              });
            });
          }),
          (t.prototype.setBehaviors = function (t) {
            let e;
            const n = this.graph;
            const r = this.modes[t];
            const i = [];
            Object(u.c)(r || [], (t) => {
              const r = h.getBehavior(t.type || t);
              r && (e = new r(t)) && (e.bind(n), i.push(e));
            }),
              (this.currentBehaves = i);
          }),
          (t.mergeBehaviors = function (t, e) {
            return (
              Object(u.c)(e, (e) => {
                t.indexOf(e) < 0 && (Object(u.o)(e) && (e = { type: e }), t.push(e));
              }),
              t
            );
          }),
          (t.filterBehaviors = function (t, e) {
            const n = [];
            return (
              t.forEach((t) => {
                let r = '';
                (r = Object(u.o)(t) ? t : t.type), e.indexOf(r) < 0 && n.push(t);
              }),
              n
            );
          }),
          (t.prototype.setMode = function (t) {
            const e = this.modes;
            const n = this.graph;
            const r = t;
            e[r] &&
              (n.emit('beforemodechange', { mode: t }),
              Object(u.c)(this.currentBehaves, (t) => {
                t.delegate && t.delegate.remove(), t.unbind(n);
              }),
              this.setBehaviors(r),
              n.emit('aftermodechange', { mode: t }),
              (this.mode = t));
          }),
          (t.prototype.getMode = function () {
            return this.mode;
          }),
          (t.prototype.manipulateBehaviors = function (e, n, r) {
            let i;
            const o = this;
            if (((i = Object(u.f)(e) ? e : [e]), Object(u.f)(n)))
              return (
                Object(u.c)(n, (e) => {
                  o.modes[e]
                    ? (o.modes[e] = r
                        ? t.mergeBehaviors(o.modes[e] || [], i)
                        : t.filterBehaviors(o.modes[e] || [], i))
                    : r && (o.modes[e] = i);
                }),
                this
              );
            let a = n;
            return (
              n || (a = this.mode),
              this.modes[a] || (r && (this.modes[a] = i)),
              (this.modes[a] = r
                ? t.mergeBehaviors(this.modes[a] || [], i)
                : t.filterBehaviors(this.modes[a] || [], i)),
              this.setMode(this.mode),
              this
            );
          }),
          (t.prototype.updateBehavior = function (t, e, n) {
            Object(u.o)(t) && (t = { type: t });
            let r = [];
            if (n && n !== this.mode && n !== 'default') {
              if (!(r = this.modes[n]) || !r.length)
                return (
                  console.warn(
                    'Update behavior failed! There is no behaviors in this mode on the graph.',
                  ),
                  this
                );
              const i = r.length;
              for (a = 0; a < i; a++) {
                if ((s = r[a]).type === t.type || s === t.type)
                  return s === t.type && (s = { type: s }), Object.assign(s, e), (r[a] = s), this;
                a === i - 1 &&
                  console.warn('Update behavior failed! There is no such behavior in the mode');
              }
            } else {
              if (!(r = this.currentBehaves) || !r.length)
                return (
                  console.warn(
                    'Update behavior failed! There is no behaviors in this mode on the graph.',
                  ),
                  this
                );
              for (var o = r.length, a = 0; a < o; a++) {
                var s;
                if ((s = r[a]).type === t.type) return s.updateCfg(e), this;
                a === o - 1 &&
                  console.warn('Update behavior failed! There is no such behavior in the mode');
              }
            }
            return this;
          }),
          (t.prototype.destroy = function () {
            (this.graph = null),
              (this.modes = null),
              (this.currentBehaves = null),
              (this.destroyed = !0);
          }),
          t
        );
      })();
      const Et = n(52);
      var kt = (function (t) {
        function e(e, n) {
          const r = t.call(this, e, n) || this;
          return (
            (r.item = n.item),
            (r.canvasX = n.canvasX),
            (r.canvasY = n.canvasY),
            (r.detail = n.detail),
            r
          );
        }
        return Object(f.c)(e, t), e;
      })(n(50).Event);
      var Tt = function (t) {
        return `${t}-${Math.random()}${Date.now()}`;
      };
      var Pt = function (t) {
        let e = 0;
        let n = 0;
        let r = 0;
        let i = 0;
        if (Object(u.k)(t)) e = n = r = i = t;
        else if (Object(u.o)(t)) {
          e = n = r = i = parseInt(t, 10);
        } else
          Object(u.f)(t) &&
            ((e = t[0]),
            (r = Object(u.j)(t[1]) ? t[0] : t[1]),
            (i = Object(u.j)(t[2]) ? t[0] : t[2]),
            (n = Object(u.j)(t[3]) ? r : t[3]));
        return [e, r, i, n];
      };
      var It = function (t) {
        const e = new kt(t.type, t);
        return (
          (e.clientX = t.clientX),
          (e.clientY = t.clientY),
          (e.x = t.x),
          (e.y = t.y),
          (e.target = t.target),
          (e.currentTarget = t.currentTarget),
          (e.bubbles = !0),
          (e.item = t.item),
          e
        );
      };
      var At = function (t) {
        if (!t) return !1;
        for (let e = [1, 0, 0, 0, 1, 0, 0, 0, 1], n = 0; n < 9; n++) if (t[n] !== e[n]) return !0;
        return !1;
      };
      var jt = function (t) {
        return Number.isNaN(Number(t));
      };
      var Nt = function (t) {
        for (var e = 1 / 0, n = -1 / 0, r = 1 / 0, i = -1 / 0, o = 0; o < t.length; o++) {
          const a = t[o].getBBox();
          const s = a.minX;
          const u = a.minY;
          const c = a.maxX;
          const h = a.maxY;
          s < e && (e = s), u < r && (r = u), c > n && (n = c), h > i && (i = h);
        }
        return {
          x: Math.floor(e),
          y: Math.floor(r),
          width: Math.ceil(n) - Math.floor(e),
          height: Math.ceil(i) - Math.floor(r),
          minX: e,
          minY: r,
          maxX: n,
          maxY: i,
        };
      };
      var _t = function (t, e, n, r, i) {
        void 0 === e && (e = 15),
          void 0 === n && (n = 'quadratic'),
          void 0 === r && (r = void 0),
          void 0 === i && (i = void 0);
        for (
          var o = t.length,
            a = 2 * e,
            s = [
              'top',
              'top-right',
              'right',
              'bottom-right',
              'bottom',
              'bottom-left',
              'left',
              'top-left',
            ],
            u = {},
            c = [],
            h = {},
            l = 0;
          l < o;
          l++
        ) {
          const f = t[l];
          const d = f.source;
          const p = f.target;
          const g = `${d}-${p}`;
          if (!c[l]) {
            u[g] || (u[g] = []), (c[l] = !0), u[g].push(f);
            for (let v = 0; v < o; v++)
              if (l !== v) {
                const y = t[v];
                const m = y.source;
                const b = y.target;
                c[v] ||
                  (d === b && p === m
                    ? (u[g].push(y), (c[v] = !0), (h[`${m}|${b}|${u[g].length - 1}`] = !0))
                    : d === m && p === b && (u[g].push(y), (c[v] = !0)));
              }
          }
        }
        for (const x in u)
          for (let M = u[x], S = M.length, w = 0; w < S; w++) {
            const O = M[w];
            if (O.source !== O.target)
              if (S === 1 && r && O.source !== O.target) O.type = r;
              else {
                O.type = n;
                const C = (w % 2 == 0 ? 1 : -1) * (h[`${O.source}|${O.target}|${w}`] ? -1 : 1);
                O.curveOffset =
                  S % 2 == 1 ? C * Math.ceil(w / 2) * a : C * (Math.floor(w / 2) * a + e);
              }
            else
              i && (O.type = i),
                (O.loopCfg = { position: s[w % 8], dist: 20 * Math.floor(w / 8) + 50 });
          }
        return t;
      };
      const Bt = (function () {
        function t(t) {
          (this.destroyed = !1), (this.graph = t), (this.destroyed = !1);
        }
        return (
          (t.prototype.getViewCenter = function () {
            const t = this.getFormatPadding();
            const e = this.graph;
            const n = this.graph.get('width');
            const r = e.get('height');
            return { x: (n - t[1] - t[3]) / 2 + t[3], y: (r - t[0] - t[2]) / 2 + t[0] };
          }),
          (t.prototype.fitCenter = function () {
            const t = this.graph;
            const e = t.get('group');
            e.resetMatrix();
            const n = e.getCanvasBBox();
            if (n.width !== 0 && n.height !== 0) {
              const r = this.getViewCenter();
              const i = n.x + n.width / 2;
              const o = n.y + n.height / 2;
              t.translate(r.x - i, r.y - o);
            }
          }),
          (t.prototype.fitView = function () {
            const t = this.graph;
            const e = this.getFormatPadding();
            const n = t.get('width');
            const r = t.get('height');
            const i = t.get('group');
            i.resetMatrix();
            const o = i.getCanvasBBox();
            if (o.width !== 0 && o.height !== 0) {
              const a = this.getViewCenter();
              const s = o.x + o.width / 2;
              const u = o.y + o.height / 2;
              t.translate(a.x - s, a.y - u);
              const c = (n - e[1] - e[3]) / o.width;
              const h = (r - e[0] - e[2]) / o.height;
              let l = c;
              c > h && (l = h), t.zoom(l, a);
            }
          }),
          (t.prototype.getFormatPadding = function () {
            const t = this.graph.get('fitViewPadding');
            return Pt(t);
          }),
          (t.prototype.focusPoint = function (t, e, n) {
            const r = this;
            const i = this.getViewCenter();
            const o = this.getPointByCanvas(i.x, i.y);
            let a = this.graph.get('group').getMatrix();
            if ((a || (a = [1, 0, 0, 0, 1, 0, 0, 0, 1]), e)) {
              const s = (o.x - t.x) * a[0];
              const u = (o.y - t.y) * a[4];
              let c = 0;
              let h = 0;
              let l = 0;
              let d = 0;
              this.graph.get('canvas').animate((t) => {
                (l = s * t), (d = u * t), r.graph.translate(l - c, d - h), (c = l), (h = d);
              }, Object(f.a)({}, n));
            } else this.graph.translate((o.x - t.x) * a[0], (o.y - t.y) * a[4]);
          }),
          (t.prototype.getPointByCanvas = function (t, e) {
            let n = this.graph.get('group').getMatrix();
            return n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), k({ x: t, y: e }, n);
          }),
          (t.prototype.getPointByClient = function (t, e) {
            const n = this.graph.get('canvas').getPointByClient(t, e);
            return this.getPointByCanvas(n.x, n.y);
          }),
          (t.prototype.getClientByPoint = function (t, e) {
            const n = this.graph.get('canvas');
            const r = this.getCanvasByPoint(t, e);
            const i = n.getClientByPoint(r.x, r.y);
            return { x: i.x, y: i.y };
          }),
          (t.prototype.getCanvasByPoint = function (t, e) {
            let n = this.graph.get('group').getMatrix();
            return n || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), E({ x: t, y: e }, n);
          }),
          (t.prototype.focus = function (t, e, n) {
            if ((Object(u.o)(t) && (t = this.graph.findById(t)), t)) {
              let r = 0;
              let i = 0;
              if (t.getType && t.getType() === 'edge') {
                const o = t.getSource().get('group').getMatrix();
                const a = t.getTarget().get('group').getMatrix();
                o && a
                  ? ((r = (o[6] + a[6]) / 2), (i = (o[7] + a[7]) / 2))
                  : (o || a) && ((r = o ? o[6] : a[6]), (i = o ? o[7] : a[7]));
              } else {
                let s = t.get('group').getMatrix();
                s || (s = [1, 0, 0, 0, 1, 0, 0, 0, 1]), (r = s[6]), (i = s[7]);
              }
              this.focusPoint({ x: r, y: i }, e, n);
            }
          }),
          (t.prototype.changeSize = function (t, e) {
            const n = this.graph;
            if (!Object(u.k)(t) || !Object(u.k)(e))
              throw Error(
                'invalid canvas width & height, please make sure width & height type is number',
              );
            n.set({ width: t, height: e }),
              n.get('canvas').changeSize(t, e),
              n.get('plugins').forEach((r) => {
                if (r.get('gridContainer')) {
                  const i = n.get('minZoom');
                  Object(Et.b)(r.get('container'), { width: `${t}px`, height: `${e}px` }),
                    Object(Et.b)(r.get('gridContainer'), {
                      width: `${t / i}px`,
                      height: `${e / i}px`,
                      left: 0,
                      top: 0,
                    });
                }
              });
          }),
          (t.prototype.destroy = function () {
            (this.graph = null), (this.destroyed = !1);
          }),
          t
        );
      })();
      function Lt(t) {
        return (Lt =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      function Dt(t) {
        if (typeof t !== 'string') return t;
        const e = function (t) {
          if (typeof t !== 'string') return t;
          try {
            return JSON.parse(t.trim());
          } catch (e) {
            return t.trim();
          }
        };
        const n = e(t);
        if (typeof n !== 'string') return n;
        for (
          var r = function (t) {
              return t[t.length - 1];
            },
            i = t.trim(),
            o = [],
            a = [],
            s = function () {
              for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
              return t.some((t) => {
                return r(a) === t;
              });
            },
            u = null,
            c = 0,
            h = '';
          c < i.length;

        ) {
          const l = i[c];
          const f = s('"', "'");
          if (f || l.trim()) {
            const d = i[c - 1] === '\\';
            const p = s('}');
            const g = s(']');
            const v = s(',');
            const y = r(o);
            if (f)
              if (r(a) !== l || d) h += l;
              else {
                a.pop();
                const m = e(h);
                y.push(m), (u = m), (h = '');
              }
            else if (g && l === ',') h && (y.push(e(h)), (h = ''));
            else if (p && l === ':') a.push(','), h && (y.push(h), (h = ''));
            else if (v && l === ',') h && (y.push(e(h)), (h = '')), a.pop();
            else if (l === '}' && (p || v)) {
              h && (y.push(e(h)), (h = '')), v && a.pop();
              for (var b = {}, x = 1; x < y.length; x += 2) b[y[x - 1]] = y[x];
              o.pop(), o.length && r(o).push(b), a.pop(), (u = b);
            } else
              l === ']' && g
                ? (h && (y.push(e(h)), (h = '')),
                  o.pop(),
                  o.length && r(o).push(y),
                  a.pop(),
                  (u = y))
                : l === '{'
                ? (o.push([]), a.push('}'))
                : l === '['
                ? (o.push([]), a.push(']'))
                : l === '"'
                ? a.push('"')
                : l === "'"
                ? a.push("'")
                : (h += l);
            c += 1;
          } else c += 1;
        }
        return u || h;
      }
      function Rt(t, e) {
        let n;
        void 0 === e && (e = { x: 0, y: 0 });
        const r = Object(f.a)({ x: 0, y: 0, width: 0, height: 0 }, e);
        if ((n = t.children) === null || void 0 === n ? void 0 : n.length) {
          const i = t.attrs;
          const o = void 0 === i ? {} : i;
          const a = o.marginTop;
          const s = Object(f.a)({}, e);
          a && (s.y += a);
          for (let u = 0; u < t.children.length; u++) {
            t.children[u].attrs.key = `${o.key || 'root'} -${u} `;
            const c = Rt(t.children[u], s);
            if (c.bbox) {
              const h = c.bbox;
              c.attrs.next === 'inline' ? (s.x += c.bbox.width) : (s.y += c.bbox.height),
                h.width + h.x > r.width && (r.width = h.width + h.x),
                h.height + h.y > r.height && (r.height = h.height + h.y);
            }
          }
        }
        return (
          (t.bbox = (function (t, e, n) {
            let r;
            let i;
            const o = t.attrs;
            const a = void 0 === o ? {} : o;
            const s = { x: e.x || 0, y: e.y || 0, width: n.width || 0, height: n.height || 0 };
            switch (t.type) {
              case 'maker':
              case 'circle':
                a.r && ((i = 2 * a.r), (r = 2 * a.r));
                break;
              case 'text':
                a.text &&
                  ((i = mt(a.text, a.fontSize || 12)[0]),
                  (r = 16),
                  (s.y += r),
                  (s.height = r),
                  (s.width = i),
                  (t.attrs = Object(f.a)({ fontSize: 12, fill: '#000' }, a)));
                break;
              default:
                a.width && (i = a.width), a.height && (r = a.height);
            }
            return (
              r >= 0 && (s.height = r),
              i >= 0 && (s.width = i),
              a.marginTop && (s.y += a.marginTop),
              a.marginLeft && (s.x += a.marginLeft),
              s
            );
          })(t, e, r)),
          (t.attrs = Object(f.a)(Object(f.a)({}, t.attrs), t.bbox)),
          t
        );
      }
      function Yt(t) {
        const e = {};
        const n = function (e) {
          const n = (function (t) {
            return function (e) {
              for (var n = t.length, r = [], i = 0, o = ''; i < n; )
                if (t[i] === '{' && t[i + 1] === '{') r.push(o), (o = ''), (i += 2);
                else if (t[i] === '}' && t[i + 1] === '}') {
                  if (r.length) {
                    const a = r.pop();
                    (o = Object(u.d)(e, o, a.endsWith('=') ? `"{${o}}"` : o)), r.push(a + o);
                  }
                  (i += 2), (o = '');
                } else (o += t[i]), (i += 1);
              return (
                r.push(o),
                r
                  .map((t, e) => {
                    return r[e - 1] && r[e - 1].endsWith('=') ? `"{${t}}"` : t;
                  })
                  .join('')
              );
            };
          })(typeof t === 'function' ? t(e) : t)(e);
          const r = document.createElement('div');
          r.innerHTML = n;
          const i = Rt(
            (function t(e, n) {
              let r = {};
              const i = (e.getAttributeNames && e.getAttributeNames()) || [];
              const o =
                e.children &&
                Array.from(e.children).map((e) => {
                  return t(e, n);
                });
              const a = {};
              const s = e.tagName ? e.tagName.toLowerCase() : 'group';
              return (
                s === 'text' && (r.text = e.innerText),
                (a.type = s),
                s === 'img' && (a.type = 'image'),
                Array.from(i).forEach((t) => {
                  const n = t.split('-').reduce((t, e) => {
                    return t + e.charAt(0).toUpperCase() + e.slice(1);
                  });
                  const i = e.getAttribute(t);
                  try {
                    if (n === 'style' || n === 'attrs') {
                      const o = Dt(i);
                      r = Object(f.a)(Object(f.a)({}, r), o);
                    } else a[n] = Dt(i);
                  } catch (t) {
                    if (n === 'style') throw t;
                    a[n] = i;
                  }
                }),
                (a.attrs = r),
                n &&
                  n.style &&
                  a.name &&
                  Lt(n.style[a.name]) === 'object' &&
                  (a.attrs = Object(f.a)(Object(f.a)({}, a.attrs), n.style[a.name])),
                n &&
                  n.style &&
                  a.keyshape &&
                  (a.attrs = Object(f.a)(Object(f.a)({}, a.attrs), n.style)),
                o.length && (a.children = o),
                a
              );
            })(r.children[0], e),
          );
          return r.remove(), i;
        };
        return {
          draw(t, r) {
            const i = n(t);
            let o = r;
            return (
              (function t(e) {
                const n = e.attrs;
                const i = void 0 === n ? {} : n;
                const a = e.bbox;
                const s = e.type;
                const u = e.children;
                const c = Object(f.e)(e, ['attrs', 'bbox', 'type', 'children']);
                if (e.type !== 'group') {
                  const h = r.addShape(
                    e.type,
                    Object(f.a)({ attrs: i, origin: { bbox: a, type: s, children: u } }, c),
                  );
                  e.keyshape && (o = h);
                }
                e.children &&
                  e.children.forEach((e) => {
                    return t(e);
                  });
              })(i),
              (e[t.id] = [i]),
              o
            );
          },
          update(t, r) {
            e[t.id] || (e[t.id] = []);
            const i = r.getContainer();
            const o = i.get('children');
            const a = n(t);
            const s = (function t(e, n) {
              let r;
              let i;
              let o;
              let a;
              const s = (e || {}).type;
              const u = ((n == null ? void 0 : n.attrs) || {}).key;
              if ((u && e && (e.attrs.key = u), !e && n))
                return { action: 'delete', val: n, type: s, key: u };
              if (e && !n) return { action: 'add', val: e, type: s };
              if (!e && !n) return { action: 'same', type: s };
              const c = [];
              if (
                ((r = e.children) === null || void 0 === r ? void 0 : r.length) > 0 ||
                ((i = n.children) === null || void 0 === i ? void 0 : i.length) > 0
              )
                for (
                  let h = Math.max(
                      (o = e.children) === null || void 0 === o ? void 0 : o.length,
                      (a = n.children) === null || void 0 === a ? void 0 : a.length,
                    ),
                    l = n.children || [],
                    f = e.children || [],
                    d = 0;
                  d < h;
                  d += 1
                )
                  c.push(t(f[d], l[d]));
              const p = Object.keys(n.attrs);
              const g = Object.keys(e.attrs);
              return n.type !== e.type
                ? { action: 'restructure', nowTarget: e, formerTarget: n, key: u, children: c }
                : p
                    .filter((t) => {
                      return t !== 'children';
                    })
                    .some((t) => {
                      return e.attrs[t] !== n.attrs[t] || !g.includes(t);
                    })
                ? { action: 'change', val: e, children: c, type: s, key: u }
                : { action: 'same', children: c, type: s, key: u };
            })(a, e[t.id].pop());
            const u = function t(e) {
              let n;
              e.type !== 'group' && i.addShape(e.type, { attrs: e.attrs }),
                ((n = e.children) === null || void 0 === n ? void 0 : n.length) &&
                  e.children.map((e) => {
                    return t(e);
                  });
            };
            const c = function t(e) {
              let n;
              const r = o.find((t) => {
                return t.attrs.key === e.attrs.key;
              });
              r && i.removeChild(r),
                ((n = e.children) === null || void 0 === n ? void 0 : n.length) &&
                  e.children.map((e) => {
                    return t(e);
                  });
            };
            !(function t(e) {
              const n = e.key;
              if (e.type !== 'group') {
                const i = o.find((t) => {
                  return t.attrs.key === n;
                });
                switch (e.action) {
                  case 'change':
                    if (i) {
                      const a = e.val.keyshape ? r.getOriginStyle() : {};
                      i.attr(Object(f.a)(Object(f.a)({}, a), e.val.attrs));
                    }
                    break;
                  case 'add':
                    u(e.val);
                    break;
                  case 'delete':
                    c(e.val);
                    break;
                  case 'restructure':
                    c(e.formerTarget), u(e.nowTarget);
                }
              }
              e.children &&
                e.children.forEach((e) => {
                  return t(e);
                });
            })(s),
              e[t.id].push(a);
          },
          getAnchorPoints() {
            return [
              [0, 0.5],
              [1, 0.5],
              [0.5, 1],
              [0.5, 0],
            ];
          },
        };
      }
      const Ft = {};
      function Xt(t) {
        return Ft[t] || (Ft[t] = Object(u.w)(t)), Ft[t];
      }
      const zt = {
        defaultShapeType: 'defaultType',
        className: null,
        getShape(t) {
          return this[t] || this[this.defaultShapeType] || this['simple-circle'];
        },
        draw(t, e, n) {
          const r = this.getShape(t);
          const i = r.draw(e, n);
          return r.afterDraw && r.afterDraw(e, n, i), i;
        },
        baseUpdate(t, e, n) {
          const r = this.getShape(t);
          r.update && r.update(e, n), r.afterUpdate && r.afterUpdate(e, n);
        },
        setState(t, e, n, r) {
          this.getShape(t).setState(e, n, r);
        },
        shouldUpdate(t) {
          return !!this.getShape(t).update;
        },
        getControlPoints(t, e) {
          return this.getShape(t).getControlPoints(e);
        },
        getAnchorPoints(t, e) {
          return this.getShape(t).getAnchorPoints(e);
        },
      };
      const Wt = {
        options: {},
        draw(t, e) {
          return this.drawShape(t, e);
        },
        drawShape() {},
        afterDraw() {},
        afterUpdate() {},
        setState() {},
        getControlPoints(t) {
          return t.controlPoints;
        },
        getAnchorPoints(t) {
          const e = this.options.anchorPoints;
          return t.anchorPoints || e;
        },
      };
      const Gt = (function () {
        function t() {}
        return (
          (t.registerFactory = function (e, n) {
            const r = Xt(e);
            const i = zt;
            const o = Object(f.a)(Object(f.a)({}, i), n);
            return (t[r] = o), (o.className = r), o;
          }),
          (t.getFactory = function (e) {
            return t[Xt(e)];
          }),
          (t.registerNode = function (e, n, r) {
            let i;
            const o = t.Node;
            if (typeof n === 'string' || typeof n === 'function') {
              var a = Yt(n);
              i = Object(f.a)(Object(f.a)({}, o.getShape('single-node')), a);
            } else if (n.jsx) {
              a = Yt(n.jsx);
              i = Object(f.a)(Object(f.a)(Object(f.a)({}, o.getShape('single-node')), a), n);
            } else {
              o.getShape(r);
              const s = r ? o.getShape(r) : Wt;
              i = Object(f.a)(Object(f.a)({}, s), n);
            }
            return (i.type = e), (i.itemType = 'node'), (o[e] = i), i;
          }),
          (t.registerEdge = function (e, n, r) {
            const i = t.Edge;
            const o = r ? i.getShape(r) : Wt;
            const a = Object(f.a)(Object(f.a)({}, o), n);
            return (a.type = e), (a.itemType = 'edge'), (i[e] = a), a;
          }),
          (t.registerCombo = function (e, n, r) {
            const i = t.Combo;
            const o = r ? i.getShape(r) : Wt;
            const a = Object(f.a)(Object(f.a)({}, o), n);
            return (a.type = e), (a.itemType = 'combo'), (i[e] = a), a;
          }),
          t
        );
      })();
      const Ut = Gt;
      Gt.registerFactory('node', { defaultShapeType: 'circle' }),
        Gt.registerFactory('edge', { defaultShapeType: 'line' }),
        Gt.registerFactory('combo', { defaultShapeType: 'circle' });
      const Ht = (function () {
        function t(t) {
          (this._cfg = {}), (this.destroyed = !1);
          const e = {
            id: void 0,
            type: 'item',
            model: {},
            group: void 0,
            animate: !1,
            visible: !0,
            locked: !1,
            event: !0,
            keyShape: void 0,
            states: [],
          };
          this._cfg = Object.assign(e, this.getDefaultCfg(), t);
          const n = this.get('model');
          let r = n.id;
          const i = this.get('type');
          r || ((r = Tt(i)), (this.get('model').id = r)), this.set('id', r);
          const o = t.group;
          o && (o.set('item', this), o.set('id', r)), this.init(), this.draw();
          const a = n.shape || n.type || (i === 'edge' ? 'line' : 'circle');
          const s = this.get('shapeFactory');
          if (s && s[a]) {
            const c = s[a].options;
            if (c && c.stateStyles) {
              let h = this.get('styles') || n.stateStyles;
              (h = Object(u.b)({}, c.stateStyles, h)), this.set('styles', h);
            }
          }
        }
        return (
          (t.prototype.calculateBBox = function () {
            const t = this.get('keyShape');
            const e = this.get('group');
            const n = lt(t, e);
            return (
              (n.x = n.minX),
              (n.y = n.minY),
              (n.width = n.maxX - n.minX),
              (n.height = n.maxY - n.minY),
              (n.centerX = (n.minX + n.maxX) / 2),
              (n.centerY = (n.minY + n.maxY) / 2),
              n
            );
          }),
          (t.prototype.calculateCanvasBBox = function () {
            const t = this.get('keyShape');
            const e = this.get('group');
            const n = lt(t, e);
            return (
              (n.x = n.minX),
              (n.y = n.minY),
              (n.width = n.maxX - n.minX),
              (n.height = n.maxY - n.minY),
              (n.centerX = (n.minX + n.maxX) / 2),
              (n.centerY = (n.minY + n.maxY) / 2),
              n
            );
          }),
          (t.prototype.drawInner = function () {
            const t = this.get('shapeFactory');
            const e = this.get('group');
            const n = this.get('model');
            e.clear();
            const r = n.visible;
            if ((void 0 === r || r || this.changeVisibility(r), t)) {
              this.updatePosition(n);
              const i = this.getShapeCfg(n);
              const o = i.type;
              const a = t.draw(o, i, e);
              a && (this.set('keyShape', a), a.set('isKeyShape', !0), a.set('draggable', !0)),
                this.setOriginStyle(),
                this.set('currentShape', o),
                this.restoreStates(t, o);
            }
          }),
          (t.prototype.setOriginStyle = function () {
            const t = this.get('group').get('children');
            const e = this.getKeyShape();
            const n = this;
            const r = e.get('name');
            if (this.get('originStyle')) {
              const i = this.getOriginStyle();
              r && !i[r] && (i[r] = {});
              const o = this.getCurrentStatesStyle();
              Object(u.c)(t, (t) => {
                const e = t.get('name');
                const a = t.attr();
                if (e && e !== r) {
                  const s = o[e];
                  i[e] || (i[e] = {}),
                    s
                      ? Object.keys(a).forEach((t) => {
                          const n = a[t];
                          n !== s[t] && (i[e][t] = n);
                        })
                      : (i[e] =
                          t.get('type') !== 'image' ? Object(u.a)(a) : n.getShapeStyleByName(e));
                } else {
                  const c = t.attr();
                  const h = Object(f.a)(Object(f.a)({}, o), o[r]);
                  Object.keys(c).forEach((t) => {
                    const e = c[t];
                    h[t] !== e && (r ? (i[r][t] = e) : (i[t] = e));
                  });
                }
              }),
                i.path && delete i.path,
                i.matrix && delete i.matrix,
                i.x && delete i.x,
                i.y && delete i.y,
                i[r] && i[r].x && delete i[r].x,
                i[r] && i[r].y && delete i[r].y,
                n.set('originStyle', i);
            } else {
              const a = {};
              Object(u.c)(t, (t) => {
                const e = t.get('type');
                const i = t.get('name');
                if (i && i !== r)
                  a[i] = e !== 'image' ? Object(u.a)(t.attr()) : n.getShapeStyleByName(i);
                else {
                  const o = n.getShapeStyleByName();
                  if ((o.path && delete o.path, o.matrix && delete o.matrix, r))
                    if (i) a[r] = o;
                    else {
                      const s = Tt('shape');
                      t.set('name', s),
                        (a[s] = e !== 'image' ? Object(u.a)(t.attr()) : n.getShapeStyleByName(i));
                    }
                  else Object.assign(a, o);
                }
              }),
                n.set('originStyle', a);
            }
          }),
          (t.prototype.restoreStates = function (t, e) {
            const n = this;
            const r = n.get('states');
            Object(u.c)(r, (r) => {
              t.setState(e, r, !0, n);
            });
          }),
          (t.prototype.init = function () {
            const t = Ut.getFactory(this.get('type'));
            this.set('shapeFactory', t);
          }),
          (t.prototype.get = function (t) {
            return this._cfg[t];
          }),
          (t.prototype.set = function (t, e) {
            Object(u.n)(t)
              ? (this._cfg = Object(f.a)(Object(f.a)({}, this._cfg), t))
              : (this._cfg[t] = e);
          }),
          (t.prototype.getDefaultCfg = function () {
            return {};
          }),
          (t.prototype.clearCache = function () {
            this.set('bboxCache', null), this.set('bboxCanvasCache', null);
          }),
          (t.prototype.beforeDraw = function () {}),
          (t.prototype.afterDraw = function () {}),
          (t.prototype.afterUpdate = function () {}),
          (t.prototype.draw = function () {
            this.beforeDraw(), this.drawInner(), this.afterDraw();
          }),
          (t.prototype.getShapeStyleByName = function (t) {
            let e;
            const n = this.get('group');
            if (
              (e = t
                ? n.find((e) => {
                    return e.get('name') === t;
                  })
                : this.getKeyShape())
            ) {
              const r = {};
              return (
                Object(u.c)(e.attr(), (t, e) => {
                  e !== 'img' && (r[e] = t);
                }),
                r
              );
            }
            return {};
          }),
          (t.prototype.getShapeCfg = function (t) {
            const e = this.get('styles');
            if (e) {
              const n = t;
              return (n.style = Object(f.a)(Object(f.a)({}, e), t.style)), n;
            }
            return t;
          }),
          (t.prototype.getStateStyle = function (t) {
            const e = this.get('styles');
            return e && e[t];
          }),
          (t.prototype.getOriginStyle = function () {
            return this.get('originStyle');
          }),
          (t.prototype.getCurrentStatesStyle = function () {
            const t = this;
            let e = {};
            const n = t.getStates();
            return n && n.length
              ? (Object(u.c)(t.getStates(), (n) => {
                  e = Object.assign(e, t.getStateStyle(n));
                }),
                e)
              : this.getOriginStyle();
          }),
          (t.prototype.setState = function (t, e) {
            const n = this.get('states');
            const r = this.get('shapeFactory');
            let i = t;
            let o = t;
            Object(u.o)(e) && ((i = `${t}:${e}`), (o = `${t}:`));
            let a = n;
            if (Object(u.g)(e)) {
              const s = n.indexOf(o);
              if (e) {
                if (s > -1) return;
                n.push(i);
              } else s > -1 && n.splice(s, 1);
            } else if (Object(u.o)(e)) {
              const c = n.filter((t) => {
                return t.includes(o);
              });
              c.length > 0 && this.clearStates(c),
                (a = a.filter((t) => {
                  return !t.includes(o);
                })).push(i),
                this.set('states', a);
            }
            if (r) {
              const h = this.get('model').type;
              r.setState(h, t, e, this);
            }
          }),
          (t.prototype.clearStates = function (t) {
            const e = this;
            const n = e.getStates();
            const r = e.get('shapeFactory');
            const i = e.get('model').type;
            t || (t = n), Object(u.o)(t) && (t = [t]);
            const o = n.filter((e) => {
              return t.indexOf(e) === -1;
            });
            e.set('states', o),
              t.forEach((t) => {
                r.setState(i, t, !1, e);
              });
          }),
          (t.prototype.getContainer = function () {
            return this.get('group');
          }),
          (t.prototype.getKeyShape = function () {
            return this.get('keyShape');
          }),
          (t.prototype.getModel = function () {
            return this.get('model');
          }),
          (t.prototype.getType = function () {
            return this.get('type');
          }),
          (t.prototype.getID = function () {
            return this.get('id');
          }),
          (t.prototype.isItem = function () {
            return !0;
          }),
          (t.prototype.getStates = function () {
            return this.get('states');
          }),
          (t.prototype.hasState = function (t) {
            return this.getStates().indexOf(t) >= 0;
          }),
          (t.prototype.refresh = function () {
            const t = this.get('model');
            this.updatePosition(t), this.updateShape(), this.afterUpdate(), this.clearCache();
          }),
          (t.prototype.isOnlyMove = function (t) {
            return !1;
          }),
          (t.prototype.update = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.get('model');
            const r = n.visible;
            const i = t.visible;
            r !== i && void 0 !== i && this.changeVisibility(i);
            const o = n.x;
            const a = n.y;
            (t.x = isNaN(t.x) ? n.x : t.x), (t.y = isNaN(t.y) ? n.y : t.y);
            const s = this.get('styles');
            if (t.stateStyles) {
              const c = t.stateStyles;
              Object(u.r)(s, c), delete t.stateStyles;
            }
            Object.assign(n, t),
              e
                ? this.updatePosition(t)
                : ((o === t.x && a === t.y) || this.updatePosition(t), this.updateShape()),
              this.afterUpdate(),
              this.clearCache();
          }),
          (t.prototype.updateShape = function () {
            const t = this.get('shapeFactory');
            const e = this.get('model');
            const n = e.type;
            if (t.shouldUpdate(n) && n === this.get('currentShape')) {
              const r = this.getShapeCfg(e);
              t.baseUpdate(n, r, this), this.setOriginStyle();
            } else this.draw();
            this.restoreStates(t, n);
          }),
          (t.prototype.updatePosition = function (t) {
            const e = this.get('model');
            const n = Object(u.j)(t.x) ? e.x : t.x;
            const r = Object(u.j)(t.y) ? e.y : t.y;
            const i = this.get('group');
            if (Object(u.j)(n) || Object(u.j)(r)) return !1;
            (e.x = n), (e.y = r);
            const o = i.getMatrix();
            return (
              (!o || o[6] !== n || o[7] !== r) &&
              (i.resetMatrix(), N(i, { x: n, y: r }), this.clearCache(), !0)
            );
          }),
          (t.prototype.getBBox = function () {
            let t = this.get('bboxCache');
            return t || ((t = this.calculateBBox()), this.set('bboxCache', t)), t;
          }),
          (t.prototype.getCanvasBBox = function () {
            let t = this.get('bboxCanvasCache');
            return t || ((t = this.calculateCanvasBBox()), this.set('bboxCanvasCache', t)), t;
          }),
          (t.prototype.toFront = function () {
            this.get('group').toFront();
          }),
          (t.prototype.toBack = function () {
            this.get('group').toBack();
          }),
          (t.prototype.show = function () {
            this.changeVisibility(!0);
          }),
          (t.prototype.hide = function () {
            this.changeVisibility(!1);
          }),
          (t.prototype.changeVisibility = function (t) {
            const e = this.get('group');
            t ? e.show() : e.hide(), this.set('visible', t);
          }),
          (t.prototype.isVisible = function () {
            return this.get('visible');
          }),
          (t.prototype.enableCapture = function (t) {
            const e = this.get('group');
            e && e.set('capture', t);
          }),
          (t.prototype.destroy = function () {
            if (!this.destroyed) {
              const t = this.get('animate');
              const e = this.get('group');
              t && e.stopAnimate(),
                this.clearCache(),
                e.remove(),
                (this._cfg = null),
                (this.destroyed = !0);
            }
          }),
          t
        );
      })();
      const qt = { source: 'start', target: 'end' };
      var Vt = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          Object(f.c)(e, t),
          (e.prototype.getDefaultCfg = function () {
            return {
              type: 'edge',
              sourceNode: null,
              targetNode: null,
              startPoint: null,
              endPoint: null,
              linkCenter: !1,
            };
          }),
          (e.prototype.setEnd = function (t, e) {
            const n = `${qt[t]}Point`;
            const r = `${t}Node`;
            const i = this.get(r);
            i && !i.destroyed && i.removeEdge(this),
              Object(u.n)(e)
                ? (this.set(n, e), this.set(r, null))
                : (e.addEdge(this), this.set(r, e), this.set(n, null));
          }),
          (e.prototype.getLinkPoint = function (t, e, n) {
            const r = `${qt[t]}Point`;
            const i = `${t}Node`;
            let o = this.get(r);
            if (!o) {
              const a = this.get(i);
              const s = `${t}Anchor`;
              const c = this.getPrePoint(t, n);
              const h = e[s];
              Object(u.j)(h) || (o = a.getLinkPointByAnchor(h)),
                (o = o || a.getLinkPoint(c)),
                Object(u.j)(o.index) || this.set(`${t}AnchorIndex`, o.index);
            }
            return o;
          }),
          (e.prototype.getPrePoint = function (t, e) {
            if (e && e.length) return e[t === 'source' ? 0 : e.length - 1];
            const n = t === 'source' ? 'target' : 'source';
            return this.getEndPoint(n);
          }),
          (e.prototype.getEndPoint = function (t) {
            const e = `${t}Node`;
            const n = `${qt[t]}Point`;
            const r = this.get(e);
            return r ? r.get('model') : this.get(n);
          }),
          (e.prototype.getControlPointsByCenter = function (t) {
            const e = this.getEndPoint('source');
            const n = this.getEndPoint('target');
            const r = this.get('shapeFactory');
            const i = t.type;
            return r.getControlPoints(i, { startPoint: e, endPoint: n });
          }),
          (e.prototype.getEndCenter = function (t) {
            const e = `${t}Node`;
            const n = `${qt[t]}Point`;
            const r = this.get(e);
            if (r) {
              const i = r.getBBox();
              return { x: i.centerX, y: i.centerY };
            }
            return this.get(n);
          }),
          (e.prototype.init = function () {
            t.prototype.init.call(this),
              this.setSource(this.get('source')),
              this.setTarget(this.get('target'));
          }),
          (e.prototype.getShapeCfg = function (e) {
            const n = this.get('linkCenter');
            const r = t.prototype.getShapeCfg.call(this, e);
            if (n)
              (r.startPoint = this.getEndCenter('source')),
                (r.endPoint = this.getEndCenter('target'));
            else {
              const i = r.controlPoints || this.getControlPointsByCenter(r);
              (r.startPoint = this.getLinkPoint('source', e, i)),
                (r.endPoint = this.getLinkPoint('target', e, i));
            }
            return (
              (r.sourceNode = this.get('sourceNode')), (r.targetNode = this.get('targetNode')), r
            );
          }),
          (e.prototype.getModel = function () {
            const t = this.get('model');
            const e = this.get('sourceNode');
            const n = this.get('targetNode');
            return (
              e ? delete t.sourceNode : (t.source = this.get('startPoint')),
              n ? delete t.targetNode : (t.target = this.get('endPoint')),
              Object(u.o)(t.source) || Object(u.n)(t.source) || (t.source = t.source.getID()),
              Object(u.o)(t.target) || Object(u.n)(t.target) || (t.target = t.target.getID()),
              t
            );
          }),
          (e.prototype.setSource = function (t) {
            this.setEnd('source', t), this.set('source', t);
          }),
          (e.prototype.setTarget = function (t) {
            this.setEnd('target', t), this.set('target', t);
          }),
          (e.prototype.getSource = function () {
            return this.get('source');
          }),
          (e.prototype.getTarget = function () {
            return this.get('target');
          }),
          (e.prototype.updatePosition = function () {
            return !1;
          }),
          (e.prototype.update = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.get('model');
            const r = n.visible;
            const i = t.visible;
            r !== i && void 0 !== i && this.changeVisibility(i);
            const o = this.get('styles');
            if (t.stateStyles) {
              const a = t.stateStyles;
              Object(u.r)(o, a), delete t.stateStyles;
            }
            Object.assign(n, t), this.updateShape(), this.afterUpdate(), this.clearCache();
          }),
          (e.prototype.destroy = function () {
            const e = this.get('sourceNode');
            const n = this.get('targetNode');
            e && !e.destroyed && e.removeEdge(this),
              n && !n.destroyed && n.removeEdge(this),
              t.prototype.destroy.call(this);
          }),
          e
        );
      })(Ht);
      var Zt = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          Object(f.c)(e, t),
          (e.prototype.getNearestPoint = function (t, e) {
            for (var n = 0, r = t[0], i = P(t[0], e), o = 0; o < t.length; o++) {
              const a = t[o];
              const s = P(a, e);
              s < i && ((r = a), (i = s), (n = o));
            }
            return (r.anchorIndex = n), r;
          }),
          (e.prototype.getDefaultCfg = function () {
            return { type: 'node', edges: [] };
          }),
          (e.prototype.getEdges = function () {
            return this.get('edges');
          }),
          (e.prototype.getInEdges = function () {
            const t = this;
            return this.get('edges').filter((e) => {
              return e.get('target') === t;
            });
          }),
          (e.prototype.getOutEdges = function () {
            const t = this;
            return this.get('edges').filter((e) => {
              return e.get('source') === t;
            });
          }),
          (e.prototype.getNeighbors = function (t) {
            const e = this;
            const n = this.get('edges');
            if (t === 'target') {
              return n
                .filter((t) => {
                  return t.getSource() === e;
                })
                .map((t) => {
                  return t.getTarget();
                });
            }
            if (t === 'source') {
              return n
                .filter((t) => {
                  return t.getTarget() === e;
                })
                .map((t) => {
                  return t.getSource();
                });
            }
            return n.map((t) => {
              return t.getSource() === e ? t.getTarget() : t.getSource();
            });
          }),
          (e.prototype.getLinkPointByAnchor = function (t) {
            return this.getAnchorPoints()[t];
          }),
          (e.prototype.getLinkPoint = function (t) {
            let e;
            let n;
            const r = this.get('keyShape').get('type');
            const i = this.get('type');
            const o = this.getBBox();
            i === 'combo'
              ? ((e = o.centerX || (o.maxX + o.minX) / 2), (n = o.centerY || (o.maxY + o.minY) / 2))
              : ((e = o.centerX), (n = o.centerY));
            let a;
            const s = this.getAnchorPoints();
            switch (r) {
              case 'circle':
                a = O({ x: e, y: n, r: o.width / 2 }, t);
                break;
              case 'ellipse':
                a = C({ x: e, y: n, rx: o.width / 2, ry: o.height / 2 }, t);
                break;
              default:
                a = w(o, t);
            }
            let u = a;
            return (
              s.length && (u || (u = t), (u = this.getNearestPoint(s, u))),
              u || (u = { x: e, y: n }),
              u
            );
          }),
          (e.prototype.getAnchorPoints = function () {
            let t = this.get('anchorPointsCache');
            if (!t) {
              t = [];
              const e = this.get('shapeFactory');
              const n = this.getBBox();
              const r = this.get('model');
              const i = this.getShapeCfg(r);
              const o = r.type;
              const a = e.getAnchorPoints(o, i) || [];
              Object(u.c)(a, (e, r) => {
                const i = {
                  x: n.minX + e[0] * n.width,
                  y: n.minY + e[1] * n.height,
                  anchorIndex: r,
                };
                t.push(i);
              }),
                this.set('anchorPointsCache', t);
            }
            return t;
          }),
          (e.prototype.addEdge = function (t) {
            this.get('edges').push(t);
          }),
          (e.prototype.lock = function () {
            this.set('locked', !0);
          }),
          (e.prototype.unlock = function () {
            this.set('locked', !1);
          }),
          (e.prototype.hasLocked = function () {
            return this.get('locked');
          }),
          (e.prototype.removeEdge = function (t) {
            const e = this.getEdges();
            const n = e.indexOf(t);
            n > -1 && e.splice(n, 1);
          }),
          (e.prototype.clearCache = function () {
            this.set('bboxCache', null), this.set('anchorPointsCache', null);
          }),
          (e.prototype.isOnlyMove = function (t) {
            if (!t) return !1;
            const e = !Object(u.j)(t.x);
            const n = !Object(u.j)(t.y);
            const r = Object.keys(t);
            return (r.length === 1 && (e || n)) || (r.length === 2 && e && n);
          }),
          e
        );
      })(Ht);
      var Kt = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          Object(f.c)(e, t),
          (e.prototype.getDefaultCfg = function () {
            return { type: 'combo', nodes: [], edges: [], combos: [] };
          }),
          (e.prototype.getShapeCfg = function (t) {
            const e = this.get('styles');
            const n = this.get('bbox');
            if (e && n) {
              const r = t;
              const i = {
                r: Math.hypot(n.height, n.width) / 2 || it.defaultCombo.size[0] / 2,
                width: n.width || it.defaultCombo.size[0],
                height: n.height || it.defaultCombo.size[1],
              };
              r.style = Object(f.a)(Object(f.a)(Object(f.a)({}, e), t.style), i);
              const o = t.padding || it.defaultCombo.padding;
              return (
                Object(u.k)(o)
                  ? ((i.r += o), (i.width += 2 * o), (i.height += 2 * o))
                  : ((i.r += o[0]),
                    (i.width += o[1] + o[3] || 2 * o[1]),
                    (i.height += o[0] + o[2] || 2 * o[0])),
                this.set('sizeCache', i),
                r
              );
            }
            return t;
          }),
          (e.prototype.calculateCanvasBBox = function () {
            if (!this.destroyed) {
              const t = this.get('keyShape');
              const e = this.get('group');
              const n = lt(t, e);
              (n.centerX = (n.minX + n.maxX) / 2), (n.centerY = (n.minY + n.maxY) / 2);
              const r = this.get('sizeCache');
              const i = this.get('bboxCache') || {};
              const o = i.x;
              const a = i.x;
              if (r)
                (r.width = Math.max(r.width, n.width)),
                  (r.height = Math.max(r.height, n.height)),
                  t.get('type') === 'circle'
                    ? ((n.width = 2 * r.r), (n.height = 2 * r.r))
                    : ((n.width = r.width), (n.height = r.height)),
                  (n.minX = n.centerX - n.width / 2),
                  (n.minY = n.centerY - n.height / 2),
                  (n.maxX = n.centerX + n.width / 2),
                  (n.maxY = n.centerY + n.height / 2);
              else
                (n.width = n.maxX - n.minX),
                  (n.height = n.maxY - n.minY),
                  (n.centerX = (n.minX + n.maxX) / 2),
                  (n.centerY = (n.minY + n.maxY) / 2);
              return (
                (n.x = n.minX),
                (n.y = n.minY),
                (n.x === o && n.y === a) || this.set('anchorPointsCache', null),
                n
              );
            }
          }),
          (e.prototype.getChildren = function () {
            return { nodes: this.getNodes(), combos: this.getCombos() };
          }),
          (e.prototype.getNodes = function () {
            return this.get('nodes');
          }),
          (e.prototype.getCombos = function () {
            return this.get('combos');
          }),
          (e.prototype.addChild = function (t) {
            switch (t.getType()) {
              case 'node':
                this.addNode(t);
                break;
              case 'combo':
                this.addCombo(t);
                break;
              default:
                return (
                  console.warn('Only node or combo items are allowed to be added into a combo'), !1
                );
            }
            return !0;
          }),
          (e.prototype.addCombo = function (t) {
            return this.get('combos').push(t), !0;
          }),
          (e.prototype.addNode = function (t) {
            return this.get('nodes').push(t), !0;
          }),
          (e.prototype.removeChild = function (t) {
            switch (t.getType()) {
              case 'node':
                this.removeNode(t);
                break;
              case 'combo':
                this.removeCombo(t);
                break;
              default:
                return (
                  console.warn('Only node or combo items are allowed to be added into a combo'), !1
                );
            }
            return !0;
          }),
          (e.prototype.removeCombo = function (t) {
            if (t) {
              const e = this.getCombos();
              const n = e.indexOf(t);
              return n > -1 && (e.splice(n, 1), !0);
            }
          }),
          (e.prototype.removeNode = function (t) {
            if (t) {
              const e = this.getNodes();
              const n = e.indexOf(t);
              return n > -1 && (e.splice(n, 1), !0);
            }
          }),
          (e.prototype.isOnlyMove = function (t) {
            return !1;
          }),
          (e.prototype.getBBox = function () {
            return this.set('bboxCanvasCache', null), this.calculateCanvasBBox();
          }),
          (e.prototype.clearCache = function () {
            this.set('bboxCache', null),
              this.set('bboxCanvasCache', null),
              this.set('anchorPointsCache', null);
          }),
          (e.prototype.destroy = function () {
            if (!this.destroyed) {
              const t = this.get('animate');
              const e = this.get('group');
              t && e.stopAnimate(),
                this.clearCache(),
                this.set('sizeCache', null),
                this.set('bbox', null),
                e.remove(),
                (this._cfg = null),
                (this.destroyed = !0);
            }
          }),
          e
        );
      })(Zt);
      const $t = (function () {
        function t(t) {
          (this.graph = t), (this.destroyed = !1);
        }
        return (
          (t.prototype.addItem = function (t, e) {
            const n = this.graph;
            const r = t === 'vedge' ? 'edge' : t;
            const i = n.get(`${r}Group`) || n.get('group');
            const o = Object(u.w)(r);
            let a = null;
            let s = n.get(r + Object(u.w)('stateStyles')) || {};
            const c = n.get(`default${o}`);
            e.stateStyles && (s = e.stateStyles),
              c &&
                Object(u.c)(c, (t, n) => {
                  Object(u.m)(t) && !Object(u.f)(t)
                    ? (e[n] = Object(u.b)({}, t, e[n]))
                    : Object(u.f)(t)
                    ? (e[n] = e[n] || Object(u.a)(c[n]))
                    : (e[n] = e[n] || c[n]);
                });
            const h = n.get(`${r}Mapper`);
            if (h) {
              const l = h(e);
              l.stateStyles && ((s = l.stateStyles), delete l.stateStyles),
                Object(u.c)(l, (t, n) => {
                  Object(u.m)(t) && !Object(u.f)(t)
                    ? (e[n] = Object(u.b)({}, e[n], t))
                    : (e[n] = l[n] || e[n]);
                });
            }
            if ((n.emit('beforeadditem', { type: t, model: e }), t === 'edge' || t === 'vedge')) {
              let f = void 0;
              let d = void 0;
              if (
                ((f = e.source),
                (d = e.target),
                f && Object(u.o)(f) && (f = n.findById(f)),
                d && Object(u.o)(d) && (d = n.findById(d)),
                !f || !d)
              )
                return void console.warn(
                  `The source or target node of edge ${e.id} does not exist!`,
                );
              f.getType && f.getType() === 'combo' && (e.isComboEdge = !0),
                d.getType && d.getType() === 'combo' && (e.isComboEdge = !0),
                (a = new Vt({
                  model: e,
                  source: f,
                  target: d,
                  styles: s,
                  linkCenter: n.get('linkCenter'),
                  group: i.addGroup(),
                }));
            } else if (t === 'node') a = new Zt({ model: e, styles: s, group: i.addGroup() });
            else if (t === 'combo') {
              const p = e.children;
              const g = Mt(p, n);
              isNaN(g.x) ? isNaN(e.x) && (e.x = 100 * Math.random()) : (e.x = g.x),
                isNaN(g.y) ? isNaN(e.y) && (e.y = 100 * Math.random()) : (e.y = g.y);
              const v = i.addGroup();
              v.setZIndex(e.depth);
              const y = (a = new Kt({
                model: e,
                styles: s,
                bbox: e.collapsed ? Mt([], n) : g,
                group: v,
              })).getModel();
              (p || []).forEach((t) => {
                const e = n.findById(t.id);
                a.addChild(e), (t.depth = y.depth + 2);
              }),
                e.collapsed &&
                  setTimeout(() => {
                    n.collapseCombo(a);
                  }, 16);
            }
            if (a)
              return (
                n.get(`${t}s`).push(a),
                (n.get('itemMap')[a.get('id')] = a),
                n.emit('afteradditem', { item: a, model: e }),
                a
              );
          }),
          (t.prototype.updateItem = function (t, e) {
            let n;
            let r;
            const i = this.graph;
            if ((Object(u.o)(t) && (t = i.findById(t)), t && !t.destroyed)) {
              let o = '';
              t.getType && (o = t.getType());
              const a = i.get(`${o}Mapper`);
              const s = t.getModel();
              const c = t.isOnlyMove(e);
              if (a) {
                const h = a(Object(u.b)({}, s, e));
                const l = Object(u.b)({}, s, h, e);
                h.stateStyles && (t.set('styles', l.stateStyles), delete l.stateStyles),
                  Object(u.c)(l, (t, n) => {
                    e[n] = t;
                  });
              } else
                Object(u.c)(e, (t, n) => {
                  s[n] &&
                    Object(u.m)(t) &&
                    !Object(u.f)(t) &&
                    (e[n] = Object(f.a)(Object(f.a)({}, s[n]), e[n]));
                });
              if ((i.emit('beforeupdateitem', { item: t, cfg: e }), o === 'edge')) {
                if (e.source) {
                  let d = e.source;
                  Object(u.o)(d) && (d = i.findById(d)), t.setSource(d);
                }
                if (e.target) {
                  let p = e.target;
                  Object(u.o)(p) && (p = i.findById(p)), t.setTarget(p);
                }
                t.update(e);
              }
              if (o === 'node' || o === 'combo') {
                t.update(e, c);
                const g = t.getEdges();
                const v = St(e);
                if (v && o === 'node')
                  Object(u.c)(g, (t) => {
                    t.refresh();
                  });
                else if (v && o === 'combo') {
                  const y = t.get('shapeFactory');
                  const m = s.type || 'circle';
                  (
                    void 0 === s.animate || void 0 === e.animate
                      ? (r = (n = y[m]) === null || void 0 === n ? void 0 : n.options) === null ||
                        void 0 === r
                        ? void 0
                        : r.animate
                      : s.animate || e.animate
                  )
                    ? setTimeout(() => {
                        if (t && !t.destroyed) {
                          const e = t.getKeyShape();
                          e &&
                            !e.destroyed &&
                            Object(u.c)(g, (t) => {
                              t && !t.destroyed && t.refresh();
                            });
                        }
                      }, 201)
                    : Object(u.c)(g, (t) => {
                        t.refresh();
                      });
                }
              }
              i.emit('afterupdateitem', { item: t, cfg: e });
            }
          }),
          (t.prototype.updateCombo = function (t, e) {
            let n;
            let r;
            const i = this;
            const o = this.graph;
            if ((Object(u.o)(t) && (t = o.findById(t)), t && !t.destroyed)) {
              const a = t.getModel();
              const s = Mt(a.collapsed ? [] : e, o);
              t.set('bbox', s), t.update({ x: s.x, y: s.y });
              const c = t.get('shapeFactory');
              const h = a.type || 'circle';
              (
                void 0 === a.animate
                  ? (r = (n = c[h]) === null || void 0 === n ? void 0 : n.options) === null ||
                    void 0 === r
                    ? void 0
                    : r.animate
                  : a.animate
              )
                ? setTimeout(() => {
                    if (t && !t.destroyed) {
                      const e = t.getKeyShape();
                      e && !e.destroyed && (t.getShapeCfg(a), i.updateComboEdges(t));
                    }
                  }, 201)
                : this.updateComboEdges(t);
            }
          }),
          (t.prototype.updateComboEdges = function (t) {
            for (let e = t.getEdges() || [], n = 0; n < e.length; n++) {
              const r = e[n];
              if (r && !r.destroyed) {
                const i = r.get('shapeFactory');
                const o = r.getShapeCfg(r.getModel());
                const a = r.getContainer();
                a.clear();
                const s = i.draw(o.type, o, a);
                r.set('keyShape', s),
                  s.set('isKeyShape', !0),
                  s.set('draggable', !0),
                  r.setOriginStyle();
              }
            }
          }),
          (t.prototype.collapseCombo = function (t) {
            const e = this.graph;
            Object(u.o)(t) && (t = e.findById(t));
            const n = t.getChildren();
            n.nodes.forEach((t) => {
              e.hideItem(t);
            }),
              n.combos.forEach((t) => {
                e.hideItem(t);
              });
          }),
          (t.prototype.expandCombo = function (t) {
            const e = this.graph;
            Object(u.o)(t) && (t = e.findById(t));
            const n = t.getChildren();
            n.nodes.forEach((t) => {
              e.showItem(t);
            }),
              n.combos.forEach((t) => {
                t.getModel().collapsed ? t.show() : e.showItem(t);
              });
          }),
          (t.prototype.removeItem = function (t) {
            const e = this;
            const n = this.graph;
            if ((Object(u.o)(t) && (t = n.findById(t)), t && !t.destroyed)) {
              const r = Object(u.a)(t.getModel());
              n.emit('beforeremoveitem', { item: r });
              let i = '';
              t.getType && (i = t.getType());
              const o = n.get(`${i}s`);
              const a = o.indexOf(t);
              if ((a > -1 && o.splice(a, 1), i === 'edge')) {
                const s = n.get(`v${i}s`);
                const c = s.indexOf(t);
                c > -1 && s.splice(c, 1);
              }
              const h = t.get('id');
              delete n.get('itemMap')[h];
              const l = n.get('comboTrees');
              const f = t.get('id');
              if (i === 'node') {
                const d = t.getModel().comboId;
                if (l && d) {
                  let p = l;
                  let g = !1;
                  l.forEach((t) => {
                    g ||
                      gt(t, (t) => {
                        if (t.id === f && p) {
                          const e = p.indexOf(t);
                          return p.splice(e, 1), (g = !0), !1;
                        }
                        return (p = t.children), !0;
                      });
                  });
                }
                for (var v = (x = t.getEdges()).length - 1; v >= 0; v--) n.removeItem(x[v], !1);
                d && n.updateCombo(d);
              } else if (i === 'combo') {
                let y;
                const m = t.getModel().parentId;
                let b = !1;
                (l || []).forEach((t) => {
                  b ||
                    gt(t, (t) => {
                      return t.id !== f || ((y = t), (b = !0), !1);
                    });
                }),
                  (y.removed = !0),
                  y &&
                    y.children &&
                    y.children.forEach((t) => {
                      e.removeItem(t.id);
                    });
                var x;
                for (v = (x = t.getEdges()).length; v >= 0; v--) n.removeItem(x[v], !1);
                m && n.updateCombo(m);
              }
              t.destroy(), n.emit('afterremoveitem', { item: r });
            }
          }),
          (t.prototype.setItemState = function (t, e, n) {
            const r = this.graph;
            let i = e;
            Object(u.o)(n) && (i = `${e}:${n}`),
              (t.hasState(i) === n && n) ||
                (Object(u.o)(n) && t.hasState(i)) ||
                (r.emit('beforeitemstatechange', { item: t, state: i, enabled: n }),
                t.setState(e, n),
                r.autoPaint(),
                r.emit('afteritemstatechange', { item: t, state: i, enabled: n }));
          }),
          (t.prototype.priorityState = function (t, e) {
            const n = this.graph;
            let r = t;
            Object(u.o)(t) && (r = n.findById(t)),
              this.setItemState(r, e, !1),
              this.setItemState(r, e, !0);
          }),
          (t.prototype.clearItemStates = function (t, e) {
            const n = this.graph;
            Object(u.o)(t) && (t = n.findById(t)),
              n.emit('beforeitemstatesclear', { item: t, states: e }),
              t.clearStates(e),
              n.emit('afteritemstatesclear', { item: t, states: e });
          }),
          (t.prototype.refreshItem = function (t) {
            const e = this.graph;
            Object(u.o)(t) && (t = e.findById(t)),
              e.emit('beforeitemrefresh', { item: t }),
              t.refresh(),
              e.emit('afteritemrefresh', { item: t });
          }),
          (t.prototype.addCombos = function (t, e) {
            const n = this;
            const r = this.graph;
            (t || []).forEach((t) => {
              vt(t, (t) => {
                let r;
                return (
                  e.forEach((e) => {
                    e.id === t.id && ((e.children = t.children), (e.depth = t.depth), (r = e));
                  }),
                  r && n.addItem('combo', r),
                  !0
                );
              });
            });
            const i = r.get('comboGroup');
            i && i.sort();
          }),
          (t.prototype.changeItemVisibility = function (t, e) {
            const n = this;
            const r = this.graph;
            if ((Object(u.o)(t) && (t = r.findById(t)), t)) {
              if (
                (r.emit('beforeitemvisibilitychange', { item: t, visible: e }),
                t.changeVisibility(e),
                t.getType && t.getType() === 'node')
              ) {
                var i = t.getEdges();
                Object(u.c)(i, (t) => {
                  (!e || (t.get('source').isVisible() && t.get('target').isVisible())) &&
                    n.changeItemVisibility(t, e);
                });
              } else if (t.getType && t.getType() === 'combo') {
                const o = r.get('comboTrees');
                const a = t.get('id');
                let s = [];
                let c = !1;
                (o || []).forEach((t) => {
                  c ||
                    (t.children &&
                      t.children.length !== 0 &&
                      gt(t, (t) => {
                        return t.id !== a || ((s = t.children), (c = !0), !1);
                      }));
                }),
                  s &&
                    (!e || (e && !t.getModel().collapsed)) &&
                    s.forEach((t) => {
                      const i = r.findById(t.id);
                      n.changeItemVisibility(i, e);
                    });
                i = t.getEdges();
                Object(u.c)(i, (t) => {
                  (!e || (t.get('source').isVisible() && t.get('target').isVisible())) &&
                    n.changeItemVisibility(t, e);
                });
              }
              return r.emit('afteritemvisibilitychange', { item: t, visible: e }), t;
            }
            console.warn('The item to be shown or hidden does not exist!');
          }),
          (t.prototype.destroy = function () {
            (this.graph = null), (this.destroyed = !0);
          }),
          t
        );
      })();
      let Qt = null;
      const Jt = (function () {
        function t(t) {
          (this.graph = t),
            (this.cachedStates = { enabled: {}, disabled: {} }),
            (this.destroyed = !1);
        }
        return (
          (t.checkCache = function (t, e, n) {
            if (n[e]) {
              const r = n[e].indexOf(t);
              r >= 0 && n[e].splice(r, 1);
            }
          }),
          (t.cacheState = function (t, e, n) {
            n[e] || (n[e] = []), n[e].push(t);
          }),
          (t.prototype.updateState = function (e, n, r) {
            const i = this;
            const o = t.checkCache;
            const a = t.cacheState;
            if (!e.destroyed) {
              const s = this.cachedStates;
              const u = s.enabled;
              const c = s.disabled;
              r ? (o(e, n, c), a(e, n, u)) : (o(e, n, u), a(e, n, c)),
                Qt && clearTimeout(Qt),
                (Qt = setTimeout(() => {
                  (Qt = null), i.updateGraphStates();
                }, 16));
            }
          }),
          (t.prototype.updateStates = function (t, e, n) {
            const r = this;
            Object(u.o)(e)
              ? this.updateState(t, e, n)
              : e.forEach((e) => {
                  r.updateState(t, e, n);
                });
          }),
          (t.prototype.updateGraphStates = function () {
            const t = this.graph.get('states');
            const e = this.cachedStates;
            Object(u.c)(e.disabled, (e, n) => {
              t[n] &&
                (t[n] = t[n].filter((t) => {
                  return e.indexOf(t) < 0 && !e.destroyed;
                }));
            }),
              Object(u.c)(e.enabled, (e, n) => {
                if (t[n]) {
                  const r = {};
                  t[n].forEach((t) => {
                    t.destroyed || (r[t.get('id')] = !0);
                  }),
                    e.forEach((e) => {
                      if (!e.destroyed) {
                        const i = e.get('id');
                        r[i] || ((r[i] = !0), t[n].push(e));
                      }
                    });
                } else t[n] = e;
              }),
              this.graph.emit('graphstatechange', { states: t }),
              (this.cachedStates = { enabled: {}, disabled: {} });
          }),
          (t.prototype.destroy = function () {
            (this.graph = null),
              (this.cachedStates = null),
              Qt && clearTimeout(Qt),
              (Qt = null),
              (this.destroyed = !0);
          }),
          t
        );
      })();
      const te = n(43);
      const ee = function (t, e) {
        return t && e
          ? t.replace(/\\?\{([^{}]+)\}/g, (t, n) => {
              if (t.charAt(0) === '\\') return t.slice(1);
              let r = e[n];
              return r === 0 && (r = '0'), r || '';
            })
          : t;
      };
      var ne = function (t) {
        const e = [];
        if (t.length < 2) throw new Error(`point length must largn than 2, now it's ${t.length}`);
        for (let n = 0, r = t; n < r.length; n++) {
          const i = r[n];
          const o = i.x;
          const a = i.y;
          e.push(o), e.push(a);
        }
        const s = Object(te.a)(e);
        return s.unshift(['M', t[0].x, t[0].y]), s;
      };
      var re = function (t, e, n, r) {
        void 0 === n && (n = 0), void 0 === r && (r = 0);
        const i = { x: (1 - n) * t.x + n * e.x, y: (1 - n) * t.y + n * e.y };
        let o = [0, 0];
        y.c.normalize(o, [e.x - t.x, e.y - t.y]), (o && (o[0] || o[1])) || (o = [0, 0]);
        const a = [-o[1] * r, o[0] * r];
        return (i.x += a[0]), (i.y += a[1]), i;
      };
      var ie = function (t, e) {
        const n = t.length;
        if (!n) return '';
        for (var r = '', i = 0; i < n; i++) {
          const o = t[i];
          r += ee(i === 0 ? 'M{x} {y}' : 'L{x} {y}', o);
        }
        return e && (r += 'Z'), r;
      };
      var oe = function (t) {
        const e = [];
        return (
          t.forEach((t) => {
            if (t[0] !== 'A') for (let n = 1; n < t.length; n += 2) e.push([t[n], t[n + 1]]);
            else {
              const r = t.length;
              e.push([t[r - 2], t[r - 1]]);
            }
          }),
          e
        );
      };
      var ae = function (t) {
        if (t.length < 2) throw new Error(`point length must largn than 2, now it's ${t.length}`);
        const e = t[0];
        const n = t[1];
        const r = t[t.length - 1];
        const i = t[t.length - 2];
        t.unshift(r), t.unshift(i), t.push(e), t.push(n);
        for (var o = [], a = 1; a < t.length - 2; a += 1) {
          const s = t[a - 1].x;
          const u = t[a - 1].y;
          const c = t[a].x;
          const h = t[a].y;
          const l = t[a + 1].x;
          const f = t[a + 1].y;
          const d = c + (l - s) / 6;
          const p = h + (f - u) / 6;
          const g = l - ((a !== t.length - 2 ? t[a + 2].x : l) - c) / 6;
          const v = f - ((a !== t.length - 2 ? t[a + 2].y : f) - h) / 6;
          o.push(['C', d, p, g, v, l, f]);
        }
        return o.unshift(['M', r.x, r.y]), o;
      };
      const se = function (t, e) {
        return y.c.scale([0, 0], y.c.normalize([0, 0], t), e);
      };
      const ue = function (t, e) {
        const n = [t[1] - e[1], e[0] - t[0]];
        const r = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
        if (r === 0) throw new Error('p0 should not be equal to p1');
        return [n[0] / r, n[1] / r];
      };
      const ce = function (t, e) {
        return [e[0] - t[0], e[1] - t[1]];
      };
      function he(t, e) {
        if (!t || t.length < 1) return '';
        if (t.length === 1)
          return (function (t) {
            const n = [t[0][0], t[0][1] - e];
            const r = [t[0][0], t[0][1] + e];
            return `M ${n} A ${e},${e},0,0,0,${r} A ${e},${e},0,0,0,${n}`;
          })(t);
        if (t.length === 2)
          return (function (t) {
            const n = y.c.scale([0, 0], ue(t[0], t[1]), e);
            const r = y.c.scale([0, 0], n, -1);
            const i = y.c.add([0, 0], t[0], n);
            const o = y.c.add([0, 0], t[1], n);
            const a = y.c.add([0, 0], t[1], r);
            const s = y.c.add([0, 0], t[0], r);
            return `M ${i} L ${o} A ${[e, e, '0,0,0', a].join(',')} L ${s} A ${[
              e,
              e,
              '0,0,0',
              i,
            ].join(',')}`;
          })(t);
        for (var n = new Array(t.length), r = 0; r < n.length; ++r) {
          const i = r === 0 ? t[t.length - 1] : t[r - 1];
          const o = t[r];
          const a = y.c.scale([0, 0], ue(i, o), e);
          n[r] = [y.c.add([0, 0], i, a), y.c.add([0, 0], o, a)];
        }
        const s = `A ${[e, e, '0,0,0,'].join(',')}`;
        return (n = n.map((t, e) => {
          let r = '';
          return e === 0 && (r = `M ${n[n.length - 1][1]} `), (r += `${s + t[0]} L ${t[1]}`);
        })).join(' ');
      }
      function le(t, e) {
        let n;
        let r;
        let i;
        const o = t.length;
        if (!t || o < 1) return '';
        if (o === 1)
          return (
            (r = [(n = t)[0][0], n[0][1] - e]),
            (i = [n[0][0], n[0][1] + e]),
            `M ${r} A ${[e, e, '0,0,0', i].join(',')} A ${[e, e, '0,0,0', r].join(',')}`
          );
        if (o === 2)
          return (function (t) {
            const n = ce(t[0], t[1]);
            const r = se(n, e);
            const i = y.c.add([0, 0], t[0], y.c.scale([0, 0], r, -1));
            const o = y.c.add([0, 0], t[1], r);
            const a = 1.2 * e;
            const s = se(y.c.normalize([0, 0], n), a);
            const u = y.c.scale([0, 0], s, -1);
            const c = y.c.add([0, 0], i, u);
            const h = y.c.add([0, 0], o, u);
            const l = y.c.add([0, 0], i, s);
            return `M ${i} C ${[c, h, o].join(',')} S ${[l, i].join(',')} Z`;
          })(t);
        for (
          var a = t.map((e, n) => {
              const r = t[(n + 1) % o];
              return { p: e, v: y.c.normalize([0, 0], ce(e, r)) };
            }),
            s = 0;
          s < a.length;
          ++s
        ) {
          const u = s > 0 ? s - 1 : o - 1;
          const c = y.c.normalize([0, 0], y.c.add([0, 0], a[u].v, y.c.scale([0, 0], a[s].v, -1)));
          a[s].p = y.c.add([0, 0], a[s].p, y.c.scale([0, 0], c, e));
        }
        return a.map((t) => {
          const e = t.p;
          return { x: e[0], y: e[1] };
        });
      }
      const fe = function (t, e, n) {
        return (t.y - n.y) * (e.x - n.x) - (t.x - n.x) * (e.y - n.y);
      };
      const de = function (t) {
        const e = t.map((t) => {
          return { x: t.getModel().x, y: t.getModel().y };
        });
        if (
          (e.sort((t, e) => {
            return t.x === e.x ? t.y - e.y : t.x - e.x;
          }),
          e.length === 1)
        )
          return e;
        for (var n = [], r = 0; r < e.length; r++) {
          for (; n.length >= 2 && fe(n[n.length - 2], n[n.length - 1], e[r]) <= 0; ) n.pop();
          n.push(e[r]);
        }
        const i = [];
        for (r = e.length - 1; r >= 0; r--) {
          for (; i.length >= 2 && fe(i[i.length - 2], i[i.length - 1], e[r]) <= 0; ) i.pop();
          i.push(e[r]);
        }
        return i.pop(), n.pop(), n.concat(i);
      };
      const pe = {
        maxRoutingIterations: 100,
        maxMarchingIterations: 100,
        pixelGroupSize: 2,
        edgeR0: 10,
        edgeR1: 10,
        nodeR0: 5,
        nodeR1: 10,
        morphBuffer: 5,
        threshold: 0.001,
        skip: 16,
        nodeInfluenceFactor: 1,
        edgeInfluenceFactor: 1,
        negativeNodeInfluenceFactor: -0.5,
      };
      function ge(t, e, n) {
        let r = !1;
        const i = function (t, n) {
          return e.cells[t + n * e.width];
        };
        const o = function (t, e) {
          let r = 0;
          return (
            i(t - 1, e - 1) >= n && (r += 1),
            i(t, e - 1) > n && (r += 2),
            i(t - 1, e) > n && (r += 4),
            i(t, e) > n && (r += 8),
            r
          );
        };
        const a = function (n, r) {
          for (var i, a, s = n, u = r, c = 0; c < e.width * e.height; c++) {
            if (
              ((i = s),
              (a = u),
              t.findIndex((t) => {
                return t.x === s && t.y === u;
              }) > -1)
            ) {
              if (t[0].x === s && t[0].y === u) return !0;
            } else t.push({ x: s, y: u });
            const h = o(s, u);
            switch (h) {
              case -1:
                return console.warn('Marched out of bounds'), !0;
              case 0:
              case 3:
              case 2:
              case 7:
                s++;
                break;
              case 12:
              case 14:
              case 4:
                s--;
                break;
              case 6:
                i === 0 && (a === -1 ? (s -= 1) : (s += 1));
                break;
              case 1:
              case 13:
              case 5:
                u--;
                break;
              case 9:
                i === 1 && (a === 0 ? (u -= 1) : (u += 1));
                break;
              case 10:
              case 8:
              case 11:
                u++;
                break;
              default:
                return console.warn(`Marching squares invalid state: ${h}`), !0;
            }
          }
        };
        this.march = function () {
          for (let t = 0; t < e.width && !r; t += 1)
            for (let s = 0; s < e.height && !r; s += 1)
              i(t, s) > n && o(t, s) !== 15 && (r = a(t, s));
          return r;
        };
      }
      const ve = function (t, e) {
        let n = Number.POSITIVE_INFINITY;
        let r = null;
        return (
          t.forEach((t) => {
            const i = H(t, e);
            i >= 0 && i < n && ((r = t), (n = i));
          }),
          r
        );
      };
      function ye(t, e, n, r, i) {
        const o = (function (t, e, n) {
          let r = null;
          let i = Number.POSITIVE_INFINITY;
          return (
            e.forEach((e) => {
              const o = { x: t.getModel().x, y: t.getModel().y };
              const a = { x: e.getModel().x, y: e.getModel().y };
              const s = V(o, a);
              const u = new z(o.x, o.y, a.x, a.y);
              const c = n.reduce((t, e) => {
                return H(e, u) > 0 ? t + 1 : t;
              }, 0);
              s * Math.pow(c + 1, 2) < i && ((r = e), (i = s * Math.pow(c + 1, 2)));
            }),
            r
          );
        })(t, n, e);
        if (o === null) return [];
        return (function (t) {
          for (var n = []; t.length > 0; ) {
            const r = t.pop();
            if (t.length === 0) {
              n.push(r);
              break;
            }
            const i = t.pop();
            const o = new z(r.x1, r.y1, i.x2, i.y2);
            ve(e, o) ? (n.push(r), t.push(i)) : t.push(o);
          }
          return n;
        })(
          (function (t, e, n, r) {
            const i = [];
            const o = [];
            o.push(t);
            for (
              var a = !0,
                s = 0,
                u = function (t, e) {
                  let n = !1;
                  return (
                    e.forEach((e) => {
                      n || ((K(t, { x: e.x1, y: e.y1 }) || K(t, { x: e.x2, y: e.y2 })) && (n = !0));
                    }),
                    n
                  );
                },
                c = function (t, e) {
                  for (let n = 0, r = e; n < r.length; n++) {
                    const i = r[n].getBBox();
                    const o = [
                      [i.x, i.y],
                      [i.x + i.width, i.y],
                      [i.x, i.y + i.height],
                      [i.x + i.width, i.y + i.height],
                    ];
                    if (Y(o, t.x, t.y)) return !0;
                  }
                  return !1;
                };
              a && s < n;

            ) {
              a = !1;
              for (
                let h = function () {
                  const t = o.pop();
                  const n = ve(e, t);
                  if (n) {
                    const h = U(n, t);
                    const l = h[0];
                    if (h[1] === 2) {
                      const f = function (s) {
                        for (
                          var h = r, f = xe(n, h, l, s), d = u(f, o) || u(f, i), p = c(f, e);
                          !d && p && h >= 1;

                        )
                          (f = xe(n, (h /= 1.5), l, s)), (d = u(f, o) || u(f, i)), (p = c(f, e));
                        !f ||
                          d ||
                          (s && p) ||
                          (o.push(new z(t.x1, t.y1, f.x, f.y)),
                          o.push(new z(f.x, f.y, t.x2, t.y2)),
                          (a = !0));
                      };
                      f(!0), a || f(!1);
                    }
                  }
                  a || i.push(t), (s += 1);
                };
                !a && o.length;

              )
                h();
            }
            for (; o.length; ) i.push(o.pop());
            return i;
          })(new z(t.getModel().x, t.getModel().y, o.getModel().x, o.getModel().y), e, r, i),
        );
      }
      const me = function (t, e, n) {
        const r = Object.assign(pe, n);
        const i = q(
          t.map((t) => {
            return { x: t.getModel().x, y: t.getModel().y };
          }),
        );
        t = t.sort((t, e) => {
          return (
            V({ x: t.getModel().x, y: t.getModel().y }, i) -
            V({ x: e.getModel().x, y: e.getModel().y }, i)
          );
        });
        const o = [];
        const a = [];
        t.forEach((t) => {
          ye(t, e, o, r.maxRoutingIterations, r.morphBuffer).forEach((t) => {
            a.push(t);
          }),
            o.push(t);
        });
        for (
          var s,
            u,
            c,
            h,
            l,
            f = (function (t, e, n) {
              const r = {
                minX: Number.POSITIVE_INFINITY,
                minY: Number.POSITIVE_INFINITY,
                maxX: Number.NEGATIVE_INFINITY,
                maxY: Number.NEGATIVE_INFINITY,
                width: 0,
                height: 0,
                x: 0,
                y: 0,
              };
              const i = [];
              t.forEach((t) => {
                i.push(t.getBBox());
              }),
                e.forEach((t) => {
                  i.push(t.getBBox());
                });
              for (let o = 0, a = i; o < a.length; o++) {
                const s = a[o];
                (r.minX = (s.minX < r.minX ? s.minX : r.minX) - n),
                  (r.minY = (s.minY < r.minY ? s.minY : r.minY) - n),
                  (r.maxX = (s.maxX > r.maxX ? s.maxX : r.maxX) + n),
                  (r.maxY = (s.maxY > r.maxY ? s.maxY : r.maxY) + n);
              }
              return (
                (r.width = r.maxX - r.minX),
                (r.height = r.maxY - r.minY),
                (r.x = r.minX),
                (r.y = r.minY),
                r
              );
            })(t, a, r.nodeR0),
            d =
              ((s = f.width),
              (u = f.height),
              (c = r.pixelGroupSize),
              (h = Math.ceil(s / c)),
              (l = Math.ceil(u / c)),
              { cells: new Float32Array(Math.max(0, h * l)).fill(0), width: h, height: l }),
            p = [],
            g = [],
            v = 0;
          v < r.maxMarchingIterations;
          v++
        )
          if ((be(t, e, a, f, d, r), (g = []), new ge((p = []), d, r.threshold).march())) {
            const y = p.map((t) => {
              return {
                x: Math.round(t.x * r.pixelGroupSize + f.minX),
                y: Math.round(t.y * r.pixelGroupSize + f.minY),
              };
            });
            if (y) {
              let m = y.length;
              if (r.skip > 1)
                for (m = Math.floor(y.length / r.skip); m < 3 && r.skip > 1; )
                  (r.skip -= 1), (m = Math.floor(y.length / r.skip));
              for (let b = 0, x = 0; x < m; x += 1, b += r.skip) g.push({ x: y[b].x, y: y[b].y });
            }
            if (
              g &&
              (function () {
                for (let e = 0, n = t; e < n.length; e++) {
                  const r = n[e];
                  const i = g.map((t) => {
                    return [t.x, t.y];
                  });
                  if (!Y(i, r.getBBox().centerX, r.getBBox().centerY)) return !1;
                }
                return !0;
              })()
            )
              return g;
            if (((r.threshold *= 0.9), v <= 0.5 * r.maxMarchingIterations))
              (r.memberInfluenceFactor *= 1.2), (r.edgeInfluenceFactor *= 1.2);
            else {
              if (!(r.nonMemberInfluenceFactor !== 0 && e.length > 0)) break;
              r.nonMemberInfluenceFactor *= 0.8;
            }
          }
        return g;
      };
      function be(t, e, n, r, i, o) {
        function a(t, e) {
          const n = Math.floor((t - e) / o.pixelGroupSize);
          return n < 0 ? 0 : n;
        }
        function s(t, e) {
          return t * o.pixelGroupSize + e;
        }
        const u = (o.nodeR0 - o.nodeR1) * (o.nodeR0 - o.nodeR1);
        const c = (o.edgeR0 - o.edgeR1) * (o.edgeR0 - o.edgeR1);
        const h = function (t, e) {
          return [
            Math.min(a(t.minX, e + r.minX), i.width),
            Math.min(a(t.minY, e + r.minY), i.height),
            Math.min(a(t.maxX, -e + r.minX), i.width),
            Math.min(a(t.maxY, -e + r.minY), i.height),
          ];
        };
        const l = function (t, e) {
          for (
            let n = t.getBBox(), a = h(n, o.nodeR1), u = a[0], c = a[1], l = a[2], f = a[3], d = c;
            d < f;
            d += 1
          )
            for (let p = u; p < l; p += 1)
              if (!(e < 0 && i[p + d * i.width] <= 0)) {
                const g = s(p, r.minX);
                const v = s(d, r.minY);
                const y = $(
                  { x: g, y: v },
                  { x: n.minX, y: n.minY, width: n.width, height: n.height },
                );
                if (y < Math.pow(o.nodeR1, 2)) {
                  const m = Math.sqrt(y) - o.nodeR1;
                  i.cells[p + d * i.width] += e * m * m;
                }
              }
        };
        o.nodeInfluenceFactor &&
          t.forEach((t) => {
            l(t, o.nodeInfluenceFactor / u);
          }),
          o.edgeInfluenceFactor &&
            n.forEach((t) => {
              !(function (t, e) {
                for (
                  let n = t.getBBox(),
                    a = h(n, o.edgeR1),
                    u = a[0],
                    c = a[1],
                    l = a[2],
                    f = a[3],
                    d = c;
                  d < f;
                  d += 1
                )
                  for (let p = u; p < l; p += 1)
                    if (!(e < 0 && i.cells[p + d * i.width] <= 0)) {
                      const g = s(p, r.minX);
                      const v = s(d, r.minY);
                      const y = Z({ x: g, y: v }, t);
                      if (y < Math.pow(o.edgeR1, 2)) {
                        const m = Math.sqrt(y) - o.edgeR1;
                        i.cells[p + d * i.width] += e * m * m;
                      }
                    }
              })(t, o.edgeInfluenceFactor / c);
            }),
          o.negativeNodeInfluenceFactor &&
            e.forEach((t) => {
              l(t, o.negativeNodeInfluenceFactor / u);
            });
      }
      function xe(t, e, n, r) {
        const i = t.getBBox();
        const o = n[0];
        const a = n[1];
        const s = n[2];
        const u = n[3];
        const c = {
          topLeft: { x: i.minX - e, y: i.minY - e },
          topRight: { x: i.maxX + e, y: i.minY - e },
          bottomLeft: { x: i.minX - e, y: i.maxY + e },
          bottomRight: { x: i.maxX + e, y: i.maxY + e },
        };
        const h = i.height * i.width;
        function l(t, e) {
          return i.width * (0.5 * (t.y - i.minY + (e.y - i.minY)));
        }
        if (a)
          return o
            ? r
              ? c.topLeft
              : c.bottomRight
            : s
            ? r
              ? c.bottomLeft
              : c.topRight
            : l(a, u) < 0.5 * h
            ? a.y > u.y
              ? r
                ? c.topLeft
                : c.bottomRight
              : r
              ? c.topRight
              : c.bottomLeft
            : a.y < u.y
            ? r
              ? c.bottomLeft
              : c.topRight
            : r
            ? c.bottomRight
            : c.topLeft;
        if (u) {
          if (o) return r ? c.topRight : c.bottomLeft;
          if (s) return r ? c.bottomRight : c.topLeft;
        }
        return l(o, s) < 0.5 * h
          ? o.x > s.x
            ? r
              ? c.topLeft
              : c.bottomRight
            : r
            ? c.bottomLeft
            : c.topRight
          : o.x < s.x
          ? r
            ? c.topRight
            : c.bottomLeft
          : r
          ? c.bottomRight
          : c.topLeft;
      }
      var Me = (function () {
        function t(t, e) {
          (this.cfg = Object(u.b)(this.getDefaultCfg(), e)),
            (this.graph = t),
            (this.id = this.cfg.id),
            (this.group = this.cfg.group),
            (this.members = this.cfg.members.map((e) => {
              return Object(u.o)(e) ? t.findById(e) : e;
            })),
            (this.nonMembers = this.cfg.nonMembers.map((e) => {
              return Object(u.o)(e) ? t.findById(e) : e;
            })),
            this.setPadding(),
            this.setType(),
            (this.path = this.calcPath(this.members, this.nonMembers)),
            this.render();
        }
        return (
          (t.prototype.getDefaultCfg = function () {
            return {
              id: 'g6-hull',
              type: 'round-convex',
              members: [],
              nonMembers: [],
              style: { fill: 'lightblue', stroke: 'blue', opacity: 0.2 },
              padding: 10,
            };
          }),
          (t.prototype.setPadding = function () {
            const t =
              this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;
            (this.padding = this.cfg.padding > 0 ? this.cfg.padding + t : 10 + t),
              (this.cfg.bubbleCfg = {
                nodeR0: this.padding - t,
                nodeR1: this.padding - t,
                morphBuffer: this.padding - t,
              });
          }),
          (t.prototype.setType = function () {
            (this.type = this.cfg.type),
              this.members.length < 3 && (this.type = 'round-convex'),
              this.type !== 'round-convex' &&
                this.type !== 'smooth-convex' &&
                this.type !== 'bubble' &&
                (console.warn(
                  'The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.',
                ),
                (this.type = 'round-convex'));
          }),
          (t.prototype.calcPath = function (t, e) {
            let n;
            let r;
            let i;
            switch (this.type) {
              case 'round-convex':
                (i = he(
                  (n = de(t)).map((t) => {
                    return [t.x, t.y];
                  }),
                  this.padding,
                )),
                  (r = Object(te.b)(i));
                break;
              case 'smooth-convex':
                (n = de(t)).length === 2
                  ? ((i = he(
                      n.map((t) => {
                        return [t.x, t.y];
                      }),
                      this.padding,
                    )),
                    (r = Object(te.b)(i)))
                  : n.length > 2 &&
                    ((i = le(
                      n.map((t) => {
                        return [t.x, t.y];
                      }),
                      this.padding,
                    )),
                    (r = ae(i)));
                break;
              case 'bubble':
                r = (n = me(t, e, this.cfg.bubbleCfg)).length >= 2 && ae(n);
            }
            return r;
          }),
          (t.prototype.render = function () {
            this.group.addShape('path', {
              attrs: Object(f.a)({ path: this.path }, this.cfg.style),
              id: this.id,
              name: this.cfg.id,
            }),
              this.group.toBack();
          }),
          (t.prototype.addMember = function (t) {
            if (t) {
              Object(u.o)(t) && (t = this.graph.findById(t)), this.members.push(t);
              const e = this.nonMembers.indexOf(t);
              return (
                e > -1 && this.nonMembers.splice(e, 1),
                this.updateData(this.members, this.nonMembers),
                !0
              );
            }
          }),
          (t.prototype.addNonMember = function (t) {
            if (t) {
              Object(u.o)(t) && (t = this.graph.findById(t)), this.nonMembers.push(t);
              const e = this.members.indexOf(t);
              return (
                e > -1 && this.members.splice(e, 1),
                this.updateData(this.members, this.nonMembers),
                !0
              );
            }
          }),
          (t.prototype.removeMember = function (t) {
            if (t) {
              Object(u.o)(t) && (t = this.graph.findById(t));
              const e = this.members.indexOf(t);
              return (
                e > -1 &&
                (this.members.splice(e, 1), this.updateData(this.members, this.nonMembers), !0)
              );
            }
          }),
          (t.prototype.removeNonMember = function (t) {
            if (t) {
              Object(u.o)(t) && (t = this.graph.findById(t));
              const e = this.nonMembers.indexOf(t);
              return (
                e > -1 &&
                (this.nonMembers.splice(e, 1), this.updateData(this.members, this.nonMembers), !0)
              );
            }
          }),
          (t.prototype.updateData = function (t, e) {
            const n = this;
            this.group.findById(this.id).remove(),
              t &&
                (this.members = t.map((t) => {
                  return Object(u.o)(t) ? n.graph.findById(t) : t;
                })),
              e &&
                (this.nonMembers = e.map((t) => {
                  return Object(u.o)(t) ? n.graph.findById(t) : t;
                })),
              (this.path = this.calcPath(this.members, this.nonMembers)),
              this.render();
          }),
          (t.prototype.updateStyle = function (t) {
            this.group.findById(this.id).attr(Object(f.a)({}, t));
          }),
          (t.prototype.updateCfg = function (t) {
            const e = this;
            (this.cfg = Object(u.b)(this.cfg, t)),
              (this.id = this.cfg.id),
              (this.group = this.cfg.group),
              t.members &&
                (this.members = this.cfg.members.map((t) => {
                  return Object(u.o)(t) ? e.graph.findById(t) : t;
                })),
              t.nonMembers &&
                (this.nonMembers = this.cfg.nonMembers.map((t) => {
                  return Object(u.o)(t) ? e.graph.findById(t) : t;
                })),
              this.setPadding(),
              this.setType(),
              (this.path = this.calcPath(this.members, this.nonMembers)),
              this.render();
          }),
          (t.prototype.contain = function (t) {
            let e;
            let n;
            const r = this;
            const i = (e = Object(u.o)(t) ? this.graph.findById(t) : t).getKeyShape();
            if (e.get('type') === 'path') n = oe(i.attr('path'));
            else {
              const o = i.getCanvasBBox();
              n = [
                [o.minX, o.minY],
                [o.maxX, o.minY],
                [o.maxX, o.maxY],
                [o.minX, o.maxY],
              ];
            }
            return (
              (n = n.map((t) => {
                const e = r.graph.getPointByCanvas(t[0], t[1]);
                return [e.x, e.y];
              })),
              X(n, oe(this.path))
            );
          }),
          (t.prototype.destroy = function () {
            this.group.remove(), (this.cfg = null);
          }),
          t
        );
      })();
      const Se = y.a.transform;
      var we = (function (t) {
        function e(e) {
          const n = t.call(this) || this;
          return (
            (n.cfg = Object(u.b)(n.getDefaultCfg(), e)),
            n.init(),
            (n.animating = !1),
            (n.destroyed = !1),
            n.cfg.enabledStack &&
              ((n.undoStack = new m.Stack(n.cfg.maxStep)),
              (n.redoStack = new m.Stack(n.cfg.maxStep))),
            n
          );
        }
        return (
          Object(f.c)(e, t),
          (e.prototype.init = function () {
            this.initCanvas();
            const t = new Bt(this);
            const e = new Ct(this);
            const n = new $t(this);
            const r = new Jt(this);
            this.set({
              viewController: t,
              modeController: e,
              itemController: n,
              stateController: r,
            }),
              this.initLayoutController(),
              this.initEventController(),
              this.initGroups(),
              this.initPlugins(),
              v(this.onTick.bind(this));
          }),
          (e.prototype.initGroups = function () {
            const t = this.get('canvas');
            const e = this.get('canvas').get('el').id;
            const n = t.addGroup({ id: `${e}-root`, className: it.rootContainerClassName });
            if (this.get('groupByTypes')) {
              const r = n.addGroup({ id: `${e}-edge`, className: it.edgeContainerClassName });
              const i = n.addGroup({ id: `${e}-node`, className: it.nodeContainerClassName });
              const o = n.addGroup({ id: `${e}-combo`, className: it.comboContainerClassName });
              o.toBack(), this.set({ nodeGroup: i, edgeGroup: r, comboGroup: o });
            }
            const a = n.addGroup({ id: `${e}-delegate`, className: it.delegateContainerClassName });
            this.set({ delegateGroup: a }), this.set('group', n);
          }),
          (e.prototype.getDefaultCfg = function () {
            return {
              container: void 0,
              width: void 0,
              height: void 0,
              renderer: 'canvas',
              modes: {},
              plugins: [],
              data: {},
              fitViewPadding: 10,
              minZoom: 0.2,
              maxZoom: 10,
              event: !0,
              groupByTypes: !0,
              directed: !1,
              autoPaint: !0,
              nodes: [],
              edges: [],
              combos: [],
              vedges: [],
              itemMap: {},
              linkCenter: !1,
              defaultNode: {},
              defaultEdge: {},
              nodeStateStyles: {},
              edgeStateStyles: {},
              states: {},
              animate: !1,
              animateCfg: { onFrame: void 0, duration: 500, easing: 'easeLinear' },
              callback: void 0,
              enabledStack: !1,
              maxStep: 10,
              tooltips: [],
            };
          }),
          (e.prototype.set = function (t, e) {
            return (
              Object(u.n)(t)
                ? (this.cfg = Object(f.a)(Object(f.a)({}, this.cfg), t))
                : (this.cfg[t] = e),
              this
            );
          }),
          (e.prototype.get = function (t) {
            return this.cfg[t];
          }),
          (e.prototype.getGroup = function () {
            return this.get('group');
          }),
          (e.prototype.getContainer = function () {
            return this.get('container');
          }),
          (e.prototype.getMinZoom = function () {
            return this.get('minZoom');
          }),
          (e.prototype.setMinZoom = function (t) {
            return this.set('minZoom', t);
          }),
          (e.prototype.getMaxZoom = function () {
            return this.get('maxZoom');
          }),
          (e.prototype.setMaxZoom = function (t) {
            return this.set('maxZoom', t);
          }),
          (e.prototype.getWidth = function () {
            return this.get('width');
          }),
          (e.prototype.getHeight = function () {
            return this.get('height');
          }),
          (e.prototype.clearItemStates = function (t, e) {
            Object(u.o)(t) && (t = this.findById(t));
            const n = this.get('itemController');
            e || (e = t.get('states')),
              n.clearItemStates(t, e),
              this.get('stateController').updateStates(t, e, !1);
          }),
          (e.prototype.node = function (t) {
            typeof t === 'function' && this.set('nodeMapper', t);
          }),
          (e.prototype.edge = function (t) {
            typeof t === 'function' && this.set('edgeMapper', t);
          }),
          (e.prototype.combo = function (t) {
            typeof t === 'function' && this.set('comboMapper', t);
          }),
          (e.prototype.findById = function (t) {
            return this.get('itemMap')[t];
          }),
          (e.prototype.find = function (t, e) {
            let n;
            const r = this.get(`${t}s`);
            return (
              Object(u.c)(r, (t, r) => {
                if (e(t, r)) return (n = t);
              }),
              n
            );
          }),
          (e.prototype.findAll = function (t, e) {
            const n = [];
            return (
              Object(u.c)(this.get(`${t}s`), (t, r) => {
                e(t, r) && n.push(t);
              }),
              n
            );
          }),
          (e.prototype.findAllByState = function (t, e) {
            return this.findAll(t, (t) => {
              return t.hasState(e);
            });
          }),
          (e.prototype.translate = function (t, e) {
            const n = this.get('group');
            let r = Object(u.a)(n.getMatrix());
            r || (r = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              (r = Se(r, [['t', t, e]])),
              n.setMatrix(r),
              this.emit('viewportchange', { action: 'translate', matrix: n.getMatrix() }),
              this.autoPaint();
          }),
          (e.prototype.moveTo = function (t, e) {
            const n = this.get('group');
            _(n, { x: t, y: e }),
              this.emit('viewportchange', { action: 'move', matrix: n.getMatrix() });
          }),
          (e.prototype.fitView = function (t) {
            t && this.set('fitViewPadding', t),
              this.get('viewController').fitView(),
              this.autoPaint();
          }),
          (e.prototype.fitCenter = function () {
            this.get('viewController').fitCenter(), this.autoPaint();
          }),
          (e.prototype.addBehaviors = function (t, e) {
            return this.get('modeController').manipulateBehaviors(t, e, !0), this;
          }),
          (e.prototype.removeBehaviors = function (t, e) {
            return this.get('modeController').manipulateBehaviors(t, e, !1), this;
          }),
          (e.prototype.updateBehavior = function (t, e, n) {
            return this.get('modeController').updateBehavior(t, e, n), this;
          }),
          (e.prototype.zoom = function (t, e) {
            const n = this.get('group');
            let r = Object(u.a)(n.getMatrix());
            const i = this.get('minZoom');
            const o = this.get('maxZoom');
            r || (r = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              (r = Se(
                r,
                e
                  ? [
                      ['t', -e.x, -e.y],
                      ['s', t, t],
                      ['t', e.x, e.y],
                    ]
                  : [['s', t, t]],
              )),
              (i && r[0] < i) ||
                (o && r[0] > o) ||
                (n.setMatrix(r),
                this.emit('viewportchange', { action: 'zoom', matrix: r }),
                this.autoPaint());
          }),
          (e.prototype.zoomTo = function (t, e) {
            const n = t / this.getZoom();
            this.zoom(n, e);
          }),
          (e.prototype.focusItem = function (t, e, n) {
            const r = this.get('viewController');
            let i = !1;
            e ? (i = !0) : void 0 === e && (i = this.get('animate'));
            let o = {};
            n ? (o = n) : void 0 === n && (o = this.get('animateCfg')),
              r.focus(t, i, o),
              this.autoPaint();
          }),
          (e.prototype.autoPaint = function () {
            this.get('autoPaint') && this.paint();
          }),
          (e.prototype.paint = function () {
            this.emit('beforepaint'), this.get('canvas').draw(), this.emit('afterpaint');
          }),
          (e.prototype.getPointByClient = function (t, e) {
            return this.get('viewController').getPointByClient(t, e);
          }),
          (e.prototype.getClientByPoint = function (t, e) {
            return this.get('viewController').getClientByPoint(t, e);
          }),
          (e.prototype.getPointByCanvas = function (t, e) {
            return this.get('viewController').getPointByCanvas(t, e);
          }),
          (e.prototype.getCanvasByPoint = function (t, e) {
            return this.get('viewController').getCanvasByPoint(t, e);
          }),
          (e.prototype.getGraphCenterPoint = function () {
            const t = this.get('group').getCanvasBBox();
            return { x: (t.minX + t.maxX) / 2, y: (t.minY + t.maxY) / 2 };
          }),
          (e.prototype.getViewPortCenterPoint = function () {
            return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);
          }),
          (e.prototype.showItem = function (t, e) {
            void 0 === e && (e = !0);
            const n = this.get('itemController').changeItemVisibility(t, !0);
            if (e && this.get('enabledStack')) {
              const r = n.getID();
              const i = {};
              const o = {};
              switch (n.getType()) {
                case 'node':
                  (i.nodes = [{ id: r, visible: !1 }]), (o.nodes = [{ id: r, visible: !0 }]);
                  break;
                case 'edge':
                  (i.nodes = [{ id: r, visible: !1 }]), (o.edges = [{ id: r, visible: !0 }]);
                  break;
                case 'combo':
                  (i.nodes = [{ id: r, visible: !1 }]), (o.combos = [{ id: r, visible: !0 }]);
              }
              this.pushStack('visible', { before: i, after: o });
            }
          }),
          (e.prototype.hideItem = function (t, e) {
            void 0 === e && (e = !0);
            const n = this.get('itemController').changeItemVisibility(t, !1);
            if (e && this.get('enabledStack')) {
              const r = n.getID();
              const i = {};
              const o = {};
              switch (n.getType()) {
                case 'node':
                  (i.nodes = [{ id: r, visible: !0 }]), (o.nodes = [{ id: r, visible: !1 }]);
                  break;
                case 'edge':
                  (i.nodes = [{ id: r, visible: !0 }]), (o.edges = [{ id: r, visible: !1 }]);
                  break;
                case 'combo':
                  (i.nodes = [{ id: r, visible: !0 }]), (o.combos = [{ id: r, visible: !1 }]);
              }
              this.pushStack('visible', { before: i, after: o });
            }
          }),
          (e.prototype.refreshItem = function (t) {
            this.get('itemController').refreshItem(t);
          }),
          (e.prototype.setAutoPaint = function (t) {
            this.set('autoPaint', t), this.get('canvas').set('autoDraw', t);
          }),
          (e.prototype.remove = function (t, e) {
            void 0 === e && (e = !0), this.removeItem(t, e);
          }),
          (e.prototype.removeItem = function (t, e) {
            void 0 === e && (e = !0);
            let n = t;
            if ((Object(u.o)(t) && (n = this.findById(t)), !n && Object(u.o)(t)))
              console.warn('The item to be removed does not exist!');
            else if (n) {
              let r = '';
              if ((n.getType && (r = n.getType()), e && this.get('enabledStack'))) {
                const i = Object(f.a)(Object(f.a)({}, n.getModel()), { itemType: r });
                const o = {};
                switch (r) {
                  case 'node':
                    (o.nodes = [i]), (o.edges = []);
                    for (let a = n.getEdges(), s = a.length - 1; s >= 0; s--)
                      o.edges.push(
                        Object(f.a)(Object(f.a)({}, a[s].getModel()), { itemType: 'edge' }),
                      );
                    break;
                  case 'edge':
                    o.edges = [i];
                    break;
                  case 'combo':
                    o.combos = [i];
                }
                this.pushStack('delete', { before: o, after: {} });
              }
              if (r === 'node') n.getModel().comboId && this.updateComboTree(n);
              if ((this.get('itemController').removeItem(n), r === 'combo')) {
                const c = xt(this.get('comboTrees'));
                this.set('comboTrees', c);
              }
            }
          }),
          (e.prototype.addItem = function (t, e, n, r) {
            void 0 === n && (n = !0), void 0 === r && (r = !0);
            const i = this.get('comboSorted');
            this.set('comboSorted', i && !r);
            const o = this.get('itemController');
            if (
              !(function (t, e) {
                if (t === 'node' || t === 'combo') {
                  if (e.id && !Object(u.o)(e.id))
                    return (
                      console.warn(
                        `G6 Warning Tips: missing 'id' property, or the 'id' %c${e.id}%c is not a string.`,
                        'font-size: 20px; color: red;',
                        '',
                      ),
                      !1
                    );
                } else if (!(t !== 'edge' || (e.source && e.target)))
                  return (
                    console.warn("G6 Warning Tips: missing 'source' or 'target' for the edge."), !1
                  );
                return !0;
              })(t, e)
            )
              return !1;
            if (!e.id || !this.findById(e.id)) {
              let a;
              let s = this.get('comboTrees');
              if ((s || (s = []), t === 'combo')) {
                const c = this.get('itemMap');
                let h = !1;
                if (
                  (s.forEach((n) => {
                    h ||
                      vt(n, (n) => {
                        if (e.parentId === n.id) {
                          h = !0;
                          const r = Object(f.a)({ id: e.id, depth: n.depth + 2 }, e);
                          n.children ? n.children.push(r) : (n.children = [r]),
                            (e.depth = r.depth),
                            (a = o.addItem(t, e));
                        }
                        const i = c[n.id];
                        return (
                          h &&
                            i &&
                            i.getType &&
                            i.getType() === 'combo' &&
                            o.updateCombo(i, n.children),
                          !0
                        );
                      });
                  }),
                  !h)
                ) {
                  const l = Object(f.a)({ id: e.id, depth: 0 }, e);
                  (e.depth = l.depth), s.push(l), (a = o.addItem(t, e));
                }
                this.set('comboTrees', s);
              } else if (t === 'node' && Object(u.o)(e.comboId) && s) {
                var d;
                (d = this.findById(e.comboId)) &&
                  d.getType &&
                  d.getType() !== 'combo' &&
                  console.warn(
                    `'${e.comboId}' is not a id of a combo in the graph, the node will be added without combo.`,
                  ),
                  (a = o.addItem(t, e));
                const p = this.get('itemMap');
                let g = !1;
                let v = !1;
                (s || []).forEach((t) => {
                  v ||
                    g ||
                    vt(t, (t) => {
                      if (t.id === e.id) return (v = !0), !1;
                      if (e.comboId === t.id && !v) {
                        g = !0;
                        const n = Object(u.a)(e);
                        (n.itemType = 'node'),
                          t.children ? t.children.push(n) : (t.children = [n]),
                          (n.depth = t.depth + 1);
                      }
                      return (
                        g &&
                          p[t.id].getType &&
                          p[t.id].getType() === 'combo' &&
                          o.updateCombo(p[t.id], t.children),
                        !0
                      );
                    });
                });
              } else a = o.addItem(t, e);
              if ((t === 'node' && e.comboId) || (t === 'combo' && e.parentId))
                (d = this.findById(e.comboId || e.parentId)) &&
                  d.getType &&
                  d.getType() === 'combo' &&
                  d.addChild(a);
              const y = this.get('combos');
              if (
                (y && y.length > 0 && this.sortCombos(),
                this.autoPaint(),
                n && this.get('enabledStack'))
              ) {
                const m = Object(f.a)(Object(f.a)({}, a.getModel()), { itemType: t });
                const b = {};
                switch (t) {
                  case 'node':
                    b.nodes = [m];
                    break;
                  case 'edge':
                    b.edges = [m];
                    break;
                  case 'combo':
                    b.combos = [m];
                }
                this.pushStack('add', { before: {}, after: b });
              }
              return a;
            }
            console.warn(
              `This item exists already. Be sure the id %c${e.id}%c is unique.`,
              'font-size: 20px; color: red;',
              '',
            );
          }),
          (e.prototype.add = function (t, e, n, r) {
            return void 0 === n && (n = !0), void 0 === r && (r = !0), this.addItem(t, e, n, r);
          }),
          (e.prototype.updateItem = function (t, e, n) {
            const r = this;
            void 0 === n && (n = !0);
            let i;
            const o = this.get('itemController');
            i = Object(u.o)(t) ? this.findById(t) : t;
            const a = Object(u.a)(i.getModel());
            let s = '';
            i.getType && (s = i.getType());
            const c = Object(f.f)([], i.getStates());
            if (
              (s === 'combo' &&
                Object(u.c)(c, (t) => {
                  return r.setItemState(i, t, !1);
                }),
              o.updateItem(i, e),
              s === 'combo' &&
                Object(u.c)(c, (t) => {
                  return r.setItemState(i, t, !0);
                }),
              n && this.get('enabledStack'))
            ) {
              const h = { nodes: [], edges: [], combos: [] };
              const l = { nodes: [], edges: [], combos: [] };
              const d = Object(f.a)({ id: a.id }, e);
              switch (s) {
                case 'node':
                  h.nodes.push(a), l.nodes.push(d);
                  break;
                case 'edge':
                  h.edges.push(a), l.edges.push(d);
                  break;
                case 'combo':
                  h.combos.push(a), l.combos.push(d);
              }
              s === 'node' && h.nodes.push(a), this.pushStack('update', { before: h, after: l });
            }
          }),
          (e.prototype.update = function (t, e, n) {
            void 0 === n && (n = !0), this.updateItem(t, e, n);
          }),
          (e.prototype.setItemState = function (t, e, n) {
            Object(u.o)(t) && (t = this.findById(t)),
              this.get('itemController').setItemState(t, e, n);
            const r = this.get('stateController');
            Object(u.o)(n) ? r.updateState(t, `${e}:${n}`, !0) : r.updateState(t, e, n);
          }),
          (e.prototype.priorityState = function (t, e) {
            this.get('itemController').priorityState(t, e);
          }),
          (e.prototype.data = function (t) {
            Ot(t), this.set('data', t);
          }),
          (e.prototype.render = function () {
            const t = this;
            this.set('comboSorted', !1);
            const e = this.get('data');
            if ((this.get('enabledStack') && this.clearStack(), !e))
              throw new Error('data must be defined first');
            const n = e.nodes;
            const r = void 0 === n ? [] : n;
            const i = e.edges;
            const o = void 0 === i ? [] : i;
            const a = e.combos;
            const s = void 0 === a ? [] : a;
            if (
              (this.clear(!0),
              this.emit('beforerender'),
              Object(u.c)(r, (e) => {
                t.add('node', e, !1, !1);
              }),
              s && s.length !== 0)
            ) {
              const c = bt(s, r);
              this.set('comboTrees', c), t.addCombos(s);
            }
            Object(u.c)(o, (e) => {
              t.add('edge', e, !1, !1);
            });
            const h = t.get('animate');
            (t.get('fitView') || t.get('fitCenter')) && t.set('animate', !1);
            const l = t.get('layoutController');
            if (l) {
              if (
                (l.layout(() => {
                  t.get('fitView') ? t.fitView() : t.get('fitCenter') && t.fitCenter();
                  t.autoPaint(),
                    t.emit('afterrender'),
                    (t.get('fitView') || t.get('fitCenter')) && t.set('animate', h);
                }),
                this.refreshPositions(),
                this.destroyed)
              )
                return;
            } else
              t.get('fitView') && t.fitView(),
                t.get('fitCenter') && t.fitCenter(),
                t.emit('afterrender'),
                t.set('animate', h);
            this.get('groupByTypes') ||
              (s && s.length !== 0
                ? this.sortCombos()
                : e.nodes && e.edges && e.nodes.length < e.edges.length
                ? this.getNodes().forEach((t) => {
                    t.toFront();
                  })
                : this.getEdges().forEach((t) => {
                    t.toBack();
                  }));
            this.get('enabledStack') && this.pushStack('render');
          }),
          (e.prototype.read = function (t) {
            this.data(t), this.render();
          }),
          (e.prototype.diffItems = function (t, e, n) {
            let r;
            const i = this;
            const o = this.get('itemMap');
            Object(u.c)(n, (n) => {
              if ((r = o[n.id])) {
                if (i.get('animate') && t === 'node') {
                  let a = r.getContainer().getMatrix();
                  a || (a = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                    r.set('originAttrs', { x: a[6], y: a[7] });
                }
                i.updateItem(r, n, !1);
              } else r = i.addItem(t, n, !1);
              r && e[`${t}s`].push(r);
            });
          }),
          (e.prototype.changeData = function (t, e) {
            void 0 === e && (e = !0);
            const n = this;
            if (!Ot(t)) return this;
            e &&
              this.get('enabledStack') &&
              this.pushStack('changedata', { before: n.save(), after: t }),
              this.set('comboSorted', !1),
              this.removeHulls(),
              this.getNodes().map((t) => {
                return n.clearItemStates(t);
              }),
              this.getEdges().map((t) => {
                return n.clearItemStates(t);
              });
            const r = this.get('canvas');
            const i = r.get('localRefresh');
            r.set('localRefresh', !1), n.get('data') || (n.data(t), n.render());
            const o = this.get('itemMap');
            const a = { nodes: [], edges: [] };
            const s = t.combos;
            if (s) {
              const c = bt(s, t.nodes);
              this.set('comboTrees', c);
            }
            this.diffItems('node', a, t.nodes),
              Object(u.c)(o, (t, e) => {
                (o[e].getModel().depth = 0),
                  (t.getType && t.getType() === 'edge') ||
                    (t.getType && t.getType() === 'combo'
                      ? (delete o[e], t.destroy())
                      : a.nodes.indexOf(t) < 0 && (delete o[e], n.remove(t, !1)));
              });
            for (let h = this.getCombos(), l = h.length - 1; l >= 0; l--)
              h[l].destroyed && h.splice(l, 1);
            s && (n.addCombos(s), this.get('groupByTypes') || this.sortCombos()),
              this.diffItems('edge', a, t.edges),
              Object(u.c)(o, (t, e) => {
                (!t.getType || (t.getType() !== 'node' && t.getType() !== 'combo')) &&
                  a.edges.indexOf(t) < 0 &&
                  (delete o[e], n.remove(t, !1));
              }),
              this.set({ nodes: a.nodes, edges: a.edges });
            const f = this.get('layoutController');
            return (
              f &&
                (f.changeData(),
                n.get('animate') && !f.getLayoutType() ? n.positionsAnimate() : n.autoPaint()),
              setTimeout(() => {
                r.set('localRefresh', i);
              }, 16),
              this
            );
          }),
          (e.prototype.addCombos = function (t) {
            const e = this.get('comboTrees');
            this.get('itemController').addCombos(e, t);
          }),
          (e.prototype.createCombo = function (t, e) {
            const n = this;
            this.set('comboSorted', !1);
            let r;
            let i = '';
            if (t) {
              if (Object(u.o)(t)) (i = t), (r = { id: t });
              else {
                if (!(i = t.id))
                  return void console.warn(
                    'Create combo failed. Please assign a unique string id for the adding combo.',
                  );
                r = t;
              }
              const o = e.map((t) => {
                const e = n.findById(t);
                const r = e.getModel();
                let o = '';
                e.getType && (o = e.getType());
                const a = { id: e.getID(), itemType: o };
                return (
                  o === 'combo'
                    ? ((a.parentId = i), (r.parentId = i))
                    : o === 'node' && ((a.comboId = i), (r.comboId = i)),
                  a
                );
              });
              (r.children = o), this.addItem('combo', r, !1), this.set('comboSorted', !1);
              const a = this.get('comboTrees');
              (a || []).forEach((t) => {
                vt(t, (t) => {
                  return t.id !== i || ((t.itemType = 'combo'), (t.children = o), !1);
                });
              }),
                a && this.sortCombos();
            }
          }),
          (e.prototype.uncombo = function (t) {
            const e = this;
            let n = t;
            if (
              (Object(u.o)(t) && (n = this.findById(t)),
              !n || (n.getType && n.getType() !== 'combo'))
            )
              console.warn('The item is not a combo!');
            else {
              const r = n.getModel().parentId;
              let i = this.get('comboTrees');
              i || (i = []);
              let o;
              const a = this.get('itemMap');
              const s = n.get('id');
              let c = [];
              const h = this.get('combos');
              const l = this.findById(r);
              if (
                (i.forEach((i) => {
                  o ||
                    vt(i, (i) => {
                      if (i.id === s) {
                        (o = i),
                          n.getEdges().forEach((t) => {
                            e.removeItem(t, !1);
                          });
                        var u = h.indexOf(t);
                        h.splice(u, 1), delete a[s], n.destroy();
                      }
                      return (
                        !r ||
                        !o ||
                        i.id !== r ||
                        (l.removeCombo(n),
                        (u = (c = i.children).indexOf(o)) !== -1 && c.splice(u, 1),
                        o.children.forEach((t) => {
                          const n = e.findById(t.id);
                          const i = n.getModel();
                          n.getType && n.getType() === 'combo'
                            ? ((t.parentId = r),
                              delete t.comboId,
                              (i.parentId = r),
                              delete i.comboId)
                            : n.getType &&
                              n.getType() === 'node' &&
                              ((t.comboId = r), (i.comboId = r)),
                            l.addChild(n),
                            c.push(t);
                        }),
                        !1)
                      );
                    });
                }),
                !r && o)
              ) {
                const f = i.indexOf(o);
                i.splice(f, 1),
                  o.children.forEach((t) => {
                    t.parentId = void 0;
                    const n = e.findById(t.id).getModel();
                    delete n.parentId, delete n.comboId, t.itemType !== 'node' && i.push(t);
                  });
              }
            }
          }),
          (e.prototype.updateCombos = function () {
            const t = this;
            const e = this.get('comboTrees');
            const n = this.get('itemController');
            const r = this.get('itemMap');
            (e || []).forEach((e) => {
              vt(e, (e) => {
                if (!e) return !0;
                const i = r[e.id];
                if (i && i.getType && i.getType() === 'combo') {
                  const o = Object(f.f)([], i.getStates());
                  Object(u.c)(o, (e) => {
                    return t.setItemState(i, e, !1);
                  }),
                    n.updateCombo(i, e.children),
                    Object(u.c)(o, (e) => {
                      return t.setItemState(i, e, !0);
                    });
                }
                return !0;
              });
            }),
              this.sortCombos();
          }),
          (e.prototype.updateCombo = function (t) {
            let e;
            const n = this;
            let r = t;
            if (
              (Object(u.o)(t) && (r = this.findById(t)),
              !r || (r.getType && r.getType() !== 'combo'))
            )
              console.warn('The item to be updated is not a combo!');
            else {
              e = r.get('id');
              const i = this.get('comboTrees');
              const o = this.get('itemController');
              const a = this.get('itemMap');
              (i || []).forEach((t) => {
                vt(t, (t) => {
                  if (!t) return !0;
                  const r = a[t.id];
                  if (e === t.id && r && r.getType && r.getType() === 'combo') {
                    const i = Object(f.f)([], r.getStates());
                    Object(u.c)(i, (t) => {
                      r.getStateStyle(t) && n.setItemState(r, t, !1);
                    }),
                      o.updateCombo(r, t.children),
                      Object(u.c)(i, (t) => {
                        r.getStateStyle(t) && n.setItemState(r, t, !0);
                      }),
                      e && (e = t.parentId);
                  }
                  return !0;
                });
              });
            }
          }),
          (e.prototype.updateComboTree = function (t, e, n) {
            void 0 === n && (n = !0);
            let r;
            this.set('comboSorted', !1);
            let i;
            const o = (r = Object(u.o)(t) ? this.findById(t) : t).getModel();
            const a = o.comboId || o.parentId;
            let s = '';
            if ((r.getType && (s = r.getType()), e && s === 'combo')) {
              let c;
              const h = this.get('comboTrees');
              let l = !0;
              if (
                ((h || []).forEach((t) => {
                  c ||
                    gt(t, (t) => {
                      if (!c) return t.id === r.getID() && (c = t), !0;
                    });
                }),
                gt(c, (t) => {
                  return t.id !== e || ((l = !1), !1);
                }),
                !l)
              )
                return void console.warn(
                  'Failed to update the combo tree! The parentId points to a descendant of the combo!',
                );
            }
            if (n && this.get('enabledStack')) {
              const f = {};
              const d = {};
              s === 'combo'
                ? ((f.combos = [{ id: o.id, parentId: o.parentId }]),
                  (d.combos = [{ id: o.id, parentId: e }]))
                : s === 'node' &&
                  ((f.nodes = [{ id: o.id, parentId: o.comboId }]),
                  (d.nodes = [{ id: o.id, parentId: e }])),
                this.pushStack('updateComboTree', { before: f, after: d });
            }
            if (o.parentId || o.comboId) {
              const p = this.findById(o.parentId || o.comboId);
              p && p.removeChild(r);
            }
            (s === 'combo' ? (o.parentId = e) : s === 'node' && (o.comboId = e), e) &&
              (i = this.findById(e)) &&
              i.addChild(r);
            a && (i = this.findById(a)) && i.removeChild(r);
            const g = xt(this.get('comboTrees'), o.id, e);
            this.set('comboTrees', g), this.updateCombos();
          }),
          (e.prototype.save = function () {
            const t = [];
            const e = [];
            const n = [];
            return (
              Object(u.c)(this.get('nodes'), (e) => {
                t.push(e.getModel());
              }),
              Object(u.c)(this.get('edges'), (t) => {
                e.push(t.getModel());
              }),
              Object(u.c)(this.get('combos'), (t) => {
                n.push(t.getModel());
              }),
              { nodes: t, edges: e, combos: n }
            );
          }),
          (e.prototype.changeSize = function (t, e) {
            return this.get('viewController').changeSize(t, e), this;
          }),
          (e.prototype.refresh = function () {
            if ((this.emit('beforegraphrefresh'), this.get('animate'))) this.positionsAnimate();
            else {
              const t = this.get('nodes');
              const e = this.get('edges');
              const n = this.get('edges');
              Object(u.c)(t, (t) => {
                t.refresh();
              }),
                Object(u.c)(e, (t) => {
                  t.refresh();
                }),
                Object(u.c)(n, (t) => {
                  t.refresh();
                });
            }
            this.emit('aftergraphrefresh'), this.autoPaint();
          }),
          (e.prototype.getNodes = function () {
            return this.get('nodes');
          }),
          (e.prototype.getEdges = function () {
            return this.get('edges');
          }),
          (e.prototype.getCombos = function () {
            return this.get('combos');
          }),
          (e.prototype.getComboChildren = function (t) {
            if (
              (Object(u.o)(t) && (t = this.findById(t)),
              t && (!t.getType || t.getType() === 'combo'))
            )
              return t.getChildren();
            console.warn('The combo does not exist!');
          }),
          (e.prototype.positionsAnimate = function () {
            const t = this;
            t.emit('beforeanimate');
            const e = t.get('animateCfg');
            const n = e.onFrame;
            const r = t.getNodes();
            const i = r.map((t) => {
              const e = t.getModel();
              return { id: e.id, x: e.x, y: e.y };
            });
            t.isAnimating() && t.stopAnimate(),
              t.get('canvas').animate(
                (e) => {
                  Object(u.c)(i, (r) => {
                    const i = t.findById(r.id);
                    if (i && !i.destroyed) {
                      let o = i.get('originAttrs');
                      const a = i.get('model');
                      if (!o) {
                        let s = i.getContainer().getMatrix();
                        s || (s = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                          (o = { x: s[6], y: s[7] }),
                          i.set('originAttrs', o);
                      }
                      if (n) {
                        const u = n(i, e, r, o);
                        i.set('model', Object.assign(a, u));
                      } else (a.x = o.x + (r.x - o.x) * e), (a.y = o.y + (r.y - o.y) * e);
                    }
                  }),
                    t.refreshPositions();
                },
                {
                  duration: e.duration,
                  easing: e.easing,
                  callback() {
                    Object(u.c)(r, (t) => {
                      t.set('originAttrs', null);
                    }),
                      e.callback && e.callback(),
                      t.emit('afteranimate'),
                      (t.animating = !1);
                  },
                },
              );
          }),
          (e.prototype.refreshPositions = function () {
            this.emit('beforegraphrefreshposition');
            let t;
            const e = this.get('nodes');
            const n = this.get('edges');
            const r = this.get('vedges');
            const i = this.get('combos');
            const o = {};
            Object(u.c)(e, (e) => {
              t = e.getModel();
              const n = e.get('originAttrs');
              if (!n || t.x !== n.x || t.y !== n.y) {
                const r = e.updatePosition({ x: t.x, y: t.y });
                (o[t.id] = r), t.comboId && (o[t.comboId] = o[t.comboId] || r);
              }
            }),
              i && i.length !== 0 && this.updateCombos(),
              Object(u.c)(n, (t) => {
                const e = t.getSource().getModel();
                const n = t.getTarget();
                if (!Object(u.n)(n)) {
                  const r = n.getModel();
                  (o[e.id] || o[r.id] || t.getModel().isComboEdge) && t.refresh();
                }
              }),
              Object(u.c)(r, (t) => {
                t.refresh();
              }),
              this.emit('aftergraphrefreshposition'),
              this.autoPaint();
          }),
          (e.prototype.stopAnimate = function () {
            this.get('canvas').stopAnimate();
          }),
          (e.prototype.isAnimating = function () {
            return this.animating;
          }),
          (e.prototype.getZoom = function () {
            const t = this.get('group').getMatrix();
            return t ? t[0] : 1;
          }),
          (e.prototype.getCurrentMode = function () {
            return this.get('modeController').getMode();
          }),
          (e.prototype.setMode = function (t) {
            return this.get('modeController').setMode(t), this;
          }),
          (e.prototype.clear = function (t) {
            return (
              void 0 === t && (t = !1),
              this.get('canvas').clear(),
              this.initGroups(),
              this.set({
                itemMap: {},
                nodes: [],
                edges: [],
                groups: [],
                combos: [],
                comboTrees: [],
              }),
              t || this.emit('afterrender'),
              this
            );
          }),
          (e.prototype.updateLayout = function (t) {
            const e = this.get('layoutController');
            Object(u.o)(t) && (t = { type: t });
            const n = this.get('layout');
            const r = {};
            Object.assign(r, n, t),
              this.set('layout', r),
              e.isLayoutTypeSame(r) && r.gpuEnabled === n.gpuEnabled
                ? e.updateLayoutCfg(r)
                : e.changeLayout(r);
          }),
          (e.prototype.destroyLayout = function () {
            this.get('layoutController').destroyLayout();
          }),
          (e.prototype.layout = function () {
            const t = this.get('layoutController');
            const e = this.get('layout');
            e && t && (e.workerEnabled ? t.layout() : t.layoutMethod ? t.relayout(!0) : t.layout());
          }),
          (e.prototype.collapseCombo = function (t) {
            const e = this;
            if ((Object(u.o)(t) && (t = this.findById(t)), t)) {
              this.emit('beforecollapseexpandcombo', { action: 'expand', item: t });
              const n = t.getModel();
              this.get('itemController').collapseCombo(t), (n.collapsed = !0);
              const r = this.getEdges().concat(this.get('vedges'));
              let i = [];
              let o = [];
              const a = this.get('comboTrees');
              let s = !1;
              (a || []).forEach((t) => {
                s ||
                  gt(t, (t) => {
                    if (s && t.depth <= n.depth) return !1;
                    if ((n.id === t.id && (s = !0), s)) {
                      const r = e.findById(t.id);
                      r &&
                        r.getType &&
                        r.getType() === 'combo' &&
                        ((i = i.concat(r.getNodes())), (o = o.concat(r.getCombos())));
                    }
                    return !0;
                  });
              });
              const c = {};
              const h = [];
              r.forEach((t) => {
                if (!t.isVisible() || t.getModel().isVEdge) {
                  let r = t.getSource();
                  let a = t.getTarget();
                  if (
                    ((i.includes(r) || o.includes(r)) && !i.includes(a) && !o.includes(a)) ||
                    r.getModel().id === n.id
                  ) {
                    if ((f = t.getModel()).isVEdge) return void e.removeItem(t, !1);
                    for (var s = a.getModel(); !a.isVisible(); ) {
                      if (!(a = e.findById(s.parentId || s.comboId)) || (!s.parentId && !s.comboId))
                        return;
                      s = a.getModel();
                    }
                    const u = s.id;
                    if (c[`${n.id}-${u}`]) return void (c[`${n.id}-${u}`] += f.size || 1);
                    var l = e.addItem('vedge', { source: n.id, target: u, isVEdge: !0 }, !1);
                    (c[`${n.id}-${u}`] = f.size || 1), h.push(l);
                  } else if (
                    (!i.includes(r) && !o.includes(r) && (i.includes(a) || o.includes(a))) ||
                    a.getModel().id === n.id
                  ) {
                    var f;
                    if ((f = t.getModel()).isVEdge) return void e.removeItem(t, !1);
                    for (var d = r.getModel(); !r.isVisible(); ) {
                      if (!(r = e.findById(d.parentId || d.comboId)) || (!d.parentId && !d.comboId))
                        return;
                      d = r.getModel();
                    }
                    const p = d.id;
                    if (c[`${p}-${n.id}`]) return void (c[`${p}-${n.id}`] += f.size || 1);
                    l = e.addItem('vedge', { target: n.id, source: p, isVEdge: !0 }, !1);
                    (c[`${p}-${n.id}`] = f.size || 1), h.push(l);
                  }
                }
              }),
                h.forEach((t) => {
                  const n = t.getModel();
                  e.updateItem(t, { size: c[`${n.source}-${n.target}`] }, !1);
                }),
                this.emit('aftercollapseexpandcombo', { action: 'collapse', item: t });
            } else console.warn('The combo to be collapsed does not exist!');
          }),
          (e.prototype.expandCombo = function (t) {
            const e = this;
            if (
              (Object(u.o)(t) && (t = this.findById(t)),
              !t || (t.getType && t.getType() !== 'combo'))
            )
              console.warn('The combo to be collapsed does not exist!');
            else {
              this.emit('beforecollapseexpandcombo', { action: 'expand', item: t });
              const n = t.getModel();
              this.get('itemController').expandCombo(t), (n.collapsed = !1);
              const r = this.getEdges().concat(this.get('vedges'));
              let i = [];
              let o = [];
              const a = this.get('comboTrees');
              let s = !1;
              (a || []).forEach((t) => {
                s ||
                  gt(t, (t) => {
                    if (s && t.depth <= n.depth) return !1;
                    if ((n.id === t.id && (s = !0), s)) {
                      const r = e.findById(t.id);
                      r &&
                        r.getType &&
                        r.getType() === 'combo' &&
                        ((i = i.concat(r.getNodes())), (o = o.concat(r.getCombos())));
                    }
                    return !0;
                  });
              });
              const c = {};
              const h = {};
              r.forEach((t) => {
                if (!t.isVisible() || t.getModel().isVEdge) {
                  let r = t.getSource();
                  let a = t.getTarget();
                  let s = r.get('id');
                  let u = a.get('id');
                  if (
                    ((i.includes(r) || o.includes(r)) && !i.includes(a) && !o.includes(a)) ||
                    s === n.id
                  ) {
                    if (t.getModel().isVEdge) return void e.removeItem(t, !1);
                    for (var l = a.getModel(); !a.isVisible(); ) {
                      if (!(a = e.findById(l.comboId || l.parentId)) || (!l.parentId && !l.comboId))
                        return;
                      l = a.getModel();
                    }
                    u = l.id;
                    for (var f = r.getModel(); !r.isVisible(); ) {
                      if (!(r = e.findById(f.comboId || f.parentId)) || (!f.parentId && !f.comboId))
                        return;
                      if (f.comboId === n.id || f.parentId === n.id) break;
                      f = r.getModel();
                    }
                    if (((s = f.id), u)) {
                      if (c[(p = `${s}-${u}`)])
                        return (
                          (c[p] += t.getModel().size || 1),
                          void e.updateItem(h[p], { size: c[p] }, !1)
                        );
                      var d = e.addItem('vedge', { source: s, target: u, isVEdge: !0 }, !1);
                      (c[p] = t.getModel().size || 1), (h[p] = d);
                    }
                  } else if (
                    (!i.includes(r) && !o.includes(r) && (i.includes(a) || o.includes(a))) ||
                    u === n.id
                  ) {
                    if (t.getModel().isVEdge) return void e.removeItem(t, !1);
                    for (f = r.getModel(); !r.isVisible(); ) {
                      if (!(r = e.findById(f.comboId || f.parentId)) || (!f.parentId && !f.comboId))
                        return;
                      f = r.getModel();
                    }
                    s = f.id;
                    for (l = a.getModel(); !a.isVisible(); ) {
                      if (!(a = e.findById(l.comboId || l.parentId)) || (!l.parentId && !l.comboId))
                        return;
                      if (l.comboId === n.id || l.parentId === n.id) break;
                      l = a.getModel();
                    }
                    if (((u = l.id), s)) {
                      var p;
                      if (c[(p = `${s}-${u}`)])
                        return (
                          (c[p] += t.getModel().size || 1),
                          void e.updateItem(h[p], { size: c[p] }, !1)
                        );
                      d = e.addItem('vedge', { target: u, source: s, isVEdge: !0 }, !1);
                      (c[p] = t.getModel().size || 1), (h[p] = d);
                    }
                  } else
                    (i.includes(r) || o.includes(r)) &&
                      (i.includes(a) || o.includes(a)) &&
                      r.isVisible() &&
                      a.isVisible() &&
                      t.show();
                }
              }),
                this.emit('aftercollapseexpandcombo', { action: 'expand', item: t });
            }
          }),
          (e.prototype.collapseExpandCombo = function (t) {
            if (
              (Object(u.o)(t) && (t = this.findById(t)),
              t && (!t.getType || t.getType() === 'combo'))
            ) {
              for (var e = t.getModel(), n = this.findById(e.parentId); n; ) {
                const r = n.getModel();
                if (r.collapsed)
                  return (
                    console.warn(
                      "Fail to expand the combo since it's ancestor combo is collapsed.",
                    ),
                    void (n = void 0)
                  );
                n = this.findById(r.parentId);
              }
              e.collapsed ? this.expandCombo(t) : this.collapseCombo(t), this.updateCombo(t);
            }
          }),
          (e.prototype.sortCombos = function () {
            const t = this;
            if (!this.get('comboSorted')) {
              this.set('comboSorted', !0);
              const e = [];
              const n = {};
              (this.get('comboTrees') || []).forEach((t) => {
                gt(t, (t) => {
                  return (
                    e[t.depth] ? e[t.depth].push(t.id) : (e[t.depth] = [t.id]),
                    (n[t.id] = t.depth),
                    !0
                  );
                });
              }),
                (this.getEdges().concat(this.get('vedges')) || []).forEach((t) => {
                  const r = t.getModel();
                  const i = n[r.source] || 0;
                  const o = n[r.target] || 0;
                  const a = Math.max(i, o);
                  e[a] ? e[a].push(r.id) : (e[a] = [r.id]);
                }),
                e.forEach((e) => {
                  if (e && e.length)
                    for (let n = e.length - 1; n >= 0; n--) {
                      const r = t.findById(e[n]);
                      r && r.toFront();
                    }
                });
            }
          }),
          (e.prototype.getNeighbors = function (t, e) {
            let n = t;
            return Object(u.o)(t) && (n = this.findById(t)), n.getNeighbors(e);
          }),
          (e.prototype.getNodeDegree = function (t, e, n) {
            void 0 === e && (e = void 0), void 0 === n && (n = !1);
            let r = t;
            Object(u.o)(t) && (r = this.findById(t));
            let i = this.get('degrees');
            (i && !n) || ((i = Object(m.getDegree)(this.save())), this.set('degrees', i));
            const o = i[r.getID()];
            let a = 0;
            if (!o) return 0;
            switch (e) {
              case 'in':
                a = o.inDegree;
                break;
              case 'out':
                a = o.outDegree;
                break;
              case 'all':
                a = o;
                break;
              default:
                a = o.degree;
            }
            return a;
          }),
          (e.prototype.getUndoStack = function () {
            return this.undoStack;
          }),
          (e.prototype.getRedoStack = function () {
            return this.redoStack;
          }),
          (e.prototype.getStackData = function () {
            return this.get('enabledStack')
              ? { undoStack: this.undoStack.toArray(), redoStack: this.redoStack.toArray() }
              : null;
          }),
          (e.prototype.clearStack = function () {
            this.get('enabledStack') && (this.undoStack.clear(), this.redoStack.clear());
          }),
          (e.prototype.pushStack = function (t, e, n) {
            if (
              (void 0 === t && (t = 'update'),
              void 0 === n && (n = 'undo'),
              this.get('enabledStack'))
            ) {
              const r = e ? Object(u.a)(e) : { before: {}, after: Object(u.a)(this.save()) };
              n === 'redo'
                ? this.redoStack.push({ action: t, data: r })
                : this.undoStack.push({ action: t, data: r }),
                this.emit('stackchange', { undoStack: this.undoStack, redoStack: this.redoStack });
            } else
              console.warn(
                '请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !',
              );
          }),
          (e.prototype.getAdjMatrix = function (t, e) {
            void 0 === t && (t = !0), void 0 === e && (e = this.get('directed'));
            let n = this.get('adjMatrix');
            return (
              (n && t) || ((n = Object(m.getAdjMatrix)(this.save(), e)), this.set('adjMatrix', n)),
              n
            );
          }),
          (e.prototype.getShortestPathMatrix = function (t, e) {
            void 0 === t && (t = !0), void 0 === e && (e = this.get('directed'));
            let n = this.get('adjMatrix');
            let r = this.get('shortestPathMatrix');
            return (
              (n && t) || ((n = Object(m.getAdjMatrix)(this.save(), e)), this.set('adjMatrix', n)),
              (r && t) ||
                ((r = Object(m.floydWarshall)(this.save(), e)), this.set('shortestPathMatrix', r)),
              r
            );
          }),
          (e.prototype.on = function (e, n, r) {
            return t.prototype.on.call(this, e, n, r);
          }),
          (e.prototype.destroy = function () {
            this.clear(),
              this.clearStack(),
              this.get('itemController').destroy(),
              this.get('modeController').destroy(),
              this.get('viewController').destroy(),
              this.get('stateController').destroy(),
              this.get('canvas').destroy(),
              (this.cfg = null),
              (this.destroyed = !0),
              (this.redoStack = null),
              (this.undoStack = null);
          }),
          (e.prototype.createHull = function (t) {
            if (t.members && !(t.members.length < 1)) {
              let e = this.get('hullGroup');
              let n = this.get('hullMap');
              if (
                (n || ((n = {}), this.set('hullMap', n)),
                (e && !e.get('destroyed')) ||
                  ((e = this.get('group').addGroup({ id: 'hullGroup' })).toBack(),
                  this.set('hullGroup', e)),
                n[t.id])
              )
                return console.warn('Existed hull id.'), n[t.id];
              const r = e.addGroup({ id: `${t.id}-container` });
              const i = new Me(this, Object(f.a)(Object(f.a)({}, t), { group: r }));
              return (n[i.id] = i), i;
            }
            console.warn('Create hull failed! The members is empty.');
          }),
          (e.prototype.getHulls = function () {
            return this.get('hullMap');
          }),
          (e.prototype.getHullById = function (t) {
            return this.get('hullMap')[t];
          }),
          (e.prototype.removeHull = function (t) {
            let e;
            (e = Object(u.o)(t) ? this.getHullById(t) : t),
              delete this.get('hullMap')[e.id],
              e.destroy();
          }),
          (e.prototype.removeHulls = function () {
            const t = this.getHulls();
            t &&
              Object.keys(t).length &&
              (Object.keys(t).forEach((e) => {
                t[e].destroy();
              }),
              this.set('hullMap', {}));
          }),
          (e.prototype.onTick = function (t) {
            this.get('layoutController').onTick(t), v(this.onTick.bind(this));
          }),
          e
        );
      })(d.a);
      function Oe(t) {
        return (Oe =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const Ce = y.a.transform;
      const Ee = ['startArrow', 'endArrow'];
      const ke = {
        lineWidth: 1,
        stroke: void 0,
        fill: void 0,
        lineAppendWidth: 1,
        opacity: void 0,
        strokeOpacity: void 0,
        fillOpacity: void 0,
        x: 0,
        y: 0,
        r: 10,
        width: 20,
        height: 20,
        shadowColor: void 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
      };
      const Te = {
        edge: {
          lineWidth: 1,
          stroke: '#000',
          lineDash: void 0,
          startArrow: !1,
          endArrow: !1,
          opacity: void 0,
          strokeOpacity: void 0,
          fillOpacity: void 0,
          shadowColor: void 0,
          shadowBlur: 0,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
        },
        node: ke,
        combo: ke,
      };
      const Pe = {
        options: {},
        itemType: '',
        type: '',
        getCustomConfig(t) {
          return {};
        },
        getOptions(t) {
          return Object(u.b)(
            {
              labelCfg: {
                style: {
                  fontFamily:
                    (typeof window !== 'undefined' &&
                      window.getComputedStyle &&
                      window
                        .getComputedStyle(document.body, null)
                        .getPropertyValue('font-family')) ||
                    'Arial, sans-serif',
                },
              },
              descriptionCfg: {
                style: {
                  fontFamily:
                    (typeof window !== 'undefined' &&
                      window.getComputedStyle &&
                      window
                        .getComputedStyle(document.body, null)
                        .getPropertyValue('font-family')) ||
                    'Arial, sans-serif',
                },
              },
            },
            this.options,
            this.getCustomConfig(t) || {},
            t,
          );
        },
        draw(t, e) {
          const n = this.drawShape(t, e);
          (n.set('className', `${this.itemType}-shape`), t.label) &&
            this.drawLabel(t, e).set('className', `${this.itemType}-label`);
          return n;
        },
        afterDraw(t, e, n) {},
        drawShape(t, e) {
          return null;
        },
        drawLabel(t, e) {
          const n = this.getOptions(t).labelCfg || {};
          const r = this.getLabelStyle(t, n, e);
          const i = r.rotate;
          delete r.rotate;
          const o = e.addShape('text', {
            attrs: r,
            draggable: !0,
            className: 'text-shape',
            name: 'text-shape',
          });
          if (i) {
            const a = o.getBBox();
            let s = o.getMatrix();
            if ((s || (s = [1, 0, 0, 0, 1, 0, 0, 0, 1]), r.rotateCenter))
              switch (r.rotateCenter) {
                case 'center':
                  s = Ce(s, [
                    ['t', -a.width / 2, -a.height / 2],
                    ['r', i],
                    ['t', a.width / 2, a.height / 2],
                  ]);
                  break;
                case 'lefttop':
                  s = Ce(s, [
                    ['t', -r.x, -r.y],
                    ['r', i],
                    ['t', r.x, r.y],
                  ]);
                  break;
                case 'leftcenter':
                  s = Ce(s, [
                    ['t', -r.x, -r.y - a.height / 2],
                    ['r', i],
                    ['t', r.x, r.y + a.height / 2],
                  ]);
                  break;
                default:
                  s = Ce(s, [
                    ['t', -a.width / 2, -a.height / 2],
                    ['r', i],
                    ['t', a.width / 2, a.height / 2],
                  ]);
              }
            else
              s = Ce(s, [
                ['t', -r.x, -r.y - a.height / 2],
                ['r', i],
                ['t', r.x, r.y + a.height / 2],
              ]);
            o.setMatrix(s);
          }
          if (r.background) {
            const u = this.drawLabelBg(t, e, o);
            const c = `${this.itemType}-label-bg`;
            u.set('classname', c), o.toFront();
          }
          return o;
        },
        drawLabelBg(t, e, n) {
          const r = this.options.labelCfg;
          const i = Object(u.r)({}, r, t.labelCfg);
          const o = this.getLabelBgStyleByPosition(n, t, i, e);
          return e.addShape('rect', { name: 'text-bg-shape', attrs: o });
        },
        getLabelStyleByPosition(t, e, n) {
          return { text: t.label };
        },
        getLabelBgStyleByPosition(t, e, n, r) {
          return {};
        },
        getLabelStyle(t, e, n) {
          const r = this.getLabelStyleByPosition(t, e, n);
          const i = `${this.itemType}Label`;
          const o = it[i] ? it[i].style : null;
          return Object(f.a)(Object(f.a)(Object(f.a)({}, o), r), e.style);
        },
        getShapeStyle(t) {
          return t.style;
        },
        update(t, e) {
          this.updateShapeStyle(t, e), this.updateLabel(t, e);
        },
        updateShapeStyle(t, e) {
          const n = e.getContainer();
          const r = e.getKeyShape();
          const i = Object(u.r)({}, r.attr(), t.style);
          const o = function (t) {
            let e;
            const o = i[t];
            if (Object(u.n)(o)) {
              const a = n.find((e) => {
                return e.get('name') === t;
              });
              a && a.attr(o);
            } else r.attr((((e = {})[t] = o), e));
          };
          for (const a in i) o(a);
        },
        updateLabel(t, e) {
          const n = e.getContainer();
          const r = this.getOptions({}).labelCfg;
          const i = `${this.itemType}-label`;
          const o = n.find((t) => {
            return t.get('className') === i;
          });
          const a = `${this.itemType}-label-bg`;
          let s = n.find((t) => {
            return t.get('classname') === a;
          });
          if (t.label || t.label === '')
            if (o) {
              let c = {};
              e.getModel && (c = e.getModel().labelCfg);
              const h = Object(u.b)({}, r, c, t.labelCfg);
              const l = this.getLabelStyleByPosition(t, h, n);
              const d = t.labelCfg ? t.labelCfg.style : void 0;
              const p = h.style && h.style.background;
              const g = Object(f.a)(Object(f.a)(Object(f.a)({}, o.attr()), l), d);
              const v = g.rotate;
              if ((delete g.rotate, v)) {
                let y = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                (y = Ce(y, [
                  ['t', -g.x, -g.y],
                  ['r', v],
                  ['t', g.x, g.y],
                ])),
                  o.resetMatrix(),
                  o.attr(Object(f.a)(Object(f.a)({}, g), { matrix: y }));
              } else o.resetMatrix(), o.attr(g);
              if (s)
                if (g.background) {
                  const m = this.getLabelBgStyleByPosition(o, t, h, n);
                  const b = Object(f.a)(Object(f.a)({}, m), p);
                  if ((s.resetMatrix(), v)) {
                    let x = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                    (x = Ce(x, [
                      ['t', -b.x, -b.y],
                      ['r', v],
                      ['t', b.x, b.y],
                    ])),
                      (b.matrix = x);
                  }
                  s.attr(b);
                } else n.removeChild(s);
              else
                g.background && ((s = this.drawLabelBg(t, n, o)).set('classname', a), o.toFront());
            } else {
              this.drawLabel(t, n).set('className', i);
            }
        },
        afterUpdate(t, e) {},
        setState(t, e, n) {
          let r;
          let i;
          const o = n.get('keyShape');
          if (o && !o.destroyed) {
            const a = n.getType();
            const s = Object(u.g)(e) ? t : `${t}:${e}`;
            const c = this.getStateStyle(s, n);
            const h = n.getStateStyle(s);
            if (h || c) {
              const l = Object(u.r)({}, h || c);
              const f = n.getContainer();
              const d = { x: 1, y: 1, cx: 1, cy: 1 };
              if ((a === 'combo' && ((d.r = 1), (d.width = 1), (d.height = 1)), e)) {
                const p = function (t) {
                  let e;
                  const n = l[t];
                  if (Object(u.n)(n) && !Ee.includes(t)) {
                    const r = f.find((e) => {
                      return e.get('name') === t;
                    });
                    r && r.attr(n);
                  } else o.attr((((e = {})[t] = n), e));
                };
                for (var g in l) p(g);
              } else {
                const v = wt(n.getCurrentStatesStyle());
                const y = n.getModel();
                const m = Object(u.r)({}, y.style, wt(n.getOriginStyle()));
                const b = o.get('name');
                const x = o.attr();
                const M = {};
                Object.keys(x).forEach((t) => {
                  if (t !== 'img') {
                    const e = x[t];
                    e && Oe(e) === 'object' ? (M[t] = Object(u.a)(e)) : (M[t] = e);
                  }
                });
                const S = {};
                const w = function (t) {
                  const e = l[t];
                  if (Object(u.n)(e) && !Ee.includes(t)) {
                    const n = f.find((e) => {
                      return e.get('name') === t;
                    });
                    if (n) {
                      const r = Object(u.a)(n.attr());
                      Object(u.c)(e, (e, i) => {
                        if (t === b && M[i] && !d[i]) {
                          delete M[i];
                          const s = m[t][i] || Te[a][i];
                          o.attr(i, s);
                        } else if (r[i] || r[i] === 0) {
                          delete r[i];
                          const u = m[t][i] || Te[a][i];
                          n.attr(i, u);
                        }
                      }),
                        (S[t] = r);
                    }
                  } else if (M[t] && !d[t]) {
                    delete M[t];
                    const i = m[t] || (m[b] ? m[b][t] : void 0) || Te[a][t];
                    o.attr(t, i);
                  }
                };
                for (const O in l) w(O);
                for (var g in (b ? (S[b] = M) : Object(u.r)(S, M), v))
                  if (!d[g]) {
                    const C = v[g];
                    (Object(u.n)(C) && !Ee.includes(g)) ||
                      (b
                        ? (Object(u.r)(m[b], (((i = {})[g] = C), i)), delete m[g])
                        : Object(u.r)(m, (((r = {})[g] = C), r)),
                      delete v[g]);
                  }
                const E = {};
                Object(u.b)(E, m, S, v);
                let k = !1;
                const T = function (t) {
                  let e;
                  let n;
                  const r = E[t];
                  if (Object(u.n)(r) && !Ee.includes(t)) {
                    const i = f.find((e) => {
                      return e.get('name') === t;
                    });
                    i &&
                      (t === b &&
                        (a === 'combo' && (delete r.r, delete r.width, delete r.height), (k = !0)),
                      i.attr(r));
                  } else if (!k) {
                    const s = r || Te[a][t];
                    a === 'combo'
                      ? b || o.attr((((e = {})[t] = s), e))
                      : o.attr((((n = {})[t] = s), n));
                  }
                };
                for (const P in E) T(P);
              }
            }
          }
        },
        getStateStyle(t, e) {
          const n = e.getModel();
          const r = e.getType();
          const i = this.getOptions(n);
          const o = i.stateStyles;
          const a = i.style;
          const s = void 0 === a ? {} : a;
          const c = n.stateStyles ? n.stateStyles[t] : o && o[t];
          return r === 'combo' ? Object(u.a)(c) : Object(u.r)({}, s, c);
        },
        getControlPoints(t) {
          return t.controlPoints;
        },
        getAnchorPoints(t) {
          return this.getOptions(t).anchorPoints;
        },
      };
      const Ie = {
        itemType: 'node',
        shapeType: 'single-node',
        labelPosition: 'center',
        offset: it.nodeLabel.offset,
        getSize(t) {
          let e = t.size || this.getOptions({}).size || it.defaultNode.size;
          return (
            Object(u.f)(e) && e.length === 1 && (e = [e[0], e[0]]),
            Object(u.f)(e) || (e = [e, e]),
            e
          );
        },
        getLabelStyleByPosition(t, e) {
          const n = e.position || this.labelPosition;
          if (n === 'center') return { x: 0, y: 0, text: t.label };
          let r = e.offset;
          Object(u.j)(r) && (r = this.offset);
          let i;
          const o = this.getSize(t);
          const a = o[0];
          const s = o[1];
          switch (n) {
            case 'top':
              i = { x: 0, y: 0 - s / 2 - r, textBaseline: 'bottom' };
              break;
            case 'bottom':
              i = { x: 0, y: s / 2 + r, textBaseline: 'top' };
              break;
            case 'left':
              i = { x: 0 - a / 2 - r, y: 0, textAlign: 'right' };
              break;
            default:
              i = { x: a / 2 + r, y: 0, textAlign: 'left' };
          }
          return (i.text = t.label), i;
        },
        getLabelBgStyleByPosition(t, e, n, r) {
          if (!t) return {};
          const i = t.getBBox();
          const o = n.style && n.style.background;
          if (!o) return {};
          let a;
          const s = Pt(o.padding);
          const c = i.width + s[1] + s[3];
          const h = i.height + s[0] + s[2];
          let l = n.offset;
          return (
            Object(u.j)(l) && (l = this.offset),
            (a = { x: i.minX - s[3], y: i.minY - s[0] }),
            (a = Object(f.a)(Object(f.a)(Object(f.a)({}, a), o), { width: c, height: h }))
          );
        },
        drawShape(t, e) {
          const n = this.shapeType;
          const r = this.getShapeStyle(t);
          return e.addShape(n, { attrs: r, draggable: !0, name: 'node-shape' });
        },
        updateLinkPoints(t, e) {
          let n;
          const r = this.getOptions(t).linkPoints;
          const i = e.find((t) => {
            return t.get('className') === 'link-point-left';
          });
          const o = e.find((t) => {
            return t.get('className') === 'link-point-right';
          });
          const a = e.find((t) => {
            return t.get('className') === 'link-point-top';
          });
          const s = e.find((t) => {
            return t.get('className') === 'link-point-bottom';
          });
          i && (n = i.attr()),
            o && !n && (n = o.attr()),
            a && !n && (n = a.attr()),
            s && !n && (n = s.attr()),
            n || (n = r);
          const c = Object(u.r)({}, n, t.linkPoints);
          const h = c.fill;
          const l = c.stroke;
          const d = c.lineWidth;
          let p = c.size / 2;
          p || (p = c.r);
          const g = t.linkPoints
            ? t.linkPoints
            : { left: void 0, right: void 0, top: void 0, bottom: void 0 };
          const v = g.left;
          const y = g.right;
          const m = g.top;
          const b = g.bottom;
          const x = this.getSize(t);
          const M = x[0];
          const S = x[1];
          const w = { r: p, fill: h, stroke: l, lineWidth: d };
          i
            ? v || void 0 === v
              ? i.attr(Object(f.a)(Object(f.a)({}, w), { x: -M / 2, y: 0 }))
              : i.remove()
            : v &&
              e.addShape('circle', {
                attrs: Object(f.a)(Object(f.a)({}, w), { x: -M / 2, y: 0 }),
                className: 'link-point-left',
                name: 'link-point-left',
                isAnchorPoint: !0,
              }),
            o
              ? (y || void 0 === y || o.remove(),
                o.attr(Object(f.a)(Object(f.a)({}, w), { x: M / 2, y: 0 })))
              : y &&
                e.addShape('circle', {
                  attrs: Object(f.a)(Object(f.a)({}, w), { x: M / 2, y: 0 }),
                  className: 'link-point-right',
                  name: 'link-point-right',
                  isAnchorPoint: !0,
                }),
            a
              ? (m || void 0 === m || a.remove(),
                a.attr(Object(f.a)(Object(f.a)({}, w), { x: 0, y: -S / 2 })))
              : m &&
                e.addShape('circle', {
                  attrs: Object(f.a)(Object(f.a)({}, w), { x: 0, y: -S / 2 }),
                  className: 'link-point-top',
                  name: 'link-point-top',
                  isAnchorPoint: !0,
                }),
            s
              ? b || void 0 === b
                ? s.attr(Object(f.a)(Object(f.a)({}, w), { x: 0, y: S / 2 }))
                : s.remove()
              : b &&
                e.addShape('circle', {
                  attrs: Object(f.a)(Object(f.a)({}, w), { x: 0, y: S / 2 }),
                  className: 'link-point-bottom',
                  name: 'link-point-bottom',
                  isAnchorPoint: !0,
                });
        },
        updateShape(t, e, n, r) {
          e.get('keyShape').attr(Object(f.a)({}, n)),
            this.updateLabel(t, e),
            r && this.updateIcon(t, e);
        },
        updateIcon(t, e) {
          const n = this;
          const r = e.getContainer();
          const i = this.getOptions(t).icon;
          const o = (t.icon ? t.icon : { show: void 0 }).show;
          const a = r.find((t) => {
            return t.get('className') === `${n.type}-icon`;
          });
          if (a)
            if (o || void 0 === o) {
              const s = Object(u.r)({}, a.attr(), i);
              var c = s.width;
              var h = s.height;
              a.attr(Object(f.a)(Object(f.a)({}, s), { x: -c / 2, y: -h / 2 }));
            } else a.remove();
          else if (o) {
            (c = i.width), (h = i.height);
            r.addShape('image', {
              attrs: Object(f.a)(Object(f.a)({}, i), { x: -c / 2, y: -h / 2 }),
              className: `${this.type}-icon`,
              name: `${this.type}-icon`,
            });
            const l = r.find((t) => {
              return t.get('className') === 'node-label';
            });
            l && l.toFront();
          }
        },
      };
      const Ae = Object(f.a)(Object(f.a)({}, Pe), Ie);
      Ut.registerNode('single-node', Ae);
      const je = {
        itemType: 'edge',
        labelPosition: 'center',
        refX: 0,
        refY: 0,
        labelAutoRotate: !1,
        options: {
          size: it.defaultEdge.size,
          style: {
            x: 0,
            y: 0,
            stroke: it.defaultEdge.style.stroke,
            lineAppendWidth: it.defaultEdge.style.lineAppendWidth,
          },
          labelCfg: {
            style: { fill: it.edgeLabel.style.fill, fontSize: it.edgeLabel.style.fontSize },
          },
          stateStyles: Object(f.a)({}, it.edgeStateStyles),
        },
        getPath(t) {
          const e = [];
          return (
            Object(u.c)(t, (t, n) => {
              n === 0 ? e.push(['M', t.x, t.y]) : e.push(['L', t.x, t.y]);
            }),
            e
          );
        },
        getShapeStyle(t) {
          const e = this.options.style;
          const n = { stroke: t.color };
          const r = Object(u.r)({}, e, n, t.style);
          const i = t.size || it.defaultEdge.size;
          const o = (t = this.getPathPoints(t)).startPoint;
          const a = t.endPoint;
          const s = this.getControlPoints(t);
          let c = [o];
          s && (c = c.concat(s)), c.push(a);
          const h = this.getPath(c);
          return Object(u.r)(
            {},
            it.defaultEdge.style,
            { stroke: it.defaultEdge.color, lineWidth: i, path: h },
            r,
          );
        },
        updateShapeStyle(t, e) {
          const n = e.getContainer();
          const r = { stroke: t.color };
          const i =
            n.find((t) => {
              return t.get('className') === 'edge-shape';
            }) || e.getKeyShape();
          const o = t.size;
          const a = (t = this.getPathPoints(t)).startPoint;
          const s = t.endPoint;
          const c = this.getControlPoints(t);
          let h = [a];
          c && (h = h.concat(c)), h.push(s);
          const l = i.attr();
          const f = Object(u.r)({}, r, l, t.style);
          const d = t.sourceNode;
          const p = t.targetNode;
          let g = { radius: f.radius };
          c || (g = { source: d, target: p, offset: f.offset, radius: f.radius }),
            l.endArrow && !1 === f.endArrow && (t.style.endArrow = { path: '' }),
            l.startArrow && !1 === f.startArrow && (t.style.startArrow = { path: '' });
          const v = this.getPath(h, g);
          const y = Object(u.r)(r, i.attr(), { lineWidth: o, path: v }, t.style);
          i && i.attr(y);
        },
        getLabelStyleByPosition(t, e, n) {
          let r;
          const i = e.position || this.labelPosition;
          const o = {};
          const a =
            n &&
            n.find((t) => {
              return t.get('className') === 'edge-shape';
            });
          r = i === 'start' ? 0 : i === 'end' ? 1 : 0.5;
          let s;
          const c = e.refX || this.refX;
          const h = e.refY || this.refY;
          if (t.startPoint.x === t.endPoint.x && t.startPoint.y === t.endPoint.y)
            return (o.x = t.startPoint.x + c), (o.y = t.startPoint.y + h), (o.text = t.label), o;
          s = Object(u.j)(e.autoRotate) ? this.labelAutoRotate : e.autoRotate;
          const l = dt(a, r, c, h, s);
          return (
            (o.x = l.x),
            (o.y = l.y),
            (o.rotate = l.rotate),
            (o.textAlign = this._getTextAlign(i, l.angle)),
            (o.text = t.label),
            o
          );
        },
        getLabelBgStyleByPosition(t, e, n, r) {
          if (!t) return {};
          const i = t.getBBox();
          const o = n.style && n.style.background;
          if (!o) return {};
          let a;
          const s = o.padding;
          const c = i.width + s[1] + s[3];
          const h = i.height + s[0] + s[2];
          const l = n.position || this.labelPosition;
          const d = Object(f.a)(Object(f.a)({}, o), {
            width: c,
            height: h,
            x: i.minX - s[2],
            y: i.minY - s[0],
            rotate: 0,
          });
          a = Object(u.j)(n.autoRotate) ? this.labelAutoRotate : n.autoRotate;
          let p;
          const g =
            r &&
            r.find((t) => {
              return t.get('className') === 'edge-shape';
            });
          p = l === 'start' ? 0 : l === 'end' ? 1 : 0.5;
          const v = n.refX || this.refX;
          const y = n.refY || this.refY;
          if (e.startPoint.x === e.endPoint.x && e.startPoint.y === e.endPoint.y)
            return (d.x = e.startPoint.x + v - c / 2), (d.y = e.startPoint.y + y - h / 2), d;
          let m = dt(g, p, v - c / 2, y + h / 2, a);
          const b = m.angle;
          return (
            b > 0.5 * Math.PI && b < 1.5 * Math.PI && (m = dt(g, p, v + c / 2, y + h / 2, a)),
            a && ((d.x = m.x), (d.y = m.y)),
            (d.rotate = m.rotate),
            d
          );
        },
        _getTextAlign(t, e) {
          let n = 'center';
          return e
            ? ((e %= 2 * Math.PI),
              t !== 'center' &&
                (n =
                  (e >= 0 && e <= Math.PI / 2) || (e >= 1.5 * Math.PI && e < 2 * Math.PI)
                    ? t
                    : (function (t) {
                        let e = t;
                        return t === 'start' ? (e = 'end') : t === 'end' && (e = 'start'), e;
                      })(t)),
              n)
            : t;
        },
        getControlPoints(t) {
          return t.controlPoints;
        },
        getPathPoints(t) {
          return t;
        },
        drawShape(t, e) {
          const n = this.getShapeStyle(t);
          return e.addShape('path', { className: 'edge-shape', name: 'edge-shape', attrs: n });
        },
        drawLabel(t, e) {
          let n;
          const r = this.options.labelCfg;
          n =
            (typeof window !== 'undefined' &&
              void 0 !== window.getComputedStyle &&
              window.getComputedStyle(document.body, null).getPropertyValue('font-family')) ||
            'Arial, sans-serif';
          const i = Object(u.b)({ fontFamily: n }, r, t.labelCfg);
          const o = this.getLabelStyle(t, i, e);
          const a = o.rotate;
          delete o.rotate;
          const s = e.addShape('text', { attrs: o, name: 'text-shape' });
          if ((a && s.rotateAtStart(a), o.background)) {
            const c = this.drawLabelBg(t, e, s);
            const h = `${this.itemType}-label-bg`;
            c.set('classname', h), s.toFront();
          }
          return s;
        },
        drawLabelBg(t, e, n) {
          const r = this.options.labelCfg;
          const i = Object(u.b)({}, r, t.labelCfg);
          const o = this.getLabelStyle(t, i, e).rotate;
          const a = this.getLabelBgStyleByPosition(n, t, i, e);
          delete a.rotate;
          const s = e.addShape('rect', { name: 'text-bg-shape', attrs: a });
          return o && s.rotateAtStart(o), s;
        },
      };
      const Ne = Object(f.a)(Object(f.a)({}, Pe), je);
      Ut.registerEdge('single-edge', Ne),
        Ut.registerEdge('line', { getControlPoints() {} }, 'single-edge'),
        Ut.registerEdge(
          'spline',
          {
            getPath(t) {
              return ne(t);
            },
          },
          'single-edge',
        ),
        Ut.registerEdge(
          'arc',
          {
            curveOffset: 20,
            clockwise: 1,
            getControlPoints(t) {
              let e;
              let n;
              const r = t.startPoint;
              const i = t.endPoint;
              const o = (r.x + i.x) / 2;
              const a = (r.y + i.y) / 2;
              if (void 0 !== t.controlPoints) {
                if (
                  ((n = t.controlPoints[0]),
                  (e = T(r, n, i)),
                  r.x <= i.x && r.y > i.y
                    ? (this.clockwise = e.x > n.x ? 0 : 1)
                    : r.x <= i.x && r.y < i.y
                    ? (this.clockwise = e.x > n.x ? 1 : 0)
                    : r.x > i.x && r.y <= i.y
                    ? (this.clockwise = e.y < n.y ? 0 : 1)
                    : (this.clockwise = e.y < n.y ? 1 : 0),
                  (n.x - r.x) / (n.y - r.y) == (i.x - r.x) / (i.y - r.y))
                )
                  return [];
              } else {
                void 0 === t.curveOffset && (t.curveOffset = this.curveOffset),
                  Object(u.f)(t.curveOffset) && (t.curveOffset = t.curveOffset[0]),
                  t.curveOffset < 0 ? (this.clockwise = 0) : (this.clockwise = 1);
                const s = { x: i.x - r.x, y: i.y - r.y };
                const c = Math.atan2(s.y, s.x);
                (n = {
                  x: t.curveOffset * Math.cos(-Math.PI / 2 + c) + o,
                  y: t.curveOffset * Math.sin(-Math.PI / 2 + c) + a,
                }),
                  (e = T(r, n, i));
              }
              const h = P(r, e);
              return [{ x: h, y: h }];
            },
            getPath(t) {
              const e = [];
              return (
                e.push(['M', t[0].x, t[0].y]),
                t.length === 2
                  ? e.push(['L', t[1].x, t[1].y])
                  : e.push(['A', t[1].x, t[1].y, 0, 0, this.clockwise, t[2].x, t[2].y]),
                e
              );
            },
          },
          'single-edge',
        ),
        Ut.registerEdge(
          'quadratic',
          {
            curvePosition: 0.5,
            curveOffset: -20,
            getControlPoints(t) {
              let e = t.controlPoints;
              if (!e || !e.length) {
                const n = t.startPoint;
                const r = t.endPoint;
                void 0 === t.curveOffset && (t.curveOffset = this.curveOffset),
                  void 0 === t.curvePosition && (t.curvePosition = this.curvePosition),
                  Object(u.f)(this.curveOffset) && (t.curveOffset = t.curveOffset[0]),
                  Object(u.f)(this.curvePosition) && (t.curvePosition = t.curveOffset[0]),
                  (e = [re(n, r, t.curvePosition, t.curveOffset)]);
              }
              return e;
            },
            getPath(t) {
              const e = [];
              return (
                e.push(['M', t[0].x, t[0].y]), e.push(['Q', t[1].x, t[1].y, t[2].x, t[2].y]), e
              );
            },
          },
          'single-edge',
        ),
        Ut.registerEdge(
          'cubic',
          {
            curvePosition: [0.5, 0.5],
            curveOffset: [-20, 20],
            getControlPoints(t) {
              let e = t.controlPoints;
              if (
                (void 0 === t.curveOffset && (t.curveOffset = this.curveOffset),
                void 0 === t.curvePosition && (t.curvePosition = this.curvePosition),
                Object(u.k)(t.curveOffset) && (t.curveOffset = [t.curveOffset, -t.curveOffset]),
                Object(u.k)(t.curvePosition) &&
                  (t.curvePosition = [t.curvePosition, 1 - t.curvePosition]),
                !e || !e.length || e.length < 2)
              ) {
                const n = t.startPoint;
                const r = t.endPoint;
                e = [
                  re(n, r, t.curvePosition[0], t.curveOffset[0]),
                  re(n, r, t.curvePosition[1], t.curveOffset[1]),
                ];
              }
              return e;
            },
            getPath(t) {
              const e = [];
              return (
                e.push(['M', t[0].x, t[0].y]),
                e.push(['C', t[1].x, t[1].y, t[2].x, t[2].y, t[3].x, t[3].y]),
                e
              );
            },
          },
          'single-edge',
        ),
        Ut.registerEdge(
          'cubic-vertical',
          {
            curvePosition: [0.5, 0.5],
            minCurveOffset: [0, 0],
            curveOffset: void 0,
            getControlPoints(t) {
              const e = t.startPoint;
              const n = t.endPoint;
              void 0 === t.curvePosition && (t.curvePosition = this.curvePosition),
                void 0 === t.curveOffset && (t.curveOffset = this.curveOffset),
                void 0 === t.minCurveOffset && (t.minCurveOffset = this.minCurveOffset),
                Object(u.k)(t.curveOffset) && (t.curveOffset = [t.curveOffset, -t.curveOffset]),
                Object(u.k)(t.minCurveOffset) &&
                  (t.minCurveOffset = [t.minCurveOffset, -t.minCurveOffset]),
                Object(u.k)(t.curvePosition) &&
                  (t.curvePosition = [t.curvePosition, 1 - t.curvePosition]);
              const r = n.y - e.y;
              let i = [0, 0];
              return (
                t.curveOffset
                  ? (i = t.curveOffset)
                  : Math.abs(r) < Math.abs(t.minCurveOffset[0]) && (i = t.minCurveOffset),
                [
                  { x: e.x, y: e.y + r * this.curvePosition[0] + i[0] },
                  { x: n.x, y: n.y - r * this.curvePosition[1] + i[1] },
                ]
              );
            },
          },
          'cubic',
        ),
        Ut.registerEdge(
          'cubic-horizontal',
          {
            curvePosition: [0.5, 0.5],
            minCurveOffset: [0, 0],
            curveOffset: void 0,
            getControlPoints(t) {
              const e = t.startPoint;
              const n = t.endPoint;
              void 0 === t.curvePosition && (t.curvePosition = this.curvePosition),
                void 0 === t.curveOffset && (t.curveOffset = this.curveOffset),
                void 0 === t.minCurveOffset && (t.minCurveOffset = this.minCurveOffset),
                Object(u.k)(t.curveOffset) && (t.curveOffset = [t.curveOffset, -t.curveOffset]),
                Object(u.k)(t.minCurveOffset) &&
                  (t.minCurveOffset = [t.minCurveOffset, -t.minCurveOffset]),
                Object(u.k)(t.curvePosition) &&
                  (t.curvePosition = [t.curvePosition, 1 - t.curvePosition]);
              const r = n.x - e.x;
              let i = [0, 0];
              return (
                t.curveOffset
                  ? (i = t.curveOffset)
                  : Math.abs(r) < Math.abs(t.minCurveOffset[0]) && (i = t.minCurveOffset),
                [
                  { x: e.x + r * this.curvePosition[0] + i[0], y: e.y },
                  { x: n.x - r * this.curvePosition[1] + i[1], y: n.y },
                ]
              );
            },
          },
          'cubic',
        ),
        Ut.registerEdge(
          'loop',
          {
            getPathPoints(t) {
              return ft(t);
            },
            getControlPoints(t) {
              return t.controlPoints;
            },
            afterDraw(t) {
              t.controlPoints = void 0;
            },
            afterUpdate(t) {
              t.controlPoints = void 0;
            },
          },
          'cubic',
        );
      const _e = {
        itemType: 'combo',
        shapeType: 'single-combo',
        labelPosition: 'top',
        refX: it.comboLabel.refX,
        refY: it.comboLabel.refY,
        options: {
          style: {
            stroke: it.defaultCombo.style.stroke,
            fill: it.defaultCombo.style.fill,
            lineWidth: it.defaultCombo.style.lineWidth,
          },
          labelCfg: {
            style: { fill: it.comboLabel.style.fill, fontSize: it.comboLabel.style.fontSize },
          },
          stateStyles: Object(f.a)({}, it.comboStateStyles),
        },
        getSize(t) {
          let e = Object(u.a)(t.size || this.options.size || it.defaultCombo.size);
          return (
            Object(u.f)(e) && e.length === 1 && (e = [e[0], e[0]]),
            Object(u.f)(e) || (e = [e, e]),
            e
          );
        },
        getLabelStyleByPosition(t, e) {
          const n = e.position || this.labelPosition;
          const r = t.style;
          let i = t.padding || this.options.padding;
          Object(u.f)(i) && (i = i[0]);
          let o = e.refX;
          let a = e.refY;
          Object(u.j)(o) && (o = this.refX), Object(u.j)(a) && (a = this.refY);
          let s;
          const c = this.getSize(t);
          const h = (Math.max(r.r, c[0] / 2) || c[0] / 2) + i;
          switch (n) {
            case 'top':
              s = { x: 0, y: -h - a, textBaseline: 'bottom', textAlign: 'center' };
              break;
            case 'bottom':
              s = { x: 0, y: h + a, textBaseline: 'bottom', textAlign: 'center' };
              break;
            case 'left':
              s = { x: -h + o, y: 0, textAlign: 'left' };
              break;
            case 'center':
              s = { x: 0, y: 0, text: t.label, textAlign: 'center' };
              break;
            default:
              s = { x: h + o, y: 0, textAlign: 'right' };
          }
          return (s.text = t.label), s;
        },
        drawShape(t, e) {
          const n = this.shapeType;
          const r = this.getShapeStyle(t);
          return e.addShape(n, { attrs: r, draggable: !0, name: 'combo-shape' });
        },
        updateShape(t, e, n) {
          const r = e.get('keyShape');
          (void 0 === t.animate ? this.options.animate : t.animate) && r.animate
            ? r.animate(n, { duration: 200, easing: 'easeLinear' })
            : r.attr(Object(f.a)({}, n)),
            this.updateLabel(t, e);
        },
      };
      const Be = Object(f.a)(Object(f.a)({}, Pe), _e);
      Ut.registerCombo('single-combo', Be),
        Ut.registerCombo(
          'circle',
          {
            options: {
              size: [it.defaultCombo.size[0], it.defaultCombo.size[0]],
              padding: it.defaultCombo.padding[0],
              animate: !0,
              style: {
                stroke: it.defaultCombo.style.stroke,
                fill: it.defaultCombo.style.fill,
                lineWidth: it.defaultCombo.style.lineWidth,
              },
              labelCfg: {
                style: { fill: it.comboLabel.style.fill, fontSize: it.comboLabel.style.fontSize },
                refX: 0,
                refY: 0,
              },
              stateStyles: Object(f.a)({}, it.comboStateStyles),
            },
            shapeType: 'circle',
            labelPosition: 'top',
            drawShape(t, e) {
              const n = this.getShapeStyle(t);
              return (
                delete n.height,
                delete n.width,
                e.addShape('circle', {
                  attrs: n,
                  className: 'circle-combo',
                  name: 'circle-combo',
                  draggable: !0,
                })
              );
            },
            getShapeStyle(t) {
              const e = this.options.style;
              let n = t.padding || this.options.padding;
              Object(u.f)(n) && (n = n[0]);
              let r;
              const i = { stroke: t.color };
              const o = Object(u.r)({}, e, i, t.style);
              if (t.fixSize) r = Object(u.k)(t.fixSize) ? t.fixSize : t.fixSize[0];
              else {
                const a = this.getSize(t);
                r =
                  !Object(u.k)(o.r) || isNaN(o.r)
                    ? a[0] / 2 || it.defaultCombo.style.r
                    : Math.max(o.r, a[0] / 2) || a[0] / 2;
              }
              o.r = r + n;
              const s = Object(f.a)({ x: 0, y: 0 }, o);
              return t.style ? (t.style.r = r) : (t.style = { r }), s;
            },
            update(t, e) {
              const n = this.getSize(t);
              let r = t.padding || this.options.padding;
              Object(u.f)(r) && (r = r[0]);
              let i;
              const o = Object(u.a)(t.style);
              (i = t.fixSize
                ? Object(u.k)(t.fixSize)
                  ? t.fixSize
                  : t.fixSize[0]
                : Math.max(o.r, n[0] / 2) || n[0] / 2),
                (o.r = i + r);
              const a = e.get('sizeCache');
              a && (a.r = o.r);
              const s = { stroke: t.color };
              const c = e.get('keyShape');
              const h = Object(u.r)({}, c.attr(), s, o);
              t.style ? (t.style.r = i) : (t.style = { r: i }), this.updateShape(t, e, h, !0);
            },
          },
          'single-combo',
        ),
        Ut.registerCombo(
          'rect',
          {
            options: {
              size: [40, 5],
              padding: [25, 20, 15, 20],
              animate: !0,
              style: {
                radius: 0,
                stroke: it.defaultCombo.style.stroke,
                fill: it.defaultCombo.style.fill,
                lineWidth: it.defaultCombo.style.lineWidth,
              },
              labelCfg: {
                style: { fill: it.comboLabel.style.fill, fontSize: it.comboLabel.style.fontSize },
              },
              anchorPoints: [
                [0, 0.5],
                [1, 0.5],
              ],
              stateStyles: Object(f.a)({}, it.comboStateStyles),
            },
            shapeType: 'rect',
            labelPosition: 'top',
            drawShape(t, e) {
              const n = this.getShapeStyle(t);
              return e.addShape('rect', {
                attrs: n,
                className: 'rect-combo',
                name: 'rect-combo',
                draggable: !0,
              });
            },
            getLabelStyleByPosition(t, e) {
              const n = e.position || this.labelPosition;
              const r = t.style;
              let i = t.padding || this.options.padding;
              Object(u.k)(i) && (i = [i, i, i, i]);
              let o = e.refX;
              let a = e.refY;
              Object(u.j)(o) && (o = this.refX), Object(u.j)(a) && (a = this.refY);
              let s;
              const c = r.width / 2 + i[3];
              const h = r.height / 2 + i[0];
              switch (n) {
                case 'top':
                  s = { x: 0 - c + o, y: 0 - h + a, textBaseline: 'top', textAlign: 'left' };
                  break;
                case 'bottom':
                  s = { x: 0, y: h + a, textBaseline: 'bottom', textAlign: 'center' };
                  break;
                case 'left':
                  s = { x: 0 - c + a, y: 0, textAlign: 'left' };
                  break;
                case 'center':
                  s = { x: 0, y: 0, text: t.label, textAlign: 'center' };
                  break;
                default:
                  s = { x: c + o, y: 0, textAlign: 'right' };
              }
              return (s.text = t.label), s;
            },
            getShapeStyle(t) {
              const e = this.options.style;
              let n = t.padding || this.options.padding;
              Object(u.k)(n) && (n = [n, n, n, n]);
              let r;
              let i;
              const o = { stroke: t.color };
              const a = Object(u.r)({}, e, o, t.style);
              const s = this.getSize(t);
              const c = t.collapsed && t.fixCollapseSize ? t.fixCollapseSize : t.fixSize;
              c
                ? Object(u.k)(c)
                  ? ((r = c), (i = c))
                  : ((r = c[0]), (i = c[1]))
                : ((r =
                    !Object(u.k)(a.width) || isNaN(a.width)
                      ? s[0] || it.defaultCombo.style.width
                      : Math.max(a.width, s[0]) || s[0]),
                  (i =
                    !Object(u.k)(a.height) || isNaN(a.height)
                      ? s[1] || it.defaultCombo.style.height
                      : Math.max(a.height, s[1]) || s[1]));
              const h = -r / 2 - n[3];
              const l = -i / 2 - n[0];
              (a.width = r + n[1] + n[3]), (a.height = i + n[0] + n[2]);
              const d = Object(f.a)({ x: h, y: l }, a);
              return (
                t.style
                  ? ((t.style.width = r), (t.style.height = i))
                  : (t.style = { width: r, height: i }),
                d
              );
            },
            update(t, e) {
              const n = this.getSize(t);
              let r = t.padding || this.options.padding;
              Object(u.k)(r) && (r = [r, r, r, r]);
              let i;
              let o;
              const a = Object(u.a)(t.style);
              const s = t.collapsed && t.fixCollapseSize ? t.fixCollapseSize : t.fixSize;
              s
                ? Object(u.k)(s)
                  ? ((i = s), (o = s))
                  : ((i = s[0]), (o = s[1]))
                : ((i = Math.max(a.width, n[0]) || n[0]), (o = Math.max(a.height, n[1]) || n[1])),
                (a.width = i + r[1] + r[3]),
                (a.height = o + r[0] + r[2]);
              const c = e.get('sizeCache');
              c && ((c.width = a.width), (c.height = a.height)),
                (a.x = -i / 2 - r[3]),
                (a.y = -o / 2 - r[0]);
              const h = { stroke: t.color };
              const l = e.get('keyShape');
              const f = Object(u.r)({}, l.attr(), h, a);
              t.style
                ? ((t.style.width = i), (t.style.height = o))
                : (t.style = { width: i, height: o }),
                this.updateShape(t, e, f, !1);
            },
            updateShape(t, e, n) {
              const r = e.get('keyShape');
              (void 0 === t.animate ? this.options.animate : t.animate) && r.animate
                ? r.animate(n, { duration: 200, easing: 'easeLinear' })
                : r.attr(Object(f.a)({}, n)),
                this.updateLabel(t, e);
            },
          },
          'single-combo',
        ),
        Ut.registerNode(
          'simple-circle',
          {
            options: {
              size: it.defaultNode.size,
              style: {
                x: 0,
                y: 0,
                stroke: it.defaultNode.style.stroke,
                fill: it.defaultNode.style.fill,
                lineWidth: it.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: it.nodeLabel.style.fill, fontSize: it.nodeLabel.style.fontSize },
              },
              stateStyles: Object(f.a)({}, it.nodeStateStyles),
            },
            shapeType: 'simple-circle',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getShapeStyle(t);
              return e.addShape('circle', {
                attrs: n,
                className: `${this.type}-keyShape`,
                draggable: !0,
              });
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const r = Object(u.b)({}, e, n);
              const i = this.getSize(t)[0] / 2;
              return Object(f.a)({ x: 0, y: 0, r: i }, r);
            },
            update(t, e) {
              const n = this.getSize(t);
              const r = { stroke: t.color, r: n[0] / 2 };
              const i = e.get('keyShape');
              const o = Object(u.b)({}, i.attr(), r, t.style);
              this.updateShape(t, e, o, !0);
            },
          },
          'single-node',
        ),
        Ut.registerNode(
          'simple-rect',
          {
            options: {
              size: [100, 30],
              style: {
                radius: 0,
                stroke: it.defaultNode.style.stroke,
                fill: it.defaultNode.style.fill,
                lineWidth: it.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: it.nodeLabel.style.fill, fontSize: it.nodeLabel.style.fontSize },
              },
              anchorPoints: [
                [0, 0.5],
                [1, 0.5],
              ],
              stateStyles: Object(f.a)({}, it.nodeStateStyles),
            },
            shapeType: 'simple-rect',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getShapeStyle(t);
              return e.addShape('rect', {
                attrs: n,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const r = Object(u.r)({}, e, n);
              const i = this.getSize(t);
              const o = r.width || i[0];
              const a = r.height || i[1];
              return Object(f.a)({ x: -o / 2, y: -a / 2, width: o, height: a }, r);
            },
            update(t, e) {
              e.getContainer();
              const n = this.getOptions({}).style;
              const r = this.getSize(t);
              const i = e.get('keyShape');
              t.size ||
                ((r[0] = i.attr('width') || n.width), (r[1] = i.attr('height') || n.height));
              const o = { stroke: t.color, x: -r[0] / 2, y: -r[1] / 2, width: r[0], height: r[1] };
              let a = Object(u.r)({}, n, i.attr(), o);
              (a = Object(u.r)(a, t.style)), this.updateShape(t, e, a, !1);
            },
          },
          'single-node',
        ),
        Ut.registerNode(
          'image',
          {
            options: {
              img: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ',
              size: 200,
              clipCfg: {
                show: !1,
                type: 'circle',
                r: 50,
                rx: 50,
                ry: 35,
                width: 50,
                height: 35,
                points: [
                  [30, 12],
                  [12, 30],
                  [30, 48],
                  [48, 30],
                ],
                path: [
                  ['M', 25, 25],
                  ['L', 50, 25],
                  ['A', 12.5, 12.5, 0, 1, 1, 50, 50],
                  ['A', 12.5, 12.5, 0, 1, 0, 50, 50],
                  ['L', 25, 75],
                  ['Z'],
                ],
                x: 0,
                y: 0,
              },
            },
            shapeType: 'image',
            labelPosition: 'bottom',
            drawShape(t, e) {
              const n = this.shapeType;
              const r = this.getShapeStyle(t);
              delete r.fill;
              const i = e.addShape(n, {
                attrs: r,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              return this.drawClip(t, i), i;
            },
            drawClip(t, e) {
              const n = this.getOptions(t).clipCfg;
              if (n.show) {
                const r = n.type;
                const i = n.x;
                const o = n.y;
                const a = n.style;
                if (r === 'circle') {
                  const s = n.r;
                  e.setClip({ type: 'circle', attrs: Object(f.a)({ r: s, x: i, y: o }, a) });
                } else if (r === 'rect') {
                  const u = n.width;
                  const c = n.height;
                  const h = i - u / 2;
                  const l = o - c / 2;
                  e.setClip({
                    type: 'rect',
                    attrs: Object(f.a)({ x: h, y: l, width: u, height: c }, a),
                  });
                } else if (r === 'ellipse') {
                  const d = n.rx;
                  const p = n.ry;
                  e.setClip({
                    type: 'ellipse',
                    attrs: Object(f.a)({ x: i, y: o, rx: d, ry: p }, a),
                  });
                } else if (r === 'polygon') {
                  const g = n.points;
                  e.setClip({ type: 'polygon', attrs: Object(f.a)({ points: g }, a) });
                } else if (r === 'path') {
                  const v = n.path;
                  e.setClip({ type: 'path', attrs: Object(f.a)({ path: v }, a) });
                }
              }
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = this.getSize(t);
              const r = this.getOptions(t).img;
              let i = n[0];
              let o = n[1];
              return (
                e && ((i = e.width || n[0]), (o = e.height || n[1])),
                Object(f.a)({ x: -i / 2, y: -o / 2, width: i, height: o, img: r }, e)
              );
            },
            updateShapeStyle(t, e) {
              const n = e.getContainer();
              const r = `${this.itemType}-shape`;
              const i =
                n.find((t) => {
                  return t.get('className') === r;
                }) || e.getKeyShape();
              const o = this.getShapeStyle(t);
              i && i.attr(o);
            },
          },
          'single-node',
        );
      let Le;
      var De = {
        triangle(t, e, n) {
          void 0 === t && (t = 10), void 0 === e && (e = 15), void 0 === n && (n = 0);
          const r = 2 * n;
          return `M ${r},0 L ${r + e},-${t / 2} L ${r + e},${t / 2} Z`;
        },
        vee(t, e, n) {
          void 0 === t && (t = 15), void 0 === e && (e = 20), void 0 === n && (n = 0);
          const r = 2 * n;
          return `M ${r},0 L ${r + e},-${t / 2}\n        L ${r + (2 * e) / 3},0 L ${r + e},${
            t / 2
          } Z`;
        },
        circle(t, e) {
          return (
            void 0 === t && (t = 5),
            void 0 === e && (e = 0),
            `M ${2 * e}, 0\n            a ${t},${t} 0 1,0 ${
              2 * t
            },0\n            a ${t},${t} 0 1,0 ${2 * -t},0`
          );
        },
        rect(t, e, n) {
          void 0 === t && (t = 10), void 0 === e && (e = 10), void 0 === n && (n = 0);
          const r = 2 * n;
          return `M ${r},${-t / 2} \n        L ${r + e},${-t / 2} \n        L ${r + e},${
            t / 2
          } \n        L ${r},${t / 2} Z`;
        },
        diamond(t, e, n) {
          void 0 === t && (t = 15), void 0 === e && (e = 15), void 0 === n && (n = 0);
          const r = 2 * n;
          return `M ${r},0 \n        L ${r + e / 2},${-t / 2} \n        L ${r + e},0 \n        L ${
            r + e / 2
          },${t / 2} Z`;
        },
        triangleRect(t, e, n, r, i, o) {
          void 0 === t && (t = 15),
            void 0 === e && (e = 15),
            void 0 === n && (n = 15),
            void 0 === r && (r = 3),
            void 0 === i && (i = 5),
            void 0 === o && (o = 0);
          const a = 2 * o;
          const s = a + e + i;
          return `M ${a},0 L ${a + e},-${t / 2} L ${a + e},${t / 2} Z\n            M ${s}, -${
            n / 2
          }\n            L ${s + r} -${n / 2}\n            L ${s + r} ${
            n / 2
          }\n            L ${s} ${n / 2}\n            Z`;
        },
      };
      var Re = {
        collapse(t, e, n) {
          return [
            ['M', t - n, e],
            ['a', n, n, 0, 1, 0, 2 * n, 0],
            ['a', n, n, 0, 1, 0, 2 * -n, 0],
            ['M', t - n + 4, e],
            ['L', t + n - 4, e],
          ];
        },
        expand(t, e, n) {
          return [
            ['M', t - n, e],
            ['a', n, n, 0, 1, 0, 2 * n, 0],
            ['a', n, n, 0, 1, 0, 2 * -n, 0],
            ['M', t - n + 4, e],
            ['L', t - n + 2 * n - 4, e],
            ['M', t - n + n, e - n + 4],
            ['L', t, e + n - 4],
          ];
        },
        upTriangle(t, e, n) {
          const r = n * Math.cos(Math.PI / 6);
          const i = n * Math.sin(Math.PI / 6);
          return [['M', t - r, e + i], ['L', t + r, e + i], ['L', t, e - n], ['Z']];
        },
        downTriangle(t, e, n) {
          const r = n * Math.cos(Math.PI / 6);
          const i = n * Math.sin(Math.PI / 6);
          return [['M', t - r, e - i], ['L', t + r, e - i], ['L', t, e + n], ['Z']];
        },
      };
      var Ye = Ut;
      var Fe = [
        '#5F95FF',
        '#61DDAA',
        '#65789B',
        '#F6BD16',
        '#7262FD',
        '#78D3F8',
        '#9661BC',
        '#F6903D',
        '#008685',
        '#F08BB4',
      ];
      const Xe = y.a.transform;
      var ze = Object(f.a)(
        Object(f.a)(Object(f.a)(Object(f.a)(Object(f.a)(Object(f.a)({}, o), i), a), r), s),
        { transform: Xe, mat3: y.b },
      );
      var We = (function () {
        function t(t) {
          (this.graph = t),
            (this.layoutCfg = t.get('layout') || {}),
            (this.layoutType = this.getLayoutType()),
            (this.layoutMethods = []),
            this.initLayout();
        }
        return (
          (t.prototype.initLayout = function () {}),
          (t.prototype.getLayoutType = function () {
            return this.getLayoutCfgType(this.layoutCfg);
          }),
          (t.prototype.getLayoutCfgType = function (t) {
            const e = t.type;
            if (e) return e;
            const n = t.pipes;
            return Array.isArray(n)
              ? n.map((t) => {
                  return (t == null ? void 0 : t.type) || '';
                })
              : null;
          }),
          (t.prototype.isLayoutTypeSame = function (t) {
            const e = this.getLayoutCfgType(t);
            return Array.isArray(this.layoutType)
              ? this.layoutType.every((t, n) => {
                  return t === e[n];
                })
              : (t == null ? void 0 : t.type) === this.layoutType;
          }),
          (t.prototype.refreshLayout = function () {
            const t = this.graph;
            t && (t.get('animate') ? t.positionsAnimate() : t.refreshPositions());
          }),
          (t.prototype.changeLayout = function (t) {
            (this.layoutCfg = t), this.destoryLayoutMethods(), this.layout();
          }),
          (t.prototype.changeData = function () {
            this.destoryLayoutMethods(), this.layout();
          }),
          (t.prototype.destoryLayoutMethods = function () {
            const t = this.layoutMethods;
            t == null ||
              t.forEach((t) => {
                t.destroy();
              }),
              (this.layoutMethods = []);
          }),
          (t.prototype.destroyLayout = function () {
            const t = this.graph;
            this.destoryLayoutMethods(),
              t.set('layout', void 0),
              (this.layoutCfg = void 0),
              (this.layoutType = void 0),
              (this.layoutMethods = void 0);
          }),
          (t.prototype.setDataFromGraph = function () {
            for (
              var t = [],
                e = [],
                n = [],
                r = [],
                i = [],
                o = [],
                a = this.graph.getNodes(),
                s = this.graph.getEdges(),
                u = this.graph.getCombos(),
                c = a.length,
                h = 0;
              h < c;
              h++
            ) {
              const l = a[h];
              if (l && !l.destroyed) {
                var f = l.getModel();
                l.isVisible() ? t.push(f) : e.push(f);
              }
            }
            const d = s.length;
            for (h = 0; h < d; h++) {
              const p = s[h];
              if (p && !p.destroyed) {
                f = p.getModel();
                p.isVisible() ? (f.isComboEdge ? i.push(f) : n.push(f)) : r.push(f);
              }
            }
            const g = u.length;
            for (h = 0; h < g; h++) {
              const v = u[h];
              if (!v.destroyed) {
                f = v.getModel();
                v.isVisible() ? o.push(f) : r.push(f);
              }
            }
            return {
              nodes: t,
              hiddenNodes: e,
              edges: n,
              hiddenEdges: r,
              combos: o,
              hiddenCombos: [],
              comboEdges: i,
            };
          }),
          (t.prototype.reLayoutMethod = function (t, e) {
            const n = this;
            return new Promise((r, i) => {
              const o = n.graph;
              const a = e == null ? void 0 : e.type;
              (e.onLayoutEnd = function () {
                o.emit('aftersublayout', { type: a }), r();
              }),
                t.init(n.data),
                a === 'force' && ((t.ticking = !1), t.forceSimulation.stop()),
                o.emit('beforesublayout', { type: a }),
                t.execute(),
                t.isCustomLayout && e.onLayoutEnd && e.onLayoutEnd();
            });
          }),
          (t.prototype.relayout = function (t) {
            const e = this;
            const n = this.graph;
            const r = this.layoutMethods;
            const i = this.layoutCfg;
            if (t) {
              this.data = this.setDataFromGraph();
              const o = this.data.nodes;
              if (!o) return !1;
              this.initPositions(i.center, o);
            }
            n.emit('beforelayout');
            let a = Promise.resolve();
            r == null ||
              r.forEach((t, n) => {
                const r = i[n];
                a = a.then(() => {
                  return e.reLayoutMethod(t, r);
                });
              }),
              a
                .then(() => {
                  i.onAllLayoutEnd && i.onAllLayoutEnd();
                })
                .catch((t) => {
                  console.warn('relayout failed', t);
                });
          }),
          (t.prototype.filterLayoutData = function (t, e) {
            let n;
            let r;
            const i = t.nodes;
            const o = t.edges;
            const a = Object(f.e)(t, ['nodes', 'edges']);
            if (!i) return t;
            if (
              ((n = Object(u.i)(e == null ? void 0 : e.nodesFilter)
                ? e.nodesFilter
                : function () {
                    return !0;
                  }),
              Object(u.i)(e == null ? void 0 : e.edgesFilter))
            )
              r = e.edgesFilter;
            else {
              const s = i.reduce((t, e) => {
                return (t[e.id] = !0), t;
              }, {});
              r = function (t) {
                return s[t.source] && s[t.target];
              };
            }
            return Object(f.a)({ nodes: i.filter(n), edges: o.filter(r) }, a);
          }),
          (t.prototype.getLayoutBBox = function (t) {
            const e = this.graph;
            const n = Object(u.e)(e.getNodes(), (t) => {
              return t.getModel().layoutOrder;
            });
            const r = Object.values(n).map((t) => {
              const e = Nt(t);
              return (e.size = [e.width, e.height]), e;
            });
            return { groupNodes: Object.values(Object(u.e)(t, 'layoutOrder')), layoutNodes: r };
          }),
          (t.prototype.layoutAnimate = function () {}),
          (t.prototype.moveToZero = function () {
            const t = this.graph.get('data').nodes;
            if (void 0 !== t[0].x && t[0].x !== null && !jt(t[0].x)) {
              for (var e = [0, 0], n = t.length, r = 0; r < n; r++) {
                var i = t[r];
                (e[0] += i.x), (e[1] += i.y);
              }
              (e[0] /= t.length), (e[1] /= t.length);
              for (r = 0; r < n; r++) {
                ((i = t[r]).x -= e[0]), (i.y -= e[1]);
              }
            }
          }),
          (t.prototype.initPositions = function (t, e) {
            const n = this.graph;
            if (!e) return !1;
            const r = e ? e.length : 0;
            if (r) {
              const i = 0.85 * n.get('width');
              const o = 0.85 * n.get('height');
              const a = Math.ceil(Math.sqrt(r) * (i / o));
              let s = i / (a - 1);
              let u = o / (Math.ceil(r / a) - 1);
              (isFinite(s) && s) || (s = 0), (isFinite(u) && s) || (u = 0);
              for (var c = t[0] - i / 2, h = t[1] - o / 2, l = !0, f = 0; f < r; f++) {
                const d = e[f];
                jt(d.x) && ((l = !1), (d.x = (f % a) * s + c)),
                  jt(d.y) && ((l = !1), (d.y = Math.floor(f / a) * u + h));
              }
              return l;
            }
          }),
          (t.prototype.destroy = function () {
            (this.graph = null), this.destoryLayoutMethods(), (this.destroyed = !0);
          }),
          (t.prototype.onTick = function (t) {
            let e;
            (e = this.layoutMethods) === null ||
              void 0 === e ||
              e.forEach((e) => {
                e == null || e.onTick(t);
              });
          }),
          t
        );
      })();
      var Ge = function (t) {
        (this.graph = t), (this.destroyed = !1), this.initEvents();
      };
      !(function (t) {
        (t.CLICK = 'click'),
          (t.DBLCLICK = 'dblclick'),
          (t.TAP = 'tap'),
          (t.DBLTAP = 'dbltap'),
          (t.DRAGSTART = 'dragstart'),
          (t.DRAGEND = 'dragend'),
          (t.DRAG = 'drag'),
          (t.DRAGENTER = 'dragenter'),
          (t.DRAGLEAVE = 'dragleave'),
          (t.DRAGOVER = 'dragover'),
          (t.DRAGOUT = 'dragout'),
          (t.DDROP = 'drop'),
          (t.PINCHSTART = 'pinchstart'),
          (t.PINCHMOVE = 'pinchmove'),
          (t.PANSTART = 'panstart'),
          (t.PANMOVE = 'panmove'),
          (t.PANEND = 'panend'),
          (t.PRESS = 'press'),
          (t.ACTION_END = 'actionend'),
          (t.TOUCHSTART = 'touchstart'),
          (t.TOUCHMOVE = 'touchmove'),
          (t.TOUCHEND = 'touchend'),
          (t.CANVAS_TOUCHSTART = 'canvas:touchstart'),
          (t.CANVAS_TOUCHMOVE = 'canvas:touchmove'),
          (t.CANVAS_TOUCHEND = 'canvas:touchend'),
          (t.NODE_TOUCHSTART = 'node:touchstart'),
          (t.NODE_TOUCHMOVE = 'node:touchmove'),
          (t.NODE_TOUCHEND = 'node:touchend'),
          (t.COMBO_TOUCHSTART = 'combo:touchstart'),
          (t.COMBO_TOUCHMOVE = 'combo:touchmove'),
          (t.COMBO_TOUCHEND = 'combo:touchend'),
          (t.EDGE_TOUCHSTART = 'edge:touchstart'),
          (t.EDGE_TOUCHMOVE = 'edge:touchmove'),
          (t.EDGE_TOUCHEND = 'edge:touchend'),
          (t.NODE_CLICK = 'node:click'),
          (t.NODE_DBLCLICK = 'node:dblclick'),
          (t.NODE_DROP = 'node:drop'),
          (t.NODE_DRAGOVER = 'node:dragover'),
          (t.NODE_DRAGENTER = 'node:dragenter'),
          (t.NODE_DRAGLEAVE = 'node:dragleave'),
          (t.NODE_DRAGSTART = 'node:dragstart'),
          (t.NODE_DRAG = 'node:drag'),
          (t.NODE_DRAGEND = 'node:dragend'),
          (t.NODE_TAP = 'node:tap'),
          (t.NODE_DBLTAP = 'node:dbltap'),
          (t.NODE_PANSTART = 'node:panstart'),
          (t.NODE_PANMOVE = 'node:panmove'),
          (t.NODE_PANEND = 'node:panend'),
          (t.NODE_PRESS = 'node:press'),
          (t.COMBO_CLICK = 'combo:click'),
          (t.COMBO_DBLCLICK = 'combo:dblclick'),
          (t.COMBO_DROP = 'combo:drop'),
          (t.COMBO_DRAGOVER = 'combo:dragover'),
          (t.COMBO_DRAGENTER = 'combo:dragenter'),
          (t.COMBO_DRAGLEAVE = 'combo:dragleave'),
          (t.COMBO_DRAGSTART = 'combo:dragstart'),
          (t.COMBO_DRAG = 'combo:drag'),
          (t.COMBO_DRAGEND = 'combo:dragend'),
          (t.COMBO_TAP = 'combo:tap'),
          (t.COMBO_DBLTAP = 'combo:dbltap'),
          (t.COMBO_PANSTART = 'combo:panstart'),
          (t.COMBO_PANMOVE = 'combo:panmove'),
          (t.COMBO_PANEND = 'combo:panend'),
          (t.COMBO_PRESS = 'combo:press'),
          (t.EDGE_CLICK = 'edge:click'),
          (t.EDGE_DBLCLICK = 'edge:dblclick'),
          (t.EDGE_DROP = 'edge:drop'),
          (t.EDGE_DRAGOVER = 'edge:dragover'),
          (t.EDGE_DRAGENTER = 'edge:dragenter'),
          (t.EDGE_DRAGLEAVE = 'edge:dragleave'),
          (t.EDGE_TAP = 'edge:tap'),
          (t.EDGE_DBLTAP = 'edge:dbltap'),
          (t.EDGE_PRESS = 'edge:press'),
          (t.CANVAS_CLICK = 'canvas:click'),
          (t.CANVAS_DBLCLICK = 'canvas:dblclick'),
          (t.CANVAS_DROP = 'canvas:drop'),
          (t.CANVAS_DRAGENTER = 'canvas:dragenter'),
          (t.CANVAS_DRAGLEAVE = 'canvas:dragleave'),
          (t.CANVAS_DRAGSTART = 'canvas:dragstart'),
          (t.CANVAS_DRAG = 'canvas:drag'),
          (t.CANVAS_DRAGEND = 'canvas:dragend'),
          (t.CANVAS_TAP = 'canvas:tap'),
          (t.CANVAS_DBLTAP = 'canvas:dbltap'),
          (t.CANVAS_PANSTART = 'canvas:panstart'),
          (t.CANVAS_PANMOVE = 'canvas:panmove'),
          (t.CANVAS_PANEND = 'canvas:panend'),
          (t.CANVAS_PRESS = 'canvas:press'),
          (t.BEFORERENDER = 'beforerender'),
          (t.AFTERRENDER = 'afterrender'),
          (t.BEFOREADDITEM = 'beforeadditem'),
          (t.AFTERADDITEM = 'afteradditem'),
          (t.BEFOREREMOVEITEM = 'beforeremoveitem'),
          (t.AFTERREMOVEITEM = 'afterremoveitem'),
          (t.BEFOREUPDATEITEM = 'beforeupdateitem'),
          (t.AFTERUPDATEITEM = 'afterupdateitem'),
          (t.BEFOREITEMVISIBILITYCHANGE = 'beforeitemvisibilitychange'),
          (t.AFTERITEMVISIBILITYCHANGE = 'afteritemvisibilitychange'),
          (t.BEFOREITEMSTATECHANGE = 'beforeitemstatechange'),
          (t.AFTERITEMSTATECHANGE = 'afteritemstatechange'),
          (t.BEFOREITEMREFRESH = 'beforeitemrefresh'),
          (t.AFTERITEMREFRESH = 'afteritemrefresh'),
          (t.BEFOREITEMSTATESCLEAR = 'beforeitemstatesclear'),
          (t.AFTERITEMSTATESCLEAR = 'afteritemstatesclear'),
          (t.BEFOREMODECHANGE = 'beforemodechange'),
          (t.AFTERMODECHANGE = 'aftermodechange'),
          (t.BEFORELAYOUT = 'beforelayout'),
          (t.AFTERLAYOUT = 'afterlayout'),
          (t.BEFORECREATEEDGE = 'beforecreateedge'),
          (t.AFTERCREATEEDGE = 'aftercreateedge'),
          (t.BEFOREGRAPHREFRESHPOSITION = 'beforegraphrefreshposition'),
          (t.AFTERGRAPHREFRESHPOSITION = 'aftergraphrefreshposition'),
          (t.BEFOREGRAPHREFRESH = 'beforegraphrefresh'),
          (t.AFTERGRAPHREFRESH = 'aftergraphrefresh'),
          (t.BEFOREANIMATE = 'beforeanimate'),
          (t.AFTERANIMATE = 'afteranimate'),
          (t.BEFOREPAINT = 'beforepaint'),
          (t.AFTERPAINT = 'afterpaint'),
          (t.BEFORECOLLAPSEEXPANDCOMBO = 'beforecollapseexpandcombo'),
          (t.AFTERCOLLAPSEEXPANDCOMBO = 'aftercollapseexpandcombo'),
          (t.GRAPHSTATECHANGE = 'graphstatechange'),
          (t.AFTERACTIVATERELATIONS = 'afteractivaterelations'),
          (t.NODESELECTCHANGE = 'nodeselectchange'),
          (t.TOOLTIPCHANGE = 'tooltipchange'),
          (t.WHEELZOOM = 'wheelzoom'),
          (t.VIEWPORTCHANGE = 'viewportchange'),
          (t.DRAGNODEEND = 'dragnodeend'),
          (t.STACKCHANGE = 'stackchange');
      })(Le || (Le = {}));
      var Ue = Ye.registerNode;
      var He = Ye.registerEdge;
      var qe = Ye.registerCombo;
      var Ve = l.registerBehavior;
      var Ze = it;
      Ye.registerNode, Ye.registerEdge, Ye.registerCombo, l.registerBehavior;
    },
    function (t, e, n) {
      'use strict';
      n.r(e),
        n.d(e, 'contains', () => {
          return i;
        }),
        n.d(e, 'includes', () => {
          return i;
        }),
        n.d(e, 'difference', () => {
          return a;
        }),
        n.d(e, 'find', () => {
          return x;
        }),
        n.d(e, 'findIndex', () => {
          return M;
        }),
        n.d(e, 'firstValue', () => {
          return S;
        }),
        n.d(e, 'flatten', () => {
          return w;
        }),
        n.d(e, 'flattenDeep', () => {
          return O;
        }),
        n.d(e, 'getRange', () => {
          return k;
        }),
        n.d(e, 'pull', () => {
          return A;
        }),
        n.d(e, 'pullAt', () => {
          return N;
        }),
        n.d(e, 'reduce', () => {
          return _;
        }),
        n.d(e, 'remove', () => {
          return B;
        }),
        n.d(e, 'sortBy', () => {
          return D;
        }),
        n.d(e, 'union', () => {
          return Y;
        }),
        n.d(e, 'uniq', () => {
          return R;
        }),
        n.d(e, 'valuesOfKey', () => {
          return F;
        }),
        n.d(e, 'head', () => {
          return X;
        }),
        n.d(e, 'last', () => {
          return z;
        }),
        n.d(e, 'startsWith', () => {
          return W;
        }),
        n.d(e, 'endsWith', () => {
          return G;
        }),
        n.d(e, 'filter', () => {
          return o;
        }),
        n.d(e, 'every', () => {
          return U;
        }),
        n.d(e, 'some', () => {
          return H;
        }),
        n.d(e, 'group', () => {
          return K;
        }),
        n.d(e, 'groupBy', () => {
          return V;
        }),
        n.d(e, 'groupToMap', () => {
          return Z;
        }),
        n.d(e, 'getWrapBehavior', () => {
          return $;
        }),
        n.d(e, 'wrapBehavior', () => {
          return Q;
        }),
        n.d(e, 'number2color', () => {
          return tt;
        }),
        n.d(e, 'parseRadius', () => {
          return et;
        }),
        n.d(e, 'clamp', () => {
          return nt;
        }),
        n.d(e, 'fixedBase', () => {
          return rt;
        }),
        n.d(e, 'isDecimal', () => {
          return ot;
        }),
        n.d(e, 'isEven', () => {
          return at;
        }),
        n.d(e, 'isInteger', () => {
          return st;
        }),
        n.d(e, 'isNegative', () => {
          return ut;
        }),
        n.d(e, 'isNumberEqual', () => {
          return ct;
        }),
        n.d(e, 'isOdd', () => {
          return ht;
        }),
        n.d(e, 'isPositive', () => {
          return lt;
        }),
        n.d(e, 'max', () => {
          return C;
        }),
        n.d(e, 'maxBy', () => {
          return ft;
        }),
        n.d(e, 'min', () => {
          return E;
        }),
        n.d(e, 'minBy', () => {
          return dt;
        }),
        n.d(e, 'mod', () => {
          return pt;
        }),
        n.d(e, 'toDegree', () => {
          return vt;
        }),
        n.d(e, 'toInteger', () => {
          return yt;
        }),
        n.d(e, 'toRadian', () => {
          return bt;
        }),
        n.d(e, 'forIn', () => {
          return xt;
        }),
        n.d(e, 'has', () => {
          return Mt;
        }),
        n.d(e, 'hasKey', () => {
          return St;
        }),
        n.d(e, 'hasValue', () => {
          return Ot;
        }),
        n.d(e, 'keys', () => {
          return g;
        }),
        n.d(e, 'isMatch', () => {
          return v;
        }),
        n.d(e, 'values', () => {
          return wt;
        }),
        n.d(e, 'lowerCase', () => {
          return Et;
        }),
        n.d(e, 'lowerFirst', () => {
          return kt;
        }),
        n.d(e, 'substitute', () => {
          return Tt;
        }),
        n.d(e, 'upperCase', () => {
          return Pt;
        }),
        n.d(e, 'upperFirst', () => {
          return It;
        }),
        n.d(e, 'getType', () => {
          return jt;
        }),
        n.d(e, 'isArguments', () => {
          return Nt;
        }),
        n.d(e, 'isArray', () => {
          return l;
        }),
        n.d(e, 'isArrayLike', () => {
          return r;
        }),
        n.d(e, 'isBoolean', () => {
          return _t;
        }),
        n.d(e, 'isDate', () => {
          return Bt;
        }),
        n.d(e, 'isError', () => {
          return Lt;
        }),
        n.d(e, 'isFunction', () => {
          return c;
        }),
        n.d(e, 'isFinite', () => {
          return Dt;
        }),
        n.d(e, 'isNil', () => {
          return h;
        }),
        n.d(e, 'isNull', () => {
          return Rt;
        }),
        n.d(e, 'isNumber', () => {
          return it;
        }),
        n.d(e, 'isObject', () => {
          return d;
        }),
        n.d(e, 'isObjectLike', () => {
          return m;
        }),
        n.d(e, 'isPlainObject', () => {
          return b;
        }),
        n.d(e, 'isPrototype', () => {
          return Ft;
        }),
        n.d(e, 'isRegExp', () => {
          return Xt;
        }),
        n.d(e, 'isString', () => {
          return L;
        }),
        n.d(e, 'isType', () => {
          return u;
        }),
        n.d(e, 'isUndefined', () => {
          return zt;
        }),
        n.d(e, 'isElement', () => {
          return Wt;
        }),
        n.d(e, 'requestAnimationFrame', () => {
          return Gt;
        }),
        n.d(e, 'clearAnimationFrame', () => {
          return Ut;
        }),
        n.d(e, 'augment', () => {
          return Vt;
        }),
        n.d(e, 'clone', () => {
          return Kt;
        }),
        n.d(e, 'debounce', () => {
          return $t;
        }),
        n.d(e, 'memoize', () => {
          return Qt;
        }),
        n.d(e, 'deepMix', () => {
          return te;
        }),
        n.d(e, 'each', () => {
          return p;
        }),
        n.d(e, 'extend', () => {
          return ee;
        }),
        n.d(e, 'indexOf', () => {
          return ne;
        }),
        n.d(e, 'isEmpty', () => {
          return ie;
        }),
        n.d(e, 'isEqual', () => {
          return oe;
        }),
        n.d(e, 'isEqualWith', () => {
          return ae;
        }),
        n.d(e, 'map', () => {
          return se;
        }),
        n.d(e, 'mapValues', () => {
          return ce;
        }),
        n.d(e, 'mix', () => {
          return qt;
        }),
        n.d(e, 'assign', () => {
          return qt;
        }),
        n.d(e, 'get', () => {
          return he;
        }),
        n.d(e, 'set', () => {
          return le;
        }),
        n.d(e, 'pick', () => {
          return de;
        }),
        n.d(e, 'omit', () => {
          return pe;
        }),
        n.d(e, 'throttle', () => {
          return ge;
        }),
        n.d(e, 'toArray', () => {
          return ve;
        }),
        n.d(e, 'toString', () => {
          return Ct;
        }),
        n.d(e, 'uniqueId', () => {
          return me;
        }),
        n.d(e, 'noop', () => {
          return be;
        }),
        n.d(e, 'identity', () => {
          return xe;
        }),
        n.d(e, 'size', () => {
          return Me;
        }),
        n.d(e, 'Cache', () => {
          return Se;
        });
      var r = function (t) {
        return t !== null && typeof t !== 'function' && isFinite(t.length);
      };
      var i = function (t, e) {
        return !!r(t) && t.indexOf(e) > -1;
      };
      var o = function (t, e) {
        if (!r(t)) return t;
        for (var n = [], i = 0; i < t.length; i++) {
          const o = t[i];
          e(o, i) && n.push(o);
        }
        return n;
      };
      var a = function (t, e) {
        return (
          void 0 === e && (e = []),
          o(t, (t) => {
            return !i(e, t);
          })
        );
      };
      const s = {}.toString;
      var u = function (t, e) {
        return s.call(t) === `[object ${e}]`;
      };
      var c = function (t) {
        return u(t, 'Function');
      };
      var h = function (t) {
        return t == null;
      };
      var l = function (t) {
        return Array.isArray ? Array.isArray(t) : u(t, 'Array');
      };
      function f(t) {
        return (f =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var d = function (t) {
        const e = f(t);
        return (t !== null && e === 'object') || e === 'function';
      };
      var p = function (t, e) {
        if (t)
          if (l(t)) for (let n = 0, r = t.length; n < r && !1 !== e(t[n], n); n++);
          else if (d(t)) for (const i in t) if (t.hasOwnProperty(i) && !1 === e(t[i], i)) break;
      };
      var g = Object.keys
        ? function (t) {
            return Object.keys(t);
          }
        : function (t) {
            const e = [];
            return (
              p(t, (n, r) => {
                (c(t) && r === 'prototype') || e.push(r);
              }),
              e
            );
          };
      var v = function (t, e) {
        const n = g(e);
        const r = n.length;
        if (h(t)) return !r;
        for (let i = 0; i < r; i += 1) {
          const o = n[i];
          if (e[o] !== t[o] || !(o in t)) return !1;
        }
        return !0;
      };
      function y(t) {
        return (y =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var m = function (t) {
        return y(t) === 'object' && t !== null;
      };
      var b = function (t) {
        if (!m(t) || !u(t, 'Object')) return !1;
        if (Object.getPrototypeOf(t) === null) return !0;
        for (var e = t; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
        return Object.getPrototypeOf(t) === e;
      };
      var x = function (t, e) {
        if (!l(t)) return null;
        let n;
        if (
          (c(e) && (n = e),
          b(e) &&
            (n = function (t) {
              return v(t, e);
            }),
          n)
        )
          for (let r = 0; r < t.length; r += 1) if (n(t[r])) return t[r];
        return null;
      };
      var M = function (t, e, n) {
        void 0 === n && (n = 0);
        for (let r = n; r < t.length; r++) if (e(t[r], r)) return r;
        return -1;
      };
      var S = function (t, e) {
        for (var n = null, r = 0; r < t.length; r++) {
          const i = t[r][e];
          if (!h(i)) {
            n = l(i) ? i[0] : i;
            break;
          }
        }
        return n;
      };
      var w = function (t) {
        if (!l(t)) return [];
        for (var e = [], n = 0; n < t.length; n++) e = e.concat(t[n]);
        return e;
      };
      var O = function t(e, n) {
        if ((void 0 === n && (n = []), l(e))) for (let r = 0; r < e.length; r += 1) t(e[r], n);
        else n.push(e);
        return n;
      };
      var C = function (t) {
        if (l(t))
          return t.reduce((t, e) => {
            return Math.max(t, e);
          }, t[0]);
      };
      var E = function (t) {
        if (l(t))
          return t.reduce((t, e) => {
            return Math.min(t, e);
          }, t[0]);
      };
      var k = function (t) {
        let e = t.filter((t) => {
          return !isNaN(t);
        });
        if (!e.length) return { min: 0, max: 0 };
        if (l(t[0])) {
          for (var n = [], r = 0; r < t.length; r++) n = n.concat(t[r]);
          e = n;
        }
        const i = C(e);
        return { min: E(e), max: i };
      };
      const T = Array.prototype;
      const P = T.splice;
      const I = T.indexOf;
      var A = function (t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        for (let r = 0; r < e.length; r++)
          for (let i = e[r], o = -1; (o = I.call(t, i)) > -1; ) P.call(t, o, 1);
        return t;
      };
      const j = Array.prototype.splice;
      var N = function (t, e) {
        if (!r(t)) return [];
        for (let n = t ? e.length : 0, i = n - 1; n--; ) {
          let o = void 0;
          const a = e[n];
          (n !== i && a === o) || ((o = a), j.call(t, a, 1));
        }
        return t;
      };
      var _ = function (t, e, n) {
        if (!l(t) && !b(t)) return t;
        let r = n;
        return (
          p(t, (t, n) => {
            r = e(r, t, n);
          }),
          r
        );
      };
      var B = function (t, e) {
        const n = [];
        if (!r(t)) return n;
        for (var i = -1, o = [], a = t.length; ++i < a; ) {
          const s = t[i];
          e(s, i, t) && (n.push(s), o.push(i));
        }
        return N(t, o), n;
      };
      var L = function (t) {
        return u(t, 'String');
      };
      var D = function (t, e) {
        let n;
        if (c(e))
          n = function (t, n) {
            return e(t) - e(n);
          };
        else {
          let r = [];
          L(e) ? r.push(e) : l(e) && (r = e),
            (n = function (t, e) {
              for (let n = 0; n < r.length; n += 1) {
                const i = r[n];
                if (t[i] > e[i]) return 1;
                if (t[i] < e[i]) return -1;
              }
              return 0;
            });
        }
        return t.sort(n), t;
      };
      function R(t, e) {
        void 0 === e && (e = new Map());
        const n = [];
        if (Array.isArray(t))
          for (let r = 0, i = t.length; r < i; r++) {
            const o = t[r];
            e.has(o) || (n.push(o), e.set(o, !0));
          }
        return n;
      }
      var Y = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return R([].concat.apply([], t));
      };
      var F = function (t, e) {
        for (var n = [], r = {}, i = 0; i < t.length; i++) {
          let o = t[i][e];
          if (!h(o)) {
            l(o) || (o = [o]);
            for (let a = 0; a < o.length; a++) {
              const s = o[a];
              r[s] || (n.push(s), (r[s] = !0));
            }
          }
        }
        return n;
      };
      function X(t) {
        if (r(t)) return t[0];
      }
      function z(t) {
        if (r(t)) {
          return t[t.length - 1];
        }
      }
      var W = function (t, e) {
        return !(!l(t) && !L(t)) && t[0] === e;
      };
      var G = function (t, e) {
        return !(!l(t) && !L(t)) && t[t.length - 1] === e;
      };
      var U = function (t, e) {
        for (let n = 0; n < t.length; n++) if (!e(t[n], n)) return !1;
        return !0;
      };
      var H = function (t, e) {
        for (let n = 0; n < t.length; n++) if (e(t[n], n)) return !0;
        return !1;
      };
      const q = Object.prototype.hasOwnProperty;
      var V = function (t, e) {
        if (!e || !l(t)) return {};
        for (
          var n,
            r = {},
            i = c(e)
              ? e
              : function (t) {
                  return t[e];
                },
            o = 0;
          o < t.length;
          o++
        ) {
          const a = t[o];
          (n = i(a)), q.call(r, n) ? r[n].push(a) : (r[n] = [a]);
        }
        return r;
      };
      function Z(t, e) {
        if (!e) return { 0: t };
        if (!c(e)) {
          const n = l(e) ? e : e.replace(/\s+/g, '').split('*');
          e = function (t) {
            for (var e = '_', r = 0, i = n.length; r < i; r++) e += t[n[r]] && t[n[r]].toString();
            return e;
          };
        }
        return V(t, e);
      }
      var K = function (t, e) {
        if (!e) return [t];
        const n = Z(t, e);
        const r = [];
        for (const i in n) r.push(n[i]);
        return r;
      };
      var $ = function (t, e) {
        return t[`_wrap_${e}`];
      };
      var Q = function (t, e) {
        if (t[`_wrap_${e}`]) return t[`_wrap_${e}`];
        const n = function (n) {
          t[e](n);
        };
        return (t[`_wrap_${e}`] = n), n;
      };
      const J = {};
      var tt = function (t) {
        let e = J[t];
        if (!e) {
          for (var n = t.toString(16), r = n.length; r < 6; r++) n = `0${n}`;
          (e = `#${n}`), (J[t] = e);
        }
        return e;
      };
      var et = function (t) {
        let e = 0;
        let n = 0;
        let r = 0;
        let i = 0;
        return (
          l(t)
            ? t.length === 1
              ? (e = n = r = i = t[0])
              : t.length === 2
              ? ((e = r = t[0]), (n = i = t[1]))
              : t.length === 3
              ? ((e = t[0]), (n = i = t[1]), (r = t[2]))
              : ((e = t[0]), (n = t[1]), (r = t[2]), (i = t[3]))
            : (e = n = r = i = t),
          { r1: e, r2: n, r3: r, r4: i }
        );
      };
      var nt = function (t, e, n) {
        return t < e ? e : t > n ? n : t;
      };
      var rt = function (t, e) {
        const n = e.toString();
        const r = n.indexOf('.');
        if (r === -1) return Math.round(t);
        let i = n.substr(r + 1).length;
        return i > 20 && (i = 20), parseFloat(t.toFixed(i));
      };
      var it = function (t) {
        return u(t, 'Number');
      };
      var ot = function (t) {
        return it(t) && t % 1 != 0;
      };
      var at = function (t) {
        return it(t) && t % 2 == 0;
      };
      var st = Number.isInteger
        ? Number.isInteger
        : function (t) {
            return it(t) && t % 1 == 0;
          };
      var ut = function (t) {
        return it(t) && t < 0;
      };
      function ct(t, e, n) {
        return void 0 === n && (n = 1e-5), Math.abs(t - e) < n;
      }
      var ht = function (t) {
        return it(t) && t % 2 != 0;
      };
      var lt = function (t) {
        return it(t) && t > 0;
      };
      var ft = function (t, e) {
        if (l(t)) {
          for (var n, r = -1 / 0, i = 0; i < t.length; i++) {
            const o = t[i];
            const a = c(e) ? e(o) : o[e];
            a > r && ((n = o), (r = a));
          }
          return n;
        }
      };
      var dt = function (t, e) {
        if (l(t)) {
          for (var n, r = 1 / 0, i = 0; i < t.length; i++) {
            const o = t[i];
            const a = c(e) ? e(o) : o[e];
            a < r && ((n = o), (r = a));
          }
          return n;
        }
      };
      var pt = function (t, e) {
        return ((t % e) + e) % e;
      };
      const gt = 180 / Math.PI;
      var vt = function (t) {
        return gt * t;
      };
      var yt = parseInt;
      const mt = Math.PI / 180;
      var bt = function (t) {
        return mt * t;
      };
      var xt = p;
      var Mt = function (t, e) {
        return t.hasOwnProperty(e);
      };
      var St = Mt;
      var wt = Object.values
        ? function (t) {
            return Object.values(t);
          }
        : function (t) {
            const e = [];
            return (
              p(t, (n, r) => {
                (c(t) && r === 'prototype') || e.push(n);
              }),
              e
            );
          };
      var Ot = function (t, e) {
        return i(wt(t), e);
      };
      var Ct = function (t) {
        return h(t) ? '' : t.toString();
      };
      var Et = function (t) {
        return Ct(t).toLowerCase();
      };
      var kt = function (t) {
        const e = Ct(t);
        return e.charAt(0).toLowerCase() + e.substring(1);
      };
      var Tt = function (t, e) {
        return t && e
          ? t.replace(/\\?\{([^{}]+)\}/g, (t, n) => {
              return t.charAt(0) === '\\' ? t.slice(1) : void 0 === e[n] ? '' : e[n];
            })
          : t;
      };
      var Pt = function (t) {
        return Ct(t).toUpperCase();
      };
      var It = function (t) {
        const e = Ct(t);
        return e.charAt(0).toUpperCase() + e.substring(1);
      };
      const At = {}.toString;
      var jt = function (t) {
        return At.call(t)
          .replace(/^\[object /, '')
          .replace(/]$/, '');
      };
      var Nt = function (t) {
        return u(t, 'Arguments');
      };
      var _t = function (t) {
        return u(t, 'Boolean');
      };
      var Bt = function (t) {
        return u(t, 'Date');
      };
      var Lt = function (t) {
        return u(t, 'Error');
      };
      var Dt = function (t) {
        return it(t) && isFinite(t);
      };
      var Rt = function (t) {
        return t === null;
      };
      const Yt = Object.prototype;
      var Ft = function (t) {
        const e = t && t.constructor;
        return t === ((typeof e === 'function' && e.prototype) || Yt);
      };
      var Xt = function (t) {
        return u(t, 'RegExp');
      };
      var zt = function (t) {
        return void 0 === t;
      };
      var Wt = function (t) {
        return t instanceof Element || t instanceof HTMLDocument;
      };
      function Gt(t) {
        return (
          window.requestAnimationFrame ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame ||
          window.msRequestAnimationFrame ||
          function (t) {
            return setTimeout(t, 16);
          }
        )(t);
      }
      function Ut(t) {
        (
          window.cancelAnimationFrame ||
          window.webkitCancelAnimationFrame ||
          window.mozCancelAnimationFrame ||
          window.msCancelAnimationFrame ||
          clearTimeout
        )(t);
      }
      function Ht(t, e) {
        for (const n in e)
          e.hasOwnProperty(n) && n !== 'constructor' && void 0 !== e[n] && (t[n] = e[n]);
      }
      function qt(t, e, n, r) {
        return e && Ht(t, e), n && Ht(t, n), r && Ht(t, r), t;
      }
      var Vt = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        for (let n = t[0], r = 1; r < t.length; r++) {
          let i = t[r];
          c(i) && (i = i.prototype), qt(n.prototype, i);
        }
      };
      function Zt(t) {
        return (Zt =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var Kt = function t(e) {
        if (Zt(e) !== 'object' || e === null) return e;
        let n;
        if (l(e)) {
          n = [];
          for (let r = 0, i = e.length; r < i; r++)
            Zt(e[r]) === 'object' && e[r] != null ? (n[r] = t(e[r])) : (n[r] = e[r]);
        } else
          for (const o in ((n = {}), e))
            Zt(e[o]) === 'object' && e[o] != null ? (n[o] = t(e[o])) : (n[o] = e[o]);
        return n;
      };
      var $t = function (t, e, n) {
        let r;
        return function () {
          const i = this;
          const o = arguments;
          const a = function () {
            (r = null), n || t.apply(i, o);
          };
          const s = n && !r;
          clearTimeout(r), (r = setTimeout(a, e)), s && t.apply(i, o);
        };
      };
      var Qt = function (t, e) {
        if (!c(t)) throw new TypeError('Expected a function');
        const n = function n() {
          for (var r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
          const o = e ? e.apply(this, r) : r[0];
          const a = n.cache;
          if (a.has(o)) return a.get(o);
          const s = t.apply(this, r);
          return a.set(o, s), s;
        };
        return (n.cache = new Map()), n;
      };
      function Jt(t, e, n, r) {
        for (const i in ((n = n || 0), (r = r || 5), e))
          if (e.hasOwnProperty(i)) {
            const o = e[i];
            o !== null && b(o)
              ? (b(t[i]) || (t[i] = {}), n < r ? Jt(t[i], o, n + 1, r) : (t[i] = e[i]))
              : l(o)
              ? ((t[i] = []), (t[i] = t[i].concat(o)))
              : void 0 !== o && (t[i] = o);
          }
      }
      var te = function (t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        for (let r = 0; r < e.length; r += 1) Jt(t, e[r]);
        return t;
      };
      var ee = function (t, e, n, r) {
        c(e) || ((n = e), (e = t), (t = function () {}));
        const i = Object.create
          ? function (t, e) {
              return Object.create(t, { constructor: { value: e } });
            }
          : function (t, e) {
              function n() {}
              n.prototype = t;
              const r = new n();
              return (r.constructor = e), r;
            };
        const o = i(e.prototype, t);
        return (
          (t.prototype = qt(o, t.prototype)),
          (t.superclass = i(e.prototype, e)),
          qt(o, n),
          qt(t, r),
          t
        );
      };
      var ne = function (t, e) {
        if (!r(t)) return -1;
        const n = Array.prototype.indexOf;
        if (n) return n.call(t, e);
        for (var i = -1, o = 0; o < t.length; o++)
          if (t[o] === e) {
            i = o;
            break;
          }
        return i;
      };
      const re = Object.prototype.hasOwnProperty;
      var ie = function (t) {
        if (h(t)) return !0;
        if (r(t)) return !t.length;
        const e = jt(t);
        if (e === 'Map' || e === 'Set') return !t.size;
        if (Ft(t)) return !Object.keys(t).length;
        for (const n in t) if (re.call(t, n)) return !1;
        return !0;
      };
      var oe = function t(e, n) {
        if (e === n) return !0;
        if (!e || !n) return !1;
        if (L(e) || L(n)) return !1;
        if (r(e) || r(n)) {
          if (e.length !== n.length) return !1;
          for (var i = !0, o = 0; o < e.length && (i = t(e[o], n[o])); o++);
          return i;
        }
        if (m(e) || m(n)) {
          const a = Object.keys(e);
          const s = Object.keys(n);
          if (a.length !== s.length) return !1;
          for (i = !0, o = 0; o < a.length && (i = t(e[a[o]], n[a[o]])); o++);
          return i;
        }
        return !1;
      };
      var ae = function (t, e, n) {
        return c(n) ? !!n(t, e) : oe(t, e);
      };
      var se = function (t, e) {
        if (!r(t)) return t;
        for (var n = [], i = 0; i < t.length; i++) {
          const o = t[i];
          n.push(e(o, i));
        }
        return n;
      };
      const ue = function (t) {
        return t;
      };
      var ce = function (t, e) {
        void 0 === e && (e = ue);
        const n = {};
        return (
          d(t) &&
            !h(t) &&
            Object.keys(t).forEach((r) => {
              n[r] = e(t[r], r);
            }),
          n
        );
      };
      var he = function (t, e, n) {
        for (var r = 0, i = L(e) ? e.split('.') : e; t && r < i.length; ) t = t[i[r++]];
        return void 0 === t || r < i.length ? n : t;
      };
      var le = function (t, e, n) {
        let r = t;
        const i = L(e) ? e.split('.') : e;
        return (
          i.forEach((t, e) => {
            e < i.length - 1
              ? (d(r[t]) || (r[t] = it(i[e + 1]) ? [] : {}), (r = r[t]))
              : (r[t] = n);
          }),
          t
        );
      };
      const fe = Object.prototype.hasOwnProperty;
      var de = function (t, e) {
        if (t === null || !b(t)) return {};
        const n = {};
        return (
          p(e, (e) => {
            fe.call(t, e) && (n[e] = t[e]);
          }),
          n
        );
      };
      var pe = function (t, e) {
        return _(
          t,
          (t, n, r) => {
            return e.includes(r) || (t[r] = n), t;
          },
          {},
        );
      };
      var ge = function (t, e, n) {
        let r;
        let i;
        let o;
        let a;
        let s = 0;
        n || (n = {});
        const u = function () {
          (s = !1 === n.leading ? 0 : Date.now()),
            (r = null),
            (a = t.apply(i, o)),
            r || (i = o = null);
        };
        const c = function () {
          const c = Date.now();
          s || !1 !== n.leading || (s = c);
          const h = e - (c - s);
          return (
            (i = this),
            (o = arguments),
            h <= 0 || h > e
              ? (r && (clearTimeout(r), (r = null)),
                (s = c),
                (a = t.apply(i, o)),
                r || (i = o = null))
              : r || !1 === n.trailing || (r = setTimeout(u, h)),
            a
          );
        };
        return (
          (c.cancel = function () {
            clearTimeout(r), (s = 0), (r = i = o = null);
          }),
          c
        );
      };
      var ve = function (t) {
        return r(t) ? Array.prototype.slice.call(t) : [];
      };
      const ye = {};
      var me = function (t) {
        return ye[(t = t || 'g')] ? (ye[t] += 1) : (ye[t] = 1), t + ye[t];
      };
      var be = function () {};
      var xe = function (t) {
        return t;
      };
      function Me(t) {
        return h(t) ? 0 : r(t) ? t.length : Object.keys(t).length;
      }
      var Se = (function () {
        function t() {
          this.map = {};
        }
        return (
          (t.prototype.has = function (t) {
            return void 0 !== this.map[t];
          }),
          (t.prototype.get = function (t, e) {
            const n = this.map[t];
            return void 0 === n ? e : n;
          }),
          (t.prototype.set = function (t, e) {
            this.map[t] = e;
          }),
          (t.prototype.clear = function () {
            this.map = {};
          }),
          (t.prototype.delete = function (t) {
            delete this.map[t];
          }),
          (t.prototype.size = function () {
            return Object.keys(this.map).length;
          }),
          t
        );
      })();
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'b', () => {
        return i.a;
      }),
        n.d(e, 'c', () => {
          return i.b;
        }),
        n.d(e, 'd', () => {
          return i.c;
        }),
        n.d(e, 'a', () => {
          return r;
        });
      var r = {};
      n.r(r),
        n.d(r, 'leftTranslate', () => {
          return o;
        }),
        n.d(r, 'leftRotate', () => {
          return a;
        }),
        n.d(r, 'leftScale', () => {
          return s;
        }),
        n.d(r, 'transform', () => {
          return u;
        }),
        n.d(r, 'direction', () => {
          return c;
        }),
        n.d(r, 'angleTo', () => {
          return h;
        }),
        n.d(r, 'vertical', () => {
          return l;
        });
      var i = n(8);
      function o(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.a.fromTranslation(r, n), i.a.multiply(t, r, e);
      }
      function a(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.a.fromRotation(r, n), i.a.multiply(t, r, e);
      }
      function s(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.a.fromScaling(r, n), i.a.multiply(t, r, e);
      }
      function u(t, e) {
        for (
          var n, r, u, c = t ? [].concat(t) : [1, 0, 0, 0, 1, 0, 0, 0, 1], h = 0, l = e.length;
          h < l;
          h++
        ) {
          const f = e[h];
          switch (f[0]) {
            case 't':
              o(c, c, [f[1], f[2]]);
              break;
            case 's':
              s(c, c, [f[1], f[2]]);
              break;
            case 'r':
              a(c, c, f[1]);
              break;
            case 'm':
              (n = c), (r = c), (u = f[1]), i.a.multiply(n, u, r);
          }
        }
        return c;
      }
      function c(t, e) {
        return t[0] * e[1] - e[0] * t[1];
      }
      function h(t, e, n) {
        const r = i.b.angle(t, e);
        const o = c(t, e) >= 0;
        return n ? (o ? 2 * Math.PI - r : r) : o ? r : 2 * Math.PI - r;
      }
      function l(t, e, n) {
        return n ? ((t[0] = e[1]), (t[1] = -1 * e[0])) : ((t[0] = -1 * e[1]), (t[1] = e[0])), t;
      }
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'j', () => {
        return i;
      }),
        n.d(e, 'c', () => {
          return o;
        }),
        n.d(e, 'g', () => {
          return a;
        }),
        n.d(e, 'b', () => {
          return s;
        });
      const r = n(0);
      function i(t, e) {
        const n = t.indexOf(e);
        n !== -1 && t.splice(n, 1);
      }
      n.d(e, 'e', () => {
        return r.j;
      }),
        n.d(e, 'd', () => {
          return r.i;
        }),
        n.d(e, 'h', () => {
          return r.o;
        }),
        n.d(e, 'f', () => {
          return r.m;
        }),
        n.d(e, 'i', () => {
          return r.r;
        }),
        n.d(e, 'a', () => {
          return r.c;
        }),
        n.d(e, 'k', () => {
          return r.w;
        });
      var o = typeof window !== 'undefined' && void 0 !== window.document;
      function a(t, e) {
        if (t.isCanvas()) return !0;
        for (var n = e.getParent(), r = !1; n; ) {
          if (n === t) {
            r = !0;
            break;
          }
          n = n.getParent();
        }
        return r;
      }
      function s(t) {
        return t.cfg.visible && t.cfg.capture;
      }
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'b', () => {
        return r;
      }),
        n.d(e, 'a', () => {
          return i;
        }),
        n.d(e, 'c', () => {
          return o;
        });
      var r = 1e-6;
      var i = typeof Float32Array !== 'undefined' ? Float32Array : Array;
      var o = Math.random;
      Math.PI;
      Math.hypot ||
        (Math.hypot = function () {
          for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e];
          return Math.sqrt(t);
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.Base = void 0);
      const r = (function () {
        function t() {
          (this.nodes = []),
            (this.edges = []),
            (this.combos = []),
            (this.positions = []),
            (this.destroyed = !1),
            (this.onLayoutEnd = function () {});
        }
        return (
          (t.prototype.layout = function (t) {
            return this.init(t), this.execute(!0);
          }),
          (t.prototype.init = function (t) {
            (this.nodes = t.nodes || []),
              (this.edges = t.edges || []),
              (this.combos = t.combos || []);
          }),
          (t.prototype.execute = function (t) {}),
          (t.prototype.executeWithWorker = function () {}),
          (t.prototype.getDefaultCfg = function () {
            return {};
          }),
          (t.prototype.updateCfg = function (t) {
            t && Object.assign(this, t);
          }),
          (t.prototype.getType = function () {
            return 'base';
          }),
          (t.prototype.destroy = function () {
            (this.nodes = null),
              (this.edges = null),
              (this.combos = null),
              (this.positions = null),
              (this.destroyed = !0);
          }),
          t
        );
      })();
      e.Base = r;
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'a', () => {
        return r;
      }),
        n.d(e, 'b', () => {
          return R;
        }),
        n.d(e, 'c', () => {
          return i;
        });
      var r = {};
      n.r(r),
        n.d(r, 'create', () => {
          return a;
        }),
        n.d(r, 'fromMat4', () => {
          return s;
        }),
        n.d(r, 'clone', () => {
          return u;
        }),
        n.d(r, 'copy', () => {
          return c;
        }),
        n.d(r, 'fromValues', () => {
          return h;
        }),
        n.d(r, 'set', () => {
          return l;
        }),
        n.d(r, 'identity', () => {
          return f;
        }),
        n.d(r, 'transpose', () => {
          return d;
        }),
        n.d(r, 'invert', () => {
          return p;
        }),
        n.d(r, 'adjoint', () => {
          return g;
        }),
        n.d(r, 'determinant', () => {
          return v;
        }),
        n.d(r, 'multiply', () => {
          return y;
        }),
        n.d(r, 'translate', () => {
          return m;
        }),
        n.d(r, 'rotate', () => {
          return b;
        }),
        n.d(r, 'scale', () => {
          return x;
        }),
        n.d(r, 'fromTranslation', () => {
          return M;
        }),
        n.d(r, 'fromRotation', () => {
          return S;
        }),
        n.d(r, 'fromScaling', () => {
          return w;
        }),
        n.d(r, 'fromMat2d', () => {
          return O;
        }),
        n.d(r, 'fromQuat', () => {
          return C;
        }),
        n.d(r, 'normalFromMat4', () => {
          return E;
        }),
        n.d(r, 'projection', () => {
          return k;
        }),
        n.d(r, 'str', () => {
          return T;
        }),
        n.d(r, 'frob', () => {
          return P;
        }),
        n.d(r, 'add', () => {
          return I;
        }),
        n.d(r, 'subtract', () => {
          return A;
        }),
        n.d(r, 'multiplyScalar', () => {
          return j;
        }),
        n.d(r, 'multiplyScalarAndAdd', () => {
          return N;
        }),
        n.d(r, 'exactEquals', () => {
          return _;
        }),
        n.d(r, 'equals', () => {
          return B;
        }),
        n.d(r, 'mul', () => {
          return L;
        }),
        n.d(r, 'sub', () => {
          return D;
        });
      var i = {};
      n.r(i),
        n.d(i, 'create', () => {
          return Y;
        }),
        n.d(i, 'clone', () => {
          return F;
        }),
        n.d(i, 'length', () => {
          return X;
        }),
        n.d(i, 'fromValues', () => {
          return z;
        }),
        n.d(i, 'copy', () => {
          return W;
        }),
        n.d(i, 'set', () => {
          return G;
        }),
        n.d(i, 'add', () => {
          return U;
        }),
        n.d(i, 'subtract', () => {
          return H;
        }),
        n.d(i, 'multiply', () => {
          return q;
        }),
        n.d(i, 'divide', () => {
          return V;
        }),
        n.d(i, 'ceil', () => {
          return Z;
        }),
        n.d(i, 'floor', () => {
          return K;
        }),
        n.d(i, 'min', () => {
          return $;
        }),
        n.d(i, 'max', () => {
          return Q;
        }),
        n.d(i, 'round', () => {
          return J;
        }),
        n.d(i, 'scale', () => {
          return tt;
        }),
        n.d(i, 'scaleAndAdd', () => {
          return et;
        }),
        n.d(i, 'distance', () => {
          return nt;
        }),
        n.d(i, 'squaredDistance', () => {
          return rt;
        }),
        n.d(i, 'squaredLength', () => {
          return it;
        }),
        n.d(i, 'negate', () => {
          return ot;
        }),
        n.d(i, 'inverse', () => {
          return at;
        }),
        n.d(i, 'normalize', () => {
          return st;
        }),
        n.d(i, 'dot', () => {
          return ut;
        }),
        n.d(i, 'cross', () => {
          return ct;
        }),
        n.d(i, 'lerp', () => {
          return ht;
        }),
        n.d(i, 'hermite', () => {
          return lt;
        }),
        n.d(i, 'bezier', () => {
          return ft;
        }),
        n.d(i, 'random', () => {
          return dt;
        }),
        n.d(i, 'transformMat4', () => {
          return pt;
        }),
        n.d(i, 'transformMat3', () => {
          return gt;
        }),
        n.d(i, 'transformQuat', () => {
          return vt;
        }),
        n.d(i, 'rotateX', () => {
          return yt;
        }),
        n.d(i, 'rotateY', () => {
          return mt;
        }),
        n.d(i, 'rotateZ', () => {
          return bt;
        }),
        n.d(i, 'angle', () => {
          return xt;
        }),
        n.d(i, 'zero', () => {
          return Mt;
        }),
        n.d(i, 'str', () => {
          return St;
        }),
        n.d(i, 'exactEquals', () => {
          return wt;
        }),
        n.d(i, 'equals', () => {
          return Ot;
        }),
        n.d(i, 'sub', () => {
          return Et;
        }),
        n.d(i, 'mul', () => {
          return kt;
        }),
        n.d(i, 'div', () => {
          return Tt;
        }),
        n.d(i, 'dist', () => {
          return Pt;
        }),
        n.d(i, 'sqrDist', () => {
          return It;
        }),
        n.d(i, 'len', () => {
          return At;
        }),
        n.d(i, 'sqrLen', () => {
          return jt;
        }),
        n.d(i, 'forEach', () => {
          return Nt;
        });
      const o = n(6);
      function a() {
        const t = new o.a(9);
        return (
          o.a != Float32Array &&
            ((t[1] = 0), (t[2] = 0), (t[3] = 0), (t[5] = 0), (t[6] = 0), (t[7] = 0)),
          (t[0] = 1),
          (t[4] = 1),
          (t[8] = 1),
          t
        );
      }
      function s(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[4]),
          (t[4] = e[5]),
          (t[5] = e[6]),
          (t[6] = e[8]),
          (t[7] = e[9]),
          (t[8] = e[10]),
          t
        );
      }
      function u(t) {
        const e = new o.a(9);
        return (
          (e[0] = t[0]),
          (e[1] = t[1]),
          (e[2] = t[2]),
          (e[3] = t[3]),
          (e[4] = t[4]),
          (e[5] = t[5]),
          (e[6] = t[6]),
          (e[7] = t[7]),
          (e[8] = t[8]),
          e
        );
      }
      function c(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          t
        );
      }
      function h(t, e, n, r, i, a, s, u, c) {
        const h = new o.a(9);
        return (
          (h[0] = t),
          (h[1] = e),
          (h[2] = n),
          (h[3] = r),
          (h[4] = i),
          (h[5] = a),
          (h[6] = s),
          (h[7] = u),
          (h[8] = c),
          h
        );
      }
      function l(t, e, n, r, i, o, a, s, u, c) {
        return (
          (t[0] = e),
          (t[1] = n),
          (t[2] = r),
          (t[3] = i),
          (t[4] = o),
          (t[5] = a),
          (t[6] = s),
          (t[7] = u),
          (t[8] = c),
          t
        );
      }
      function f(t) {
        return (
          (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 1),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function d(t, e) {
        if (t === e) {
          const n = e[1];
          const r = e[2];
          const i = e[5];
          (t[1] = e[3]), (t[2] = e[6]), (t[3] = n), (t[5] = e[7]), (t[6] = r), (t[7] = i);
        } else
          (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]);
        return t;
      }
      function p(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        const l = h * a - s * c;
        const f = -h * o + s * u;
        const d = c * o - a * u;
        let p = n * l + r * f + i * d;
        return p
          ? ((p = 1 / p),
            (t[0] = l * p),
            (t[1] = (-h * r + i * c) * p),
            (t[2] = (s * r - i * a) * p),
            (t[3] = f * p),
            (t[4] = (h * n - i * u) * p),
            (t[5] = (-s * n + i * o) * p),
            (t[6] = d * p),
            (t[7] = (-c * n + r * u) * p),
            (t[8] = (a * n - r * o) * p),
            t)
          : null;
      }
      function g(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        return (
          (t[0] = a * h - s * c),
          (t[1] = i * c - r * h),
          (t[2] = r * s - i * a),
          (t[3] = s * u - o * h),
          (t[4] = n * h - i * u),
          (t[5] = i * o - n * s),
          (t[6] = o * c - a * u),
          (t[7] = r * u - n * c),
          (t[8] = n * a - r * o),
          t
        );
      }
      function v(t) {
        const e = t[0];
        const n = t[1];
        const r = t[2];
        const i = t[3];
        const o = t[4];
        const a = t[5];
        const s = t[6];
        const u = t[7];
        const c = t[8];
        return e * (c * o - a * u) + n * (-c * i + a * s) + r * (u * i - o * s);
      }
      function y(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = n[0];
        const d = n[1];
        const p = n[2];
        const g = n[3];
        const v = n[4];
        const y = n[5];
        const m = n[6];
        const b = n[7];
        const x = n[8];
        return (
          (t[0] = f * r + d * a + p * c),
          (t[1] = f * i + d * s + p * h),
          (t[2] = f * o + d * u + p * l),
          (t[3] = g * r + v * a + y * c),
          (t[4] = g * i + v * s + y * h),
          (t[5] = g * o + v * u + y * l),
          (t[6] = m * r + b * a + x * c),
          (t[7] = m * i + b * s + x * h),
          (t[8] = m * o + b * u + x * l),
          t
        );
      }
      function m(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = n[0];
        const d = n[1];
        return (
          (t[0] = r),
          (t[1] = i),
          (t[2] = o),
          (t[3] = a),
          (t[4] = s),
          (t[5] = u),
          (t[6] = f * r + d * a + c),
          (t[7] = f * i + d * s + h),
          (t[8] = f * o + d * u + l),
          t
        );
      }
      function b(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = Math.sin(n);
        const d = Math.cos(n);
        return (
          (t[0] = d * r + f * a),
          (t[1] = d * i + f * s),
          (t[2] = d * o + f * u),
          (t[3] = d * a - f * r),
          (t[4] = d * s - f * i),
          (t[5] = d * u - f * o),
          (t[6] = c),
          (t[7] = h),
          (t[8] = l),
          t
        );
      }
      function x(t, e, n) {
        const r = n[0];
        const i = n[1];
        return (
          (t[0] = r * e[0]),
          (t[1] = r * e[1]),
          (t[2] = r * e[2]),
          (t[3] = i * e[3]),
          (t[4] = i * e[4]),
          (t[5] = i * e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          t
        );
      }
      function M(t, e) {
        return (
          (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 1),
          (t[5] = 0),
          (t[6] = e[0]),
          (t[7] = e[1]),
          (t[8] = 1),
          t
        );
      }
      function S(t, e) {
        const n = Math.sin(e);
        const r = Math.cos(e);
        return (
          (t[0] = r),
          (t[1] = n),
          (t[2] = 0),
          (t[3] = -n),
          (t[4] = r),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function w(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = e[1]),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function O(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = 0),
          (t[3] = e[2]),
          (t[4] = e[3]),
          (t[5] = 0),
          (t[6] = e[4]),
          (t[7] = e[5]),
          (t[8] = 1),
          t
        );
      }
      function C(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = n + n;
        const s = r + r;
        const u = i + i;
        const c = n * a;
        const h = r * a;
        const l = r * s;
        const f = i * a;
        const d = i * s;
        const p = i * u;
        const g = o * a;
        const v = o * s;
        const y = o * u;
        return (
          (t[0] = 1 - l - p),
          (t[3] = h - y),
          (t[6] = f + v),
          (t[1] = h + y),
          (t[4] = 1 - c - p),
          (t[7] = d - g),
          (t[2] = f - v),
          (t[5] = d + g),
          (t[8] = 1 - c - l),
          t
        );
      }
      function E(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        const l = e[9];
        const f = e[10];
        const d = e[11];
        const p = e[12];
        const g = e[13];
        const v = e[14];
        const y = e[15];
        const m = n * s - r * a;
        const b = n * u - i * a;
        const x = n * c - o * a;
        const M = r * u - i * s;
        const S = r * c - o * s;
        const w = i * c - o * u;
        const O = h * g - l * p;
        const C = h * v - f * p;
        const E = h * y - d * p;
        const k = l * v - f * g;
        const T = l * y - d * g;
        const P = f * y - d * v;
        let I = m * P - b * T + x * k + M * E - S * C + w * O;
        return I
          ? ((I = 1 / I),
            (t[0] = (s * P - u * T + c * k) * I),
            (t[1] = (u * E - a * P - c * C) * I),
            (t[2] = (a * T - s * E + c * O) * I),
            (t[3] = (i * T - r * P - o * k) * I),
            (t[4] = (n * P - i * E + o * C) * I),
            (t[5] = (r * E - n * T - o * O) * I),
            (t[6] = (g * w - v * S + y * M) * I),
            (t[7] = (v * x - p * w - y * b) * I),
            (t[8] = (p * S - g * x + y * m) * I),
            t)
          : null;
      }
      function k(t, e, n) {
        return (
          (t[0] = 2 / e),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = -2 / n),
          (t[5] = 0),
          (t[6] = -1),
          (t[7] = 1),
          (t[8] = 1),
          t
        );
      }
      function T(t) {
        return `mat3(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}, ${t[4]}, ${t[5]}, ${t[6]}, ${t[7]}, ${t[8]})`;
      }
      function P(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
      }
      function I(t, e, n) {
        return (
          (t[0] = e[0] + n[0]),
          (t[1] = e[1] + n[1]),
          (t[2] = e[2] + n[2]),
          (t[3] = e[3] + n[3]),
          (t[4] = e[4] + n[4]),
          (t[5] = e[5] + n[5]),
          (t[6] = e[6] + n[6]),
          (t[7] = e[7] + n[7]),
          (t[8] = e[8] + n[8]),
          t
        );
      }
      function A(t, e, n) {
        return (
          (t[0] = e[0] - n[0]),
          (t[1] = e[1] - n[1]),
          (t[2] = e[2] - n[2]),
          (t[3] = e[3] - n[3]),
          (t[4] = e[4] - n[4]),
          (t[5] = e[5] - n[5]),
          (t[6] = e[6] - n[6]),
          (t[7] = e[7] - n[7]),
          (t[8] = e[8] - n[8]),
          t
        );
      }
      function j(t, e, n) {
        return (
          (t[0] = e[0] * n),
          (t[1] = e[1] * n),
          (t[2] = e[2] * n),
          (t[3] = e[3] * n),
          (t[4] = e[4] * n),
          (t[5] = e[5] * n),
          (t[6] = e[6] * n),
          (t[7] = e[7] * n),
          (t[8] = e[8] * n),
          t
        );
      }
      function N(t, e, n, r) {
        return (
          (t[0] = e[0] + n[0] * r),
          (t[1] = e[1] + n[1] * r),
          (t[2] = e[2] + n[2] * r),
          (t[3] = e[3] + n[3] * r),
          (t[4] = e[4] + n[4] * r),
          (t[5] = e[5] + n[5] * r),
          (t[6] = e[6] + n[6] * r),
          (t[7] = e[7] + n[7] * r),
          (t[8] = e[8] + n[8] * r),
          t
        );
      }
      function _(t, e) {
        return (
          t[0] === e[0] &&
          t[1] === e[1] &&
          t[2] === e[2] &&
          t[3] === e[3] &&
          t[4] === e[4] &&
          t[5] === e[5] &&
          t[6] === e[6] &&
          t[7] === e[7] &&
          t[8] === e[8]
        );
      }
      function B(t, e) {
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const a = t[3];
        const s = t[4];
        const u = t[5];
        const c = t[6];
        const h = t[7];
        const l = t[8];
        const f = e[0];
        const d = e[1];
        const p = e[2];
        const g = e[3];
        const v = e[4];
        const y = e[5];
        const m = e[6];
        const b = e[7];
        const x = e[8];
        return (
          Math.abs(n - f) <= o.b * Math.max(1, Math.abs(n), Math.abs(f)) &&
          Math.abs(r - d) <= o.b * Math.max(1, Math.abs(r), Math.abs(d)) &&
          Math.abs(i - p) <= o.b * Math.max(1, Math.abs(i), Math.abs(p)) &&
          Math.abs(a - g) <= o.b * Math.max(1, Math.abs(a), Math.abs(g)) &&
          Math.abs(s - v) <= o.b * Math.max(1, Math.abs(s), Math.abs(v)) &&
          Math.abs(u - y) <= o.b * Math.max(1, Math.abs(u), Math.abs(y)) &&
          Math.abs(c - m) <= o.b * Math.max(1, Math.abs(c), Math.abs(m)) &&
          Math.abs(h - b) <= o.b * Math.max(1, Math.abs(h), Math.abs(b)) &&
          Math.abs(l - x) <= o.b * Math.max(1, Math.abs(l), Math.abs(x))
        );
      }
      var L = y;
      var D = A;
      var R = n(51);
      function Y() {
        const t = new o.a(3);
        return o.a != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t;
      }
      function F(t) {
        const e = new o.a(3);
        return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
      }
      function X(t) {
        const e = t[0];
        const n = t[1];
        const r = t[2];
        return Math.hypot(e, n, r);
      }
      function z(t, e, n) {
        const r = new o.a(3);
        return (r[0] = t), (r[1] = e), (r[2] = n), r;
      }
      function W(t, e) {
        return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t;
      }
      function G(t, e, n, r) {
        return (t[0] = e), (t[1] = n), (t[2] = r), t;
      }
      function U(t, e, n) {
        return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), (t[2] = e[2] + n[2]), t;
      }
      function H(t, e, n) {
        return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), (t[2] = e[2] - n[2]), t;
      }
      function q(t, e, n) {
        return (t[0] = e[0] * n[0]), (t[1] = e[1] * n[1]), (t[2] = e[2] * n[2]), t;
      }
      function V(t, e, n) {
        return (t[0] = e[0] / n[0]), (t[1] = e[1] / n[1]), (t[2] = e[2] / n[2]), t;
      }
      function Z(t, e) {
        return (t[0] = Math.ceil(e[0])), (t[1] = Math.ceil(e[1])), (t[2] = Math.ceil(e[2])), t;
      }
      function K(t, e) {
        return (t[0] = Math.floor(e[0])), (t[1] = Math.floor(e[1])), (t[2] = Math.floor(e[2])), t;
      }
      function $(t, e, n) {
        return (
          (t[0] = Math.min(e[0], n[0])),
          (t[1] = Math.min(e[1], n[1])),
          (t[2] = Math.min(e[2], n[2])),
          t
        );
      }
      function Q(t, e, n) {
        return (
          (t[0] = Math.max(e[0], n[0])),
          (t[1] = Math.max(e[1], n[1])),
          (t[2] = Math.max(e[2], n[2])),
          t
        );
      }
      function J(t, e) {
        return (t[0] = Math.round(e[0])), (t[1] = Math.round(e[1])), (t[2] = Math.round(e[2])), t;
      }
      function tt(t, e, n) {
        return (t[0] = e[0] * n), (t[1] = e[1] * n), (t[2] = e[2] * n), t;
      }
      function et(t, e, n, r) {
        return (t[0] = e[0] + n[0] * r), (t[1] = e[1] + n[1] * r), (t[2] = e[2] + n[2] * r), t;
      }
      function nt(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        const i = e[2] - t[2];
        return Math.hypot(n, r, i);
      }
      function rt(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        const i = e[2] - t[2];
        return n * n + r * r + i * i;
      }
      function it(t) {
        const e = t[0];
        const n = t[1];
        const r = t[2];
        return e * e + n * n + r * r;
      }
      function ot(t, e) {
        return (t[0] = -e[0]), (t[1] = -e[1]), (t[2] = -e[2]), t;
      }
      function at(t, e) {
        return (t[0] = 1 / e[0]), (t[1] = 1 / e[1]), (t[2] = 1 / e[2]), t;
      }
      function st(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        let o = n * n + r * r + i * i;
        return (
          o > 0 && (o = 1 / Math.sqrt(o)),
          (t[0] = e[0] * o),
          (t[1] = e[1] * o),
          (t[2] = e[2] * o),
          t
        );
      }
      function ut(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
      }
      function ct(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = n[0];
        const s = n[1];
        const u = n[2];
        return (t[0] = i * u - o * s), (t[1] = o * a - r * u), (t[2] = r * s - i * a), t;
      }
      function ht(t, e, n, r) {
        const i = e[0];
        const o = e[1];
        const a = e[2];
        return (
          (t[0] = i + r * (n[0] - i)), (t[1] = o + r * (n[1] - o)), (t[2] = a + r * (n[2] - a)), t
        );
      }
      function lt(t, e, n, r, i, o) {
        const a = o * o;
        const s = a * (2 * o - 3) + 1;
        const u = a * (o - 2) + o;
        const c = a * (o - 1);
        const h = a * (3 - 2 * o);
        return (
          (t[0] = e[0] * s + n[0] * u + r[0] * c + i[0] * h),
          (t[1] = e[1] * s + n[1] * u + r[1] * c + i[1] * h),
          (t[2] = e[2] * s + n[2] * u + r[2] * c + i[2] * h),
          t
        );
      }
      function ft(t, e, n, r, i, o) {
        const a = 1 - o;
        const s = a * a;
        const u = o * o;
        const c = s * a;
        const h = 3 * o * s;
        const l = 3 * u * a;
        const f = u * o;
        return (
          (t[0] = e[0] * c + n[0] * h + r[0] * l + i[0] * f),
          (t[1] = e[1] * c + n[1] * h + r[1] * l + i[1] * f),
          (t[2] = e[2] * c + n[2] * h + r[2] * l + i[2] * f),
          t
        );
      }
      function dt(t, e) {
        e = e || 1;
        const n = 2 * o.c() * Math.PI;
        const r = 2 * o.c() - 1;
        const i = Math.sqrt(1 - r * r) * e;
        return (t[0] = Math.cos(n) * i), (t[1] = Math.sin(n) * i), (t[2] = r * e), t;
      }
      function pt(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        let a = n[3] * r + n[7] * i + n[11] * o + n[15];
        return (
          (a = a || 1),
          (t[0] = (n[0] * r + n[4] * i + n[8] * o + n[12]) / a),
          (t[1] = (n[1] * r + n[5] * i + n[9] * o + n[13]) / a),
          (t[2] = (n[2] * r + n[6] * i + n[10] * o + n[14]) / a),
          t
        );
      }
      function gt(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        return (
          (t[0] = r * n[0] + i * n[3] + o * n[6]),
          (t[1] = r * n[1] + i * n[4] + o * n[7]),
          (t[2] = r * n[2] + i * n[5] + o * n[8]),
          t
        );
      }
      function vt(t, e, n) {
        const r = n[0];
        const i = n[1];
        const o = n[2];
        const a = n[3];
        const s = e[0];
        const u = e[1];
        const c = e[2];
        let h = i * c - o * u;
        let l = o * s - r * c;
        let f = r * u - i * s;
        let d = i * f - o * l;
        let p = o * h - r * f;
        let g = r * l - i * h;
        const v = 2 * a;
        return (
          (h *= v),
          (l *= v),
          (f *= v),
          (d *= 2),
          (p *= 2),
          (g *= 2),
          (t[0] = s + h + d),
          (t[1] = u + l + p),
          (t[2] = c + f + g),
          t
        );
      }
      function yt(t, e, n, r) {
        const i = [];
        const o = [];
        return (
          (i[0] = e[0] - n[0]),
          (i[1] = e[1] - n[1]),
          (i[2] = e[2] - n[2]),
          (o[0] = i[0]),
          (o[1] = i[1] * Math.cos(r) - i[2] * Math.sin(r)),
          (o[2] = i[1] * Math.sin(r) + i[2] * Math.cos(r)),
          (t[0] = o[0] + n[0]),
          (t[1] = o[1] + n[1]),
          (t[2] = o[2] + n[2]),
          t
        );
      }
      function mt(t, e, n, r) {
        const i = [];
        const o = [];
        return (
          (i[0] = e[0] - n[0]),
          (i[1] = e[1] - n[1]),
          (i[2] = e[2] - n[2]),
          (o[0] = i[2] * Math.sin(r) + i[0] * Math.cos(r)),
          (o[1] = i[1]),
          (o[2] = i[2] * Math.cos(r) - i[0] * Math.sin(r)),
          (t[0] = o[0] + n[0]),
          (t[1] = o[1] + n[1]),
          (t[2] = o[2] + n[2]),
          t
        );
      }
      function bt(t, e, n, r) {
        const i = [];
        const o = [];
        return (
          (i[0] = e[0] - n[0]),
          (i[1] = e[1] - n[1]),
          (i[2] = e[2] - n[2]),
          (o[0] = i[0] * Math.cos(r) - i[1] * Math.sin(r)),
          (o[1] = i[0] * Math.sin(r) + i[1] * Math.cos(r)),
          (o[2] = i[2]),
          (t[0] = o[0] + n[0]),
          (t[1] = o[1] + n[1]),
          (t[2] = o[2] + n[2]),
          t
        );
      }
      function xt(t, e) {
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const o = e[0];
        const a = e[1];
        const s = e[2];
        const u = Math.sqrt(n * n + r * r + i * i) * Math.sqrt(o * o + a * a + s * s);
        const c = u && ut(t, e) / u;
        return Math.acos(Math.min(Math.max(c, -1), 1));
      }
      function Mt(t) {
        return (t[0] = 0), (t[1] = 0), (t[2] = 0), t;
      }
      function St(t) {
        return `vec3(${t[0]}, ${t[1]}, ${t[2]})`;
      }
      function wt(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
      }
      function Ot(t, e) {
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const a = e[0];
        const s = e[1];
        const u = e[2];
        return (
          Math.abs(n - a) <= o.b * Math.max(1, Math.abs(n), Math.abs(a)) &&
          Math.abs(r - s) <= o.b * Math.max(1, Math.abs(r), Math.abs(s)) &&
          Math.abs(i - u) <= o.b * Math.max(1, Math.abs(i), Math.abs(u))
        );
      }
      let Ct;
      var Et = H;
      var kt = q;
      var Tt = V;
      var Pt = nt;
      var It = rt;
      var At = X;
      var jt = it;
      var Nt =
        ((Ct = Y()),
        function (t, e, n, r, i, o) {
          let a;
          let s;
          for (
            e || (e = 3), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n;
            a < s;
            a += e
          )
            (Ct[0] = t[a]),
              (Ct[1] = t[a + 1]),
              (Ct[2] = t[a + 2]),
              i(Ct, Ct, o),
              (t[a] = Ct[0]),
              (t[a + 1] = Ct[1]),
              (t[a + 2] = Ct[2]);
          return t;
        });
    },
    ,
    function (t, e, n) {
      'use strict';
      const r =
        (this && this.__createBinding) ||
        (Object.create
          ? function (t, e, n, r) {
              void 0 === r && (r = n),
                Object.defineProperty(t, r, {
                  enumerable: !0,
                  get() {
                    return e[n];
                  },
                });
            }
          : function (t, e, n, r) {
              void 0 === r && (r = n), (t[r] = e[n]);
            });
      const i =
        (this && this.__exportStar) ||
        function (t, e) {
          for (const n in t)
            n === 'default' || Object.prototype.hasOwnProperty.call(e, n) || r(e, t, n);
        };
      Object.defineProperty(e, '__esModule', { value: !0 }),
        i(n(11), e),
        i(n(12), e),
        i(n(13), e),
        i(n(14), e),
        i(n(15), e),
        i(n(16), e);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.camelize = e.isString = void 0);
      e.isString = function (t) {
        return typeof t === 'string';
      };
      let r;
      let i;
      const o = /-(\w)/g;
      e.camelize =
        ((r = function (t) {
          return t.replace(o, (t, e) => {
            return e ? e.toUpperCase() : '';
          });
        }),
        (i = Object.create(null)),
        function (t) {
          return i[t] || (i[t] = r(t));
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isArray = void 0),
        (e.isArray = Array.isArray);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.toNumber = e.isNaN = e.isNumber = void 0);
      e.isNumber = function (t) {
        return typeof t === 'number';
      };
      e.isNaN = function (t) {
        return Number.isNaN(Number(t));
      };
      e.toNumber = function (t) {
        const n = parseFloat(t);
        return e.isNaN(n) ? t : n;
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.traverseTreeUp =
          e.scaleMatrix =
          e.getAdjMatrix =
          e.floydWarshall =
          e.getDegree =
            void 0);
      e.getDegree = function (t, e, n) {
        for (var r = [], i = 0; i < t; i++) r[i] = 0;
        return n
          ? (n.forEach((t) => {
              t.source && (r[e[t.source]] += 1), t.target && (r[e[t.target]] += 1);
            }),
            r)
          : r;
      };
      e.floydWarshall = function (t) {
        for (var e = [], n = t.length, r = 0; r < n; r += 1) {
          e[r] = [];
          for (var i = 0; i < n; i += 1)
            r === i
              ? (e[r][i] = 0)
              : t[r][i] !== 0 && t[r][i]
              ? (e[r][i] = t[r][i])
              : (e[r][i] = 1 / 0);
        }
        for (let o = 0; o < n; o += 1)
          for (r = 0; r < n; r += 1)
            for (i = 0; i < n; i += 1) e[r][i] > e[r][o] + e[o][i] && (e[r][i] = e[r][o] + e[o][i]);
        return e;
      };
      e.getAdjMatrix = function (t, e) {
        const n = t.nodes;
        const r = t.edges;
        const i = [];
        const o = {};
        if (!n) throw new Error('invalid nodes data!');
        return (
          n &&
            n.forEach((t, e) => {
              o[t.id] = e;
              i.push([]);
            }),
          r &&
            r.forEach((t) => {
              const n = t.source;
              const r = t.target;
              const a = o[n];
              const s = o[r];
              (i[a][s] = 1), e || (i[s][a] = 1);
            }),
          i
        );
      };
      e.scaleMatrix = function (t, e) {
        const n = [];
        return (
          t.forEach((t) => {
            const r = [];
            t.forEach((t) => {
              r.push(t * e);
            }),
              n.push(r);
          }),
          n
        );
      };
      e.traverseTreeUp = function (t, e) {
        typeof e === 'function' &&
          (function t(e, n) {
            if (e && e.children)
              for (let r = e.children.length - 1; r >= 0; r--) if (!t(e.children[r], n)) return;
            return !!n(e);
          })(t, e);
      };
    },
    function (t, e, n) {
      'use strict';
      function r(t) {
        return (r =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var i =
        (this && this.__assign) ||
        function () {
          return (i =
            Object.assign ||
            function (t) {
              for (var e, n = 1, r = arguments.length; n < r; n++)
                for (const i in (e = arguments[n]))
                  Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
              return t;
            }).apply(this, arguments);
        };
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.clone = e.isObject = void 0);
      e.isObject = function (t) {
        return t !== null && r(t) === 'object';
      };
      e.clone = function (t) {
        if (t === null) return t;
        if (t instanceof Date) return new Date(t.getTime());
        if (t instanceof Array) {
          const n = [];
          return (
            t.forEach((t) => {
              n.push(t);
            }),
            n.map((t) => {
              return e.clone(t);
            })
          );
        }
        if (r(t) === 'object' && t !== {}) {
          const o = i({}, t);
          return (
            Object.keys(o).forEach((t) => {
              o[t] = e.clone(o[t]);
            }),
            o
          );
        }
        return t;
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.isFunction = void 0);
      e.isFunction = function (t) {
        return typeof t === 'function';
      };
    },
    ,
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.PROPS_CLIENT_XY =
          e.PROPS_XY =
          e.DIRECTION_ALL =
          e.DIRECTION_VERTICAL =
          e.DIRECTION_HORIZONTAL =
          e.DIRECTION_DOWN =
          e.DIRECTION_UP =
          e.DIRECTION_RIGHT =
          e.DIRECTION_LEFT =
          e.DIRECTION_NONE =
          e.INPUT_CANCEL =
          e.INPUT_END =
          e.INPUT_MOVE =
          e.INPUT_START =
          e.COMPUTE_INTERVAL =
          e.INPUT_TYPE_TOUCH =
          e.INPUT_TYPE_PEN =
          e.INPUT_TYPE_MOUSE =
          e.INPUT_TYPE_KINECT =
            void 0);
      e.INPUT_TYPE_TOUCH = 'touch';
      e.INPUT_TYPE_PEN = 'pen';
      e.INPUT_TYPE_MOUSE = 'mouse';
      e.INPUT_TYPE_KINECT = 'kinect';
      e.COMPUTE_INTERVAL = 25;
      e.INPUT_START = 1;
      e.INPUT_MOVE = 2;
      e.INPUT_END = 4;
      e.INPUT_CANCEL = 8;
      e.DIRECTION_NONE = 1;
      e.DIRECTION_LEFT = 2;
      e.DIRECTION_RIGHT = 4;
      e.DIRECTION_UP = 8;
      e.DIRECTION_DOWN = 16;
      e.DIRECTION_HORIZONTAL = 6;
      e.DIRECTION_VERTICAL = 24;
      e.DIRECTION_ALL = 30;
      e.PROPS_XY = ['x', 'y'];
      e.PROPS_CLIENT_XY = ['clientX', 'clientY'];
    },
    function (t, e, n) {
      'use strict';
      const r = n(93);
      const i = Object(r.getColorsWithSubjectColor)('rgb(95, 149, 255)', 'rgb(255, 255, 255)');
      e.a = {
        version: '0.0.11',
        rootContainerClassName: 'root-container',
        uiContainerClassName: 'ui-container',
        waterContainerClassName: 'water-container',
        nodeContainerClassName: 'node-container',
        edgeContainerClassName: 'edge-container',
        comboContainerClassName: 'combo-container',
        delegateContainerClassName: 'delegate-container',
        defaultLoopPosition: 'top',
        nodeLabel: {
          style: { fill: '#000', fontSize: 12, textAlign: 'center', textBaseline: 'middle' },
          offset: 4,
        },
        defaultNode: {
          type: 'circle',
          style: { lineWidth: 1, stroke: i.mainStroke, fill: i.mainFill },
          size: 20,
          color: i.mainStroke,
          linkPoints: { size: 8, lineWidth: 1, fill: i.activeFill, stroke: i.activeStroke },
        },
        nodeStateStyles: {
          active: {
            fill: i.activeFill,
            stroke: i.activeStroke,
            lineWidth: 2,
            shadowColor: i.mainStroke,
            shadowBlur: 10,
          },
          selected: {
            fill: i.selectedFill,
            stroke: i.selectedStroke,
            lineWidth: 4,
            shadowColor: i.selectedStroke,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: {
            fill: i.highlightFill,
            stroke: i.highlightStroke,
            lineWidth: 2,
            'text-shape': { fontWeight: 500 },
          },
          inactive: { fill: i.inactiveFill, stroke: i.inactiveStroke, lineWidth: 1 },
          disable: { fill: i.disableFill, stroke: i.disableStroke, lineWidth: 1 },
        },
        edgeLabel: {
          style: {
            fill: 'rgb(0, 0, 0)',
            textAlign: 'center',
            textBaseline: 'middle',
            fontSize: 12,
          },
        },
        defaultEdge: {
          type: 'line',
          size: 1,
          style: { stroke: i.edgeMainStroke, lineAppendWidth: 2 },
          color: i.edgeMainStroke,
        },
        edgeStateStyles: {
          active: { stroke: i.edgeActiveStroke, lineWidth: 1 },
          selected: {
            stroke: i.edgeSelectedStroke,
            lineWidth: 2,
            shadowColor: i.edgeSelectedStroke,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: {
            stroke: i.edgeHighlightStroke,
            lineWidth: 2,
            'text-shape': { fontWeight: 500 },
          },
          inactive: { stroke: i.edgeInactiveStroke, lineWidth: 1 },
          disable: { stroke: i.edgeDisableStroke, lineWidth: 1 },
        },
        comboLabel: {
          style: { fill: 'rgb(0, 0, 0)', textBaseline: 'middle', fontSize: 12 },
          refY: 10,
          refX: 10,
        },
        defaultCombo: {
          type: 'circle',
          style: {
            fill: i.comboMainFill,
            lineWidth: 1,
            stroke: i.comboMainStroke,
            r: 5,
            width: 20,
            height: 10,
          },
          size: [20, 5],
          color: i.comboMainStroke,
          padding: [25, 20, 15, 20],
        },
        comboStateStyles: {
          active: { stroke: i.comboActiveStroke, lineWidth: 1, fill: i.comboActiveFill },
          selected: {
            stroke: i.comboSelectedStroke,
            lineWidth: 2,
            fill: i.comboSelectedFill,
            shadowColor: i.comboSelectedStroke,
            shadowBlur: 10,
            'text-shape': { fontWeight: 500 },
          },
          highlight: {
            stroke: i.comboHighlightStroke,
            lineWidth: 2,
            fill: i.comboHighlightFill,
            'text-shape': { fontWeight: 500 },
          },
          inactive: { stroke: i.comboInactiveStroke, fill: i.comboInactiveFill, lineWidth: 1 },
          disable: { stroke: i.comboDisableStroke, fill: i.comboDisableFill, lineWidth: 1 },
        },
        delegateStyle: {
          fill: '#F3F9FF',
          fillOpacity: 0.5,
          stroke: '#1890FF',
          strokeOpacity: 0.9,
          lineDash: [5, 5],
        },
        textWaterMarkerConfig: {
          width: 150,
          height: 100,
          compatible: !1,
          text: {
            x: 0,
            y: 60,
            lineHeight: 20,
            rotate: 20,
            fontSize: 14,
            fontFamily: 'Microsoft YaHei',
            fill: 'rgba(0, 0, 0, 0.1)',
            baseline: 'Middle',
          },
        },
        imageWaterMarkerConfig: { image: { x: 0, y: 0, width: 30, height: 20, rotate: 0 } },
        waterMarkerImage:
          'https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg',
      };
    },
    ,
    function (t, e, n) {
      'use strict';
      function r(t, e) {
        const n = [];
        const r = t[0];
        const i = t[1];
        const o = t[2];
        const a = t[3];
        const s = t[4];
        const u = t[5];
        const c = t[6];
        const h = t[7];
        const l = t[8];
        const f = e[0];
        const d = e[1];
        const p = e[2];
        const g = e[3];
        const v = e[4];
        const y = e[5];
        const m = e[6];
        const b = e[7];
        const x = e[8];
        return (
          (n[0] = f * r + d * a + p * c),
          (n[1] = f * i + d * s + p * h),
          (n[2] = f * o + d * u + p * l),
          (n[3] = g * r + v * a + y * c),
          (n[4] = g * i + v * s + y * h),
          (n[5] = g * o + v * u + y * l),
          (n[6] = m * r + b * a + x * c),
          (n[7] = m * i + b * s + x * h),
          (n[8] = m * o + b * u + x * l),
          n
        );
      }
      function i(t, e) {
        const n = [];
        const r = e[0];
        const i = e[1];
        return (n[0] = t[0] * r + t[3] * i + t[6]), (n[1] = t[1] * r + t[4] * i + t[7]), n;
      }
      function o(t) {
        const e = [];
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const o = t[3];
        const a = t[4];
        const s = t[5];
        const u = t[6];
        const c = t[7];
        const h = t[8];
        const l = h * a - s * c;
        const f = -h * o + s * u;
        const d = c * o - a * u;
        let p = n * l + r * f + i * d;
        return p
          ? ((p = 1 / p),
            (e[0] = l * p),
            (e[1] = (-h * r + i * c) * p),
            (e[2] = (s * r - i * a) * p),
            (e[3] = f * p),
            (e[4] = (h * n - i * u) * p),
            (e[5] = (-s * n + i * o) * p),
            (e[6] = d * p),
            (e[7] = (-c * n + r * u) * p),
            (e[8] = (a * n - r * o) * p),
            e)
          : null;
      }
      n.d(e, 'b', () => {
        return r;
      }),
        n.d(e, 'c', () => {
          return i;
        }),
        n.d(e, 'a', () => {
          return o;
        });
    },
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.STATE_FAILED =
          e.STATE_CANCELLED =
          e.STATE_RECOGNIZED =
          e.STATE_ENDED =
          e.STATE_CHANGED =
          e.STATE_BEGAN =
          e.STATE_POSSIBLE =
            void 0);
      e.STATE_POSSIBLE = 1;
      e.STATE_BEGAN = 2;
      e.STATE_CHANGED = 4;
      e.STATE_ENDED = 8;
      e.STATE_RECOGNIZED = 8;
      e.STATE_CANCELLED = 16;
      e.STATE_FAILED = 32;
    },
    ,
    function (t, e, n) {
      'use strict';
      const r = n(98);
      n.d(e, 'a', () => {
        return r.Layout;
      }),
        n.d(e, 'b', () => {
          return r.Layouts;
        });
      const i = n(63);
      n.d(e, 'c', () => {
        return i.registerLayout;
      }),
        n.d(e, 'd', () => {
          return i.unRegisterLayout;
        });
      const o = n(64);
      Object(i.registerLayout)('random', o.RandomLayout);
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'a', () => {
        return h;
      }),
        n.d(e, 'b', () => {
          return d;
        }),
        n.d(e, 'c', () => {
          return s;
        });
      const r = n(0);
      const i = '\t\n\v\f\r   ᠎             　\u2028\u2029';
      const o = new RegExp(
        `([a-z])[${i},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${i}]*,?[${i}]*)+)`,
        'ig',
      );
      const a = new RegExp(`(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${i}]*,?[${i}]*`, 'ig');
      var s = function (t) {
        if (!t) return null;
        if (Object(r.f)(t)) return t;
        const e = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 };
        const n = [];
        return (
          String(t).replace(o, (r, i, o) => {
            const s = [];
            let u = i.toLowerCase();
            if (
              (o.replace(a, (t, e) => {
                e && s.push(+e);
              }),
              u === 'm' &&
                s.length > 2 &&
                (n.push([i].concat(s.splice(0, 2))), (u = 'l'), (i = i === 'm' ? 'l' : 'L')),
              u === 'o' && s.length === 1 && n.push([i, s[0]]),
              u === 'r')
            )
              n.push([i].concat(s));
            else for (; s.length >= e[u] && (n.push([i].concat(s.splice(0, e[u]))), e[u]); );
            return t;
          }),
          n
        );
      };
      const u = function (t, e) {
        if (t.length !== e.length) return !1;
        let n = !0;
        return (
          Object(r.c)(t, (t, r) => {
            if (t !== e[r]) return (n = !1), !1;
          }),
          n
        );
      };
      function c(t, e, n) {
        let r = null;
        let i = n;
        return (
          e < i && ((i = e), (r = 'add')), t < i && ((i = t), (r = 'del')), { type: r, min: i }
        );
      }
      var h = function (t, e) {
        const n = (function (t, e) {
          let n;
          let r;
          const i = t.length;
          const o = e.length;
          let a = 0;
          if (i === 0 || o === 0) return null;
          for (var s = [], h = 0; h <= i; h++) (s[h] = []), (s[h][0] = { min: h });
          for (var l = 0; l <= o; l++) s[0][l] = { min: l };
          for (h = 1; h <= i; h++) {
            n = t[h - 1];
            for (l = 1; l <= o; l++) {
              (r = e[l - 1]), (a = u(n, r) ? 0 : 1);
              const f = s[h - 1][l].min + 1;
              const d = s[h][l - 1].min + 1;
              const p = s[h - 1][l - 1].min + a;
              s[h][l] = c(f, d, p);
            }
          }
          return s;
        })(t, e);
        let r = t.length;
        const i = e.length;
        const o = [];
        let a = 1;
        let s = 1;
        if (n[r][i].min !== r) {
          for (var h = 1; h <= r; h++) {
            let l = n[h][h].min;
            s = h;
            for (let f = a; f <= i; f++) n[h][f].min < l && ((l = n[h][f].min), (s = f));
            (a = s), n[h][a].type && o.push({ index: h - 1, type: n[h][a].type });
          }
          for (h = o.length - 1; h >= 0; h--)
            (a = o[h].index),
              o[h].type === 'add' ? t.splice(a, 0, [].concat(t[a])) : t.splice(a, 1);
        }
        const d = i - (r = t.length);
        if (r < i)
          for (h = 0; h < d; h++)
            t[r - 1][0] === 'z' || t[r - 1][0] === 'Z'
              ? t.splice(r - 2, 0, t[r - 2])
              : t.push(t[r - 1]),
              (r += 1);
        return t;
      };
      function l(t, e, n) {
        for (var r, i = [].concat(t), o = 1 / (n + 1), a = f(e)[0], s = 1; s <= n; s++)
          (o *= s),
            (r = Math.floor(t.length * o)) === 0
              ? i.unshift([a[0] * o + t[r][0] * (1 - o), a[1] * o + t[r][1] * (1 - o)])
              : i.splice(r, 0, [a[0] * o + t[r][0] * (1 - o), a[1] * o + t[r][1] * (1 - o)]);
        return i;
      }
      function f(t) {
        const e = [];
        switch (t[0]) {
          case 'M':
          case 'L':
            e.push([t[1], t[2]]);
            break;
          case 'A':
            e.push([t[6], t[7]]);
            break;
          case 'Q':
            e.push([t[3], t[4]]), e.push([t[1], t[2]]);
            break;
          case 'T':
            e.push([t[1], t[2]]);
            break;
          case 'C':
            e.push([t[5], t[6]]), e.push([t[1], t[2]]), e.push([t[3], t[4]]);
            break;
          case 'S':
            e.push([t[3], t[4]]), e.push([t[1], t[2]]);
            break;
          case 'H':
          case 'V':
            e.push([t[1], t[1]]);
        }
        return e;
      }
      var d = function (t, e) {
        if (t.length <= 1) return t;
        for (var n, r = 0; r < e.length; r++)
          if (t[r][0] !== e[r][0])
            switch (((n = f(t[r])), e[r][0])) {
              case 'M':
                t[r] = ['M'].concat(n[0]);
                break;
              case 'L':
                t[r] = ['L'].concat(n[0]);
                break;
              case 'A':
                (t[r] = [].concat(e[r])), (t[r][6] = n[0][0]), (t[r][7] = n[0][1]);
                break;
              case 'Q':
                if (n.length < 2) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = l(n, t[r - 1], 1);
                }
                t[r] = ['Q'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              case 'T':
                t[r] = ['T'].concat(n[0]);
                break;
              case 'C':
                if (n.length < 3) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = l(n, t[r - 1], 2);
                }
                t[r] = ['C'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              case 'S':
                if (n.length < 2) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = l(n, t[r - 1], 1);
                }
                t[r] = ['S'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              default:
                t[r] = e[r];
            }
        return t;
      };
    },
    function (t, e, n) {
      'use strict';
      n.r(e),
        n.d(e, 'getAdjMatrix', () => {
          return r;
        }),
        n.d(e, 'breadthFirstSearch', () => {
          return l;
        }),
        n.d(e, 'connectedComponent', () => {
          return d;
        }),
        n.d(e, 'getDegree', () => {
          return g;
        }),
        n.d(e, 'getInDegree', () => {
          return v;
        }),
        n.d(e, 'getOutDegree', () => {
          return y;
        }),
        n.d(e, 'detectCycle', () => {
          return S;
        }),
        n.d(e, 'detectDirectedCycle', () => {
          return it;
        }),
        n.d(e, 'detectAllCycles', () => {
          return M;
        }),
        n.d(e, 'detectAllDirectedCycle', () => {
          return x;
        }),
        n.d(e, 'detectAllUndirectedCycle', () => {
          return b;
        }),
        n.d(e, 'depthFirstSearch', () => {
          return m;
        }),
        n.d(e, 'dijkstra', () => {
          return C;
        }),
        n.d(e, 'findAllPath', () => {
          return T;
        }),
        n.d(e, 'findShortestPath', () => {
          return k;
        }),
        n.d(e, 'floydWarshall', () => {
          return P;
        }),
        n.d(e, 'labelPropagation', () => {
          return I;
        }),
        n.d(e, 'louvain', () => {
          return j;
        }),
        n.d(e, 'minimumSpanningTree', () => {
          return R;
        }),
        n.d(e, 'pageRank', () => {
          return Y;
        }),
        n.d(e, 'getNeighbors', () => {
          return u;
        }),
        n.d(e, 'Stack', () => {
          return rt;
        }),
        n.d(e, 'GADDI', () => {
          return nt;
        });
      var r = function (t, e) {
        const n = t.nodes;
        const r = t.edges;
        const i = [];
        const o = {};
        if (!n) throw new Error('invalid nodes data!');
        return (
          n &&
            n.forEach((t, e) => {
              o[t.id] = e;
              i.push([]);
            }),
          r &&
            r.forEach((t) => {
              const n = t.source;
              const r = t.target;
              const a = o[n];
              const s = o[r];
              (!a && a !== 0) || (!s && s !== 0) || ((i[a][s] = 1), e || (i[s][a] = 1));
            }),
          i
        );
      };
      const i = function (t, e) {
        return t === e;
      };
      const o = (function () {
        function t(t, e) {
          void 0 === e && (e = null), (this.value = t), (this.next = e);
        }
        return (
          (t.prototype.toString = function (t) {
            return t ? t(this.value) : `${this.value}`;
          }),
          t
        );
      })();
      const a = (function () {
        function t(t) {
          void 0 === t && (t = i), (this.head = null), (this.tail = null), (this.compare = t);
        }
        return (
          (t.prototype.prepend = function (t) {
            const e = new o(t, this.head);
            return (this.head = e), this.tail || (this.tail = e), this;
          }),
          (t.prototype.append = function (t) {
            const e = new o(t);
            return this.head
              ? ((this.tail.next = e), (this.tail = e), this)
              : ((this.head = e), (this.tail = e), this);
          }),
          (t.prototype.delete = function (t) {
            if (!this.head) return null;
            for (var e = null; this.head && this.compare(this.head.value, t); )
              (e = this.head), (this.head = this.head.next);
            let n = this.head;
            if (n !== null)
              for (; n.next; )
                this.compare(n.next.value, t)
                  ? ((e = n.next), (n.next = n.next.next))
                  : (n = n.next);
            return this.compare(this.tail.value, t) && (this.tail = n), e;
          }),
          (t.prototype.find = function (t) {
            const e = t.value;
            const n = void 0 === e ? void 0 : e;
            const r = t.callback;
            const i = void 0 === r ? void 0 : r;
            if (!this.head) return null;
            for (let o = this.head; o; ) {
              if (i && i(o.value)) return o;
              if (void 0 !== n && this.compare(o.value, n)) return o;
              o = o.next;
            }
            return null;
          }),
          (t.prototype.deleteTail = function () {
            const t = this.tail;
            if (this.head === this.tail) return (this.head = null), (this.tail = null), t;
            for (var e = this.head; e.next; ) e.next.next ? (e = e.next) : (e.next = null);
            return (this.tail = e), t;
          }),
          (t.prototype.deleteHead = function () {
            if (!this.head) return null;
            const t = this.head;
            return (
              this.head.next
                ? (this.head = this.head.next)
                : ((this.head = null), (this.tail = null)),
              t
            );
          }),
          (t.prototype.fromArray = function (t) {
            const e = this;
            return (
              t.forEach((t) => {
                return e.append(t);
              }),
              this
            );
          }),
          (t.prototype.toArray = function () {
            for (var t = [], e = this.head; e; ) t.push(e), (e = e.next);
            return t;
          }),
          (t.prototype.reverse = function () {
            for (var t = this.head, e = null, n = null; t; )
              (n = t.next), (t.next = e), (e = t), (t = n);
            (this.tail = this.head), (this.head = e);
          }),
          (t.prototype.toString = function (t) {
            return (
              void 0 === t && (t = void 0),
              this.toArray()
                .map((e) => {
                  return e.toString(t);
                })
                .toString()
            );
          }),
          t
        );
      })();
      const s = (function () {
        function t() {
          this.linkedList = new a();
        }
        return (
          (t.prototype.isEmpty = function () {
            return !this.linkedList.head;
          }),
          (t.prototype.peek = function () {
            return this.linkedList.head ? this.linkedList.head.value : null;
          }),
          (t.prototype.enqueue = function (t) {
            this.linkedList.append(t);
          }),
          (t.prototype.dequeue = function () {
            const t = this.linkedList.deleteHead();
            return t ? t.value : null;
          }),
          (t.prototype.toString = function (t) {
            return this.linkedList.toString(t);
          }),
          t
        );
      })();
      var u = function (t, e, n) {
        void 0 === e && (e = []);
        const r = e.filter((e) => {
          return e.source === t || e.target === t;
        });
        if (n === 'target') {
          return r
            .filter((e) => {
              return e.source === t;
            })
            .map((t) => {
              return t.target;
            });
        }
        if (n === 'source') {
          return r
            .filter((e) => {
              return e.target === t;
            })
            .map((t) => {
              return t.source;
            });
        }
        return r.map((e) => {
          return e.source === t ? e.target : e.source;
        });
      };
      const c = function (t, e) {
        return e.filter((e) => {
          return e.source === t || e.target === t;
        });
      };
      const h = function (t) {
        return (
          void 0 === t && (t = 0),
          `${t}-${`${Math.random()}`.split('.')[1].substr(0, 5)}${`${Math.random()}`
            .split('.')[1]
            .substr(0, 5)}`
        );
      };
      var l = function (t, e, n) {
        const r = (function (t) {
          void 0 === t && (t = {});
          let e;
          const n = t;
          const r = function () {};
          const i =
            ((e = {}),
            function (t) {
              const n = t.next;
              return !e[n] && ((e[n] = !0), !0);
            });
          return (
            (n.allowTraversal = t.allowTraversal || i),
            (n.enter = t.enter || r),
            (n.leave = t.leave || r),
            n
          );
        })(n);
        const i = new s();
        const o = t.edges;
        const a = void 0 === o ? [] : o;
        i.enqueue(e);
        for (
          var c = '',
            h = function () {
              const t = i.dequeue();
              r.enter({ current: t, previous: c }),
                u(t, a, 'target').forEach((e) => {
                  r.allowTraversal({ previous: c, current: t, next: e }) && i.enqueue(e);
                }),
                r.leave({ current: t, previous: c }),
                (c = t);
            };
          !i.isEmpty();

        )
          h();
      };
      const f = function (t) {
        for (
          var e = t.nodes,
            n = void 0 === e ? [] : e,
            r = t.edges,
            i = void 0 === r ? [] : r,
            o = [],
            a = {},
            s = {},
            c = {},
            h = [],
            l = 0,
            f = function t(e) {
              (s[e.id] = l), (c[e.id] = l), (l += 1), o.push(e), (a[e.id] = !0);
              for (
                var r = u(e.id, i, 'target').filter((t) => {
                    return (
                      n
                        .map((t) => {
                          return t.id;
                        })
                        .indexOf(t) > -1
                    );
                  }),
                  f = function (i) {
                    const o = r[i];
                    if (s[o] || s[o] === 0) a[o] && (c[e.id] = Math.min(c[e.id], s[o]));
                    else {
                      const u = n.filter((t) => {
                        return t.id === o;
                      });
                      u.length > 0 && t(u[0]), (c[e.id] = Math.min(c[e.id], c[o]));
                    }
                  },
                  d = 0;
                d < r.length;
                d++
              )
                f(d);
              if (c[e.id] === s[e.id]) {
                for (var p = []; o.length > 0; ) {
                  const g = o.pop();
                  if (((a[g.id] = !1), p.push(g), g === e)) break;
                }
                p.length > 0 && h.push(p);
              }
            },
            d = 0,
            p = n;
          d < p.length;
          d++
        ) {
          const g = p[d];
          s[g.id] || s[g.id] === 0 || f(g);
        }
        return h;
      };
      function d(t, e) {
        return e
          ? f(t)
          : (function (t) {
              for (
                var e = t.nodes,
                  n = void 0 === e ? [] : e,
                  r = t.edges,
                  i = void 0 === r ? [] : r,
                  o = [],
                  a = {},
                  s = [],
                  c = function t(e) {
                    s.push(e), (a[e.id] = !0);
                    for (
                      var r = u(e.id, i),
                        o = function (e) {
                          const i = r[e];
                          if (!a[i]) {
                            const o = n.filter((t) => {
                              return t.id === i;
                            });
                            o.length > 0 && t(o[0]);
                          }
                        },
                        c = 0;
                      c < r.length;
                      ++c
                    )
                      o(c);
                  },
                  h = 0;
                h < n.length;
                h++
              ) {
                const l = n[h];
                if (!a[l.id]) {
                  c(l);
                  for (var f = []; s.length > 0; ) f.push(s.pop());
                  o.push(f);
                }
              }
              return o;
            })(t);
      }
      const p = function (t) {
        const e = {};
        const n = t.nodes;
        const r = void 0 === n ? [] : n;
        const i = t.edges;
        const o = void 0 === i ? [] : i;
        return (
          r.forEach((t) => {
            e[t.id] = { degree: 0, inDegree: 0, outDegree: 0 };
          }),
          o.forEach((t) => {
            e[t.source].degree++,
              e[t.source].outDegree++,
              e[t.target].degree++,
              e[t.target].inDegree++;
          }),
          e
        );
      };
      var g = p;
      var v = function (t, e) {
        return p(t)[e] ? p(t)[e].inDegree : 0;
      };
      var y = function (t, e) {
        return p(t)[e] ? p(t)[e].outDegree : 0;
      };
      function m(t, e, n) {
        !(function t(e, n, r, i) {
          i.enter({ current: n, previous: r });
          const o = e.edges;
          u(n, void 0 === o ? [] : o, 'target').forEach((o) => {
            i.allowTraversal({ previous: r, current: n, next: o }) && t(e, o, n, i);
          }),
            i.leave({ current: n, previous: r });
        })(
          t,
          e,
          '',
          (function (t) {
            void 0 === t && (t = {});
            let e;
            const n = t;
            const r = function () {};
            const i =
              ((e = {}),
              function (t) {
                const n = t.next;
                return !e[n] && ((e[n] = !0), !0);
              });
            return (
              (n.allowTraversal = t.allowTraversal || i),
              (n.enter = t.enter || r),
              (n.leave = t.leave || r),
              n
            );
          })(n),
        );
      }
      var b = function (t, e, n) {
        let r;
        let i;
        void 0 === n && (n = !0);
        for (var o = [], a = 0, s = d(t, !1); a < s.length; a++) {
          const c = s[a];
          if (c.length)
            for (
              var h = c[0],
                l = h.id,
                f = [h],
                p = (((r = {})[l] = h), r),
                g = (((i = {})[l] = new Set()), i);
              f.length > 0;

            )
              for (
                var v = f.pop(),
                  y = v.id,
                  m = u(y, t.edges),
                  b = function (r) {
                    let i;
                    const a = m[r];
                    const s = t.nodes.find((t) => {
                      return t.id === a;
                    });
                    if (a === y) o.push((((i = {})[a] = v), i));
                    else if ((a in g)) {
                      if (!g[y].has(s)) {
                        for (
                          var u = !0, c = [s, v], h = p[y];
                          g[a].size && !g[a].has(h) && (c.push(h), h !== p[h.id]);

                        )
                          h = p[h.id];
                        if (
                          (c.push(h),
                          e && n
                            ? ((u = !1),
                              c.findIndex((t) => {
                                return e.indexOf(t.id) > -1;
                              }) > -1 && (u = !0))
                            : e &&
                              !n &&
                              c.findIndex((t) => {
                                return e.indexOf(t.id) > -1;
                              }) > -1 &&
                              (u = !1),
                          u)
                        ) {
                          for (var l = {}, d = 1; d < c.length; d += 1) l[c[d - 1].id] = c[d];
                          c.length && (l[c[c.length - 1].id] = c[0]), o.push(l);
                        }
                        g[a].add(v);
                      }
                    } else (p[a] = v), f.push(s), (g[a] = new Set([v]));
                  },
                  x = 0;
                x < m.length;
                x += 1
              )
                b(x);
        }
        return o;
      };
      var x = function (t, e, n) {
        void 0 === n && (n = !0);
        for (
          var r = [],
            i = new Set(),
            o = [],
            a = [],
            s = {},
            c = {},
            h = function t(u, c, h) {
              let l = !1;
              if (e && !1 === n && e.indexOf(u.id) > -1) return l;
              r.push(u), i.add(u);
              for (var f = h[u.id], d = 0; d < f.length; d += 1) {
                if ((v = s[f[d]]) === c) {
                  for (var p = {}, g = 1; g < r.length; g += 1) p[r[g - 1].id] = r[g];
                  r.length && (p[r[r.length - 1].id] = r[0]), a.push(p), (l = !0);
                } else i.has(v) || (t(v, c, h) && (l = !0));
              }
              if (l)
                !(function (t) {
                  for (var e = [t]; e.length > 0; ) {
                    const n = e.pop();
                    i.has(n) &&
                      (i.delete(n),
                      o[n.id].forEach((t) => {
                        e.push(t);
                      }),
                      o[n.id].clear());
                  }
                })(u);
              else
                for (d = 0; d < f.length; d += 1) {
                  var v = s[f[d]];
                  o[v.id].has(u) || o[v.id].add(u);
                }
              return r.pop(), l;
            },
            l = t.nodes,
            d = void 0 === l ? [] : l,
            p = 0;
          p < d.length;
          p += 1
        ) {
          const g = d[p];
          const v = g.id;
          (c[v] = p), (s[p] = g);
        }
        if (e && n) {
          const y = function (t) {
            const n = e[t];
            (c[d[t].id] = c[n]),
              (c[n] = 0),
              (s[0] = d.find((t) => {
                return t.id === n;
              })),
              (s[c[d[t].id]] = d[t]);
          };
          for (p = 0; p < e.length; p++) y(p);
        }
        for (
          var m = function (r) {
              for (var i, o, s = 1 / 0, h = 0; h < r.length; h += 1)
                for (let l = r[h], f = 0; f < l.length; f++) {
                  const d = c[l[f].id];
                  d < s && ((s = d), (o = h));
                }
              const p = r[o];
              const g = [];
              for (h = 0; h < p.length; h += 1) {
                const v = p[h];
                g[v.id] = [];
                for (
                  let y = 0,
                    m = u(v.id, t.edges, 'target').filter((t) => {
                      return (
                        p
                          .map((t) => {
                            return t.id;
                          })
                          .indexOf(t) > -1
                      );
                    });
                  y < m.length;
                  y++
                ) {
                  const b = m[y];
                  b !== v.id || (!1 === n && e.indexOf(v.id) > -1)
                    ? g[v.id].push(c[b])
                    : a.push((((i = {})[v.id] = v), i));
                }
              }
              return { component: p, adjList: g, minIdx: s };
            },
            b = 0;
          b < d.length;

        ) {
          const x = d.filter((t) => {
            return c[t.id] >= b;
          });
          const M = f({ nodes: x, edges: t.edges }).filter((t) => {
            return t.length > 1;
          });
          if (M.length === 0) break;
          const S = m(M);
          const w = S.minIdx;
          const O = S.adjList;
          const C = S.component;
          if (!(C.length > 1)) break;
          C.forEach((t) => {
            o[t.id] = new Set();
          });
          const E = s[w];
          if (e && n && e.indexOf(E.id) === -1) return a;
          h(E, E, O), (b = w + 1);
        }
        return a;
      };
      var M = function (t, e, n, r) {
        return void 0 === r && (r = !0), e ? x(t, n, r) : b(t, n, r);
      };
      var S = function (t) {
        let e = null;
        const n = t.nodes;
        const r = {};
        const i = {};
        const o = {};
        const a = {};
        (void 0 === n ? [] : n).forEach((t) => {
          i[t.id] = t;
        });
        for (
          let s = {
            enter(t) {
              const n = t.current;
              const a = t.previous;
              if (o[n]) {
                e = {};
                for (var s = n, u = a; u !== n; ) (e[s] = u), (s = u), (u = r[u]);
                e[s] = u;
              } else (o[n] = n), delete i[n], (r[n] = a);
            },
            leave(t) {
              const e = t.current;
              (a[e] = e), delete o[e];
            },
            allowTraversal(t) {
              const n = t.next;
              return !e && !a[n];
            },
          };
          Object.keys(i).length;

        ) {
          m(t, Object.keys(i)[0], s);
        }
        return e;
      };
      const w = n(1);
      const O = n(0);
      var C = function (t, e, n, r) {
        const i = t.nodes;
        const o = void 0 === i ? [] : i;
        const a = t.edges;
        const s = void 0 === a ? [] : a;
        const u = [];
        const h = {};
        const l = {};
        const f = {};
        o.forEach((t, n) => {
          const r = t.id;
          u.push(r), (l[r] = 1 / 0), r === e && (l[r] = 0);
        });
        for (
          let d = o.length,
            p = function (t) {
              const e = (function (t, e, n) {
                for (var r, i = 1 / 0, o = 0; o < e.length; o++) {
                  const a = e[o].id;
                  !n[a] && t[a] <= i && ((i = t[a]), (r = e[o]));
                }
                return r;
              })(l, o, h);
              const i = e.id;
              if (((h[i] = !0), l[i] === 1 / 0)) return 'continue';
              (n
                ? (function (t, e) {
                    return e.filter((e) => {
                      return e.source === t;
                    });
                  })(i, s)
                : c(i, s)
              ).forEach((t) => {
                const n = t.target;
                const o = t.source;
                const a = n === i ? o : n;
                const s = r && t[r] ? t[r] : 1;
                l[a] > l[e.id] + s
                  ? ((l[a] = l[e.id] + s), (f[a] = [e.id]))
                  : l[a] === l[e.id] + s && f[a].push(e.id);
              });
            },
            g = 0;
          g < d;
          g++
        )
          p();
        f[e] = [e];
        const v = {};
        for (var y in l) l[y] !== 1 / 0 && E(e, y, f, v);
        const m = {};
        for (var y in v) m[y] = v[y][0];
        return { length: l, path: m, allPath: v };
      };
      function E(t, e, n, r) {
        if (t === e) return [t];
        if (r[e]) return r[e];
        for (var i = [], o = 0, a = n[e]; o < a.length; o++) {
          const s = E(t, a[o], n, r);
          if (!s) return;
          for (let u = 0, c = s; u < c.length; u++) {
            const h = c[u];
            Object(O.f)(h) ? i.push(Object(w.f)(Object(w.f)([], h), [e])) : i.push([h, e]);
          }
        }
        return (r[e] = i), r[e];
      }
      var k = function (t, e, n, r, i) {
        const o = C(t, e, r, i);
        const a = o.length;
        const s = o.path;
        const u = o.allPath;
        return { length: a[n], path: s[n], allPath: u[n] };
      };
      var T = function (t, e, n, r) {
        let i;
        if (e === n) return [[e]];
        const o = t.edges;
        const a = void 0 === o ? [] : o;
        const s = [e];
        const c = (((i = {})[e] = !0), i);
        const h = [];
        const l = [];
        let f = r ? u(e, a, 'target') : u(e, a);
        for (h.push(f); s.length > 0 && h.length > 0; ) {
          const d = h[h.length - 1];
          if (d.length) {
            const p = d.shift();
            if (
              (p &&
                (s.push(p),
                (c[p] = !0),
                (f = r ? u(p, a, 'target') : u(p, a)),
                h.push(
                  f.filter((t) => {
                    return !c[t];
                  }),
                )),
              s[s.length - 1] === n)
            ) {
              const g = s.map((t) => {
                return t;
              });
              l.push(g);
              v = s.pop();
              (c[v] = !1), h.pop();
            }
          } else {
            var v = s.pop();
            (c[v] = !1), h.pop();
          }
        }
        return l;
      };
      var P = function (t, e) {
        for (var n = r(t, e), i = [], o = n.length, a = 0; a < o; a += 1) {
          i[a] = [];
          for (var s = 0; s < o; s += 1)
            a === s
              ? (i[a][s] = 0)
              : n[a][s] !== 0 && n[a][s]
              ? (i[a][s] = n[a][s])
              : (i[a][s] = 1 / 0);
        }
        for (let u = 0; u < o; u += 1)
          for (a = 0; a < o; a += 1)
            for (s = 0; s < o; s += 1) i[a][s] > i[a][u] + i[u][s] && (i[a][s] = i[a][u] + i[u][s]);
        return i;
      };
      var I = function (t, e, n, i) {
        void 0 === e && (e = !1), void 0 === n && (n = 'weight'), void 0 === i && (i = 1e3);
        const o = t.nodes;
        const a = void 0 === o ? [] : o;
        const s = t.edges;
        const u = void 0 === s ? [] : s;
        const c = {};
        const l = {};
        a.forEach((t, e) => {
          const n = h();
          (t.clusterId = n), (c[n] = { id: n, nodes: [t] }), (l[t.id] = { node: t, idx: e });
        });
        const f = r(t, e);
        const d = [];
        const p = {};
        f.forEach((t, e) => {
          let n = 0;
          const r = a[e].id;
          (p[r] = {}),
            t.forEach((t, e) => {
              if (t) {
                n += t;
                const i = a[e].id;
                p[r][i] = t;
              }
            }),
            d.push(n);
        });
        for (
          var g = 0,
            v = function () {
              let t = !1;
              if (
                (a.forEach((e) => {
                  const n = {};
                  Object.keys(p[e.id]).forEach((t) => {
                    const r = p[e.id][t];
                    const i = l[t].node.clusterId;
                    n[i] || (n[i] = 0), (n[i] += r);
                  });
                  let r = -1 / 0;
                  let i = [];
                  if (
                    (Object.keys(n).forEach((t) => {
                      r < n[t] ? ((r = n[t]), (i = [t])) : r === n[t] && i.push(t);
                    }),
                    i.length !== 1 || i[0] !== e.clusterId)
                  ) {
                    const o = i.indexOf(e.clusterId);
                    if ((o >= 0 && i.splice(o, 1), i && i.length)) {
                      t = !0;
                      const a = c[e.clusterId];
                      const s = a.nodes.indexOf(e);
                      a.nodes.splice(s, 1);
                      const u = Math.floor(Math.random() * i.length);
                      const h = c[i[u]];
                      h.nodes.push(e), (e.clusterId = h.id);
                    }
                  }
                }),
                !t)
              )
                return 'break';
              g++;
            };
          g < i;

        ) {
          if (v() === 'break') break;
        }
        Object.keys(c).forEach((t) => {
          const e = c[t];
          (e.nodes && e.nodes.length) || delete c[t];
        });
        const y = [];
        const m = {};
        u.forEach((t) => {
          const e = t.source;
          const r = t.target;
          const i = t[n] || 1;
          const o = l[e].node.clusterId;
          const a = l[r].node.clusterId;
          const s = `${o}---${a}`;
          if (m[s]) (m[s].weight += i), m[s].count++;
          else {
            const u = { source: o, target: a, weight: i, count: 1 };
            (m[s] = u), y.push(u);
          }
        });
        const b = [];
        return (
          Object.keys(c).forEach((t) => {
            b.push(c[t]);
          }),
          { clusters: b, clusterEdges: y }
        );
      };
      const A = function (t, e, n, r) {
        for (var i = e.length, o = 2 * r, a = 0, s = 0; s < i; s++)
          for (let u = t[s].clusterId, c = 0; c < i; c++) {
            if (u === t[c].clusterId) a += (e[s][c] || 0) - ((n[s] || 0) * (n[c] || 0)) / o;
          }
        return (a *= 1 / o);
      };
      var j = function (t, e, n, i) {
        void 0 === e && (e = !1), void 0 === n && (n = 'weight'), void 0 === i && (i = 1e-4);
        const o = t.nodes;
        const a = void 0 === o ? [] : o;
        const s = t.edges;
        const u = void 0 === s ? [] : s;
        let c = 1;
        const h = {};
        const l = {};
        a.forEach((t, e) => {
          const n = String(c++);
          (t.clusterId = n), (h[n] = { id: n, nodes: [t] }), (l[t.id] = { node: t, idx: e });
        });
        const f = r(t, e);
        const d = [];
        const p = {};
        let g = 0;
        f.forEach((t, e) => {
          let n = 0;
          const r = a[e].id;
          (p[r] = {}),
            t.forEach((t, e) => {
              if (t) {
                n += t;
                const i = a[e].id;
                (p[r][i] = t), (g += t);
              }
            }),
            d.push(n);
        }),
          (g /= 2);
        for (
          let v = 1 / 0, y = 1 / 0, m = 0;
          (v = A(a, f, d, g)), !(Math.abs(v - y) < i || m > 100);

        )
          (y = v),
            m++,
            Object.keys(h).forEach((t) => {
              let e = 0;
              u.forEach((r) => {
                const i = r.source;
                const o = r.target;
                const a = l[i].node.clusterId;
                const s = l[o].node.clusterId;
                ((a === t && s !== t) || (s === t && a !== t)) && (e += r[n] || 1);
              }),
                (h[t].sumTot = e);
            }),
            a.forEach((t, e) => {
              let r;
              const i = h[t.clusterId];
              let o = 0;
              const a = d[e] / (2 * g);
              let s = 0;
              i.nodes.forEach((t) => {
                const n = l[t.id].idx;
                s += f[e][n] || 0;
              });
              const c = s - i.sumTot * a;
              const v = p[t.id];
              if (
                (Object.keys(v).forEach((n) => {
                  const i = l[n].node.clusterId;
                  if (i !== t.clusterId) {
                    const s = h[i];
                    const u = s.nodes;
                    if (u && u.length) {
                      let d = 0;
                      u.forEach((t) => {
                        const n = l[t.id].idx;
                        d += f[e][n] || 0;
                      });
                      const p = d - s.sumTot * a - c;
                      p > o && ((o = p), (r = s));
                    }
                  }
                }),
                o > 0)
              ) {
                r.nodes.push(t);
                const y = t.clusterId;
                t.clusterId = r.id;
                const m = i.nodes.indexOf(t);
                i.nodes.splice(m, 1);
                let b = 0;
                let x = 0;
                u.forEach((t) => {
                  const e = t.source;
                  const i = t.target;
                  const o = l[e].node.clusterId;
                  const a = l[i].node.clusterId;
                  ((o === r.id && a !== r.id) || (a === r.id && o !== r.id)) && (b += t[n] || 1),
                    ((o === y && a !== y) || (a === y && o !== y)) && (x += t[n] || 1);
                }),
                  (r.sumTot = b),
                  (i.sumTot = x);
              }
            });
        const b = {};
        let x = 0;
        Object.keys(h).forEach((t) => {
          const e = h[t];
          if (e.nodes && e.nodes.length) {
            const n = String(x + 1);
            n !== t &&
              ((e.id = n),
              (e.nodes = e.nodes.map((t) => {
                return { id: t.id, clusterId: n };
              })),
              (h[n] = e),
              (b[t] = n),
              delete h[t],
              x++);
          } else delete h[t];
        }),
          a.forEach((t) => {
            t.clusterId && b[t.clusterId] && (t.clusterId = b[t.clusterId]);
          });
        const M = [];
        const S = {};
        u.forEach((t) => {
          const e = t.source;
          const r = t.target;
          const i = t[n] || 1;
          const o = l[e].node.clusterId;
          const a = l[r].node.clusterId;
          const s = `${o}---${a}`;
          if (S[s]) (S[s].weight += i), S[s].count++;
          else {
            const u = { source: o, target: a, weight: i, count: 1 };
            (S[s] = u), M.push(u);
          }
        });
        const w = [];
        return (
          Object.keys(h).forEach((t) => {
            w.push(h[t]);
          }),
          { clusters: w, clusterEdges: M }
        );
      };
      const N = (function () {
        function t(t) {
          (this.count = t.length), (this.parent = {});
          for (let e = 0, n = t; e < n.length; e++) {
            const r = n[e];
            this.parent[r] = r;
          }
        }
        return (
          (t.prototype.find = function (t) {
            for (; this.parent[t] !== t; ) t = this.parent[t];
            return t;
          }),
          (t.prototype.union = function (t, e) {
            const n = this.find(t);
            const r = this.find(e);
            n !== r &&
              (n < r
                ? (this.parent[e] !== e && this.union(this.parent[e], t),
                  (this.parent[e] = this.parent[t]))
                : (this.parent[t] !== t && this.union(this.parent[t], e),
                  (this.parent[t] = this.parent[e])));
          }),
          (t.prototype.connected = function (t, e) {
            return this.find(t) === this.find(e);
          }),
          t
        );
      })();
      const _ = function (t, e) {
        return t - e;
      };
      const B = (function () {
        function t(t) {
          void 0 === t && (t = _), (this.compareFn = t), (this.list = []);
        }
        return (
          (t.prototype.getLeft = function (t) {
            return 2 * t + 1;
          }),
          (t.prototype.getRight = function (t) {
            return 2 * t + 2;
          }),
          (t.prototype.getParent = function (t) {
            return t === 0 ? null : Math.floor((t - 1) / 2);
          }),
          (t.prototype.isEmpty = function () {
            return this.list.length <= 0;
          }),
          (t.prototype.top = function () {
            return this.isEmpty() ? void 0 : this.list[0];
          }),
          (t.prototype.delMin = function () {
            const t = this.top();
            const e = this.list.pop();
            return this.list.length > 0 && ((this.list[0] = e), this.moveDown(0)), t;
          }),
          (t.prototype.insert = function (t) {
            if (t !== null) {
              this.list.push(t);
              const e = this.list.length - 1;
              return this.moveUp(e), !0;
            }
            return !1;
          }),
          (t.prototype.moveUp = function (t) {
            for (
              let e = this.getParent(t);
              t && t > 0 && this.compareFn(this.list[e], this.list[t]) > 0;

            ) {
              const n = this.list[e];
              (this.list[e] = this.list[t]), (this.list[t] = n), (t = e), (e = this.getParent(t));
            }
          }),
          (t.prototype.moveDown = function (t) {
            let e;
            let n = t;
            const r = this.getLeft(t);
            const i = this.getRight(t);
            const o = this.list.length;
            r !== null && r < o && this.compareFn(this.list[n], this.list[r]) > 0
              ? (n = r)
              : i !== null && i < o && this.compareFn(this.list[n], this.list[i]) > 0 && (n = i),
              t !== n &&
                ((e = [this.list[n], this.list[t]]),
                (this.list[t] = e[0]),
                (this.list[n] = e[1]),
                this.moveDown(n));
          }),
          t
        );
      })();
      const L = function (t, e) {
        const n = [];
        const r = t.nodes;
        const i = void 0 === r ? [] : r;
        const o = t.edges;
        const a = void 0 === o ? [] : o;
        if (i.length === 0) return n;
        const s = i[0];
        const u = new Set();
        u.add(s);
        const h = new B((t, n) => {
          return e ? t.weight - n.weight : 0;
        });
        for (
          c(s.id, a).forEach((t) => {
            h.insert(t);
          });
          !h.isEmpty();

        ) {
          const l = h.delMin();
          const f = l.source;
          const d = l.target;
          (u.has(f) && u.has(d)) ||
            (n.push(l),
            u.has(f) ||
              (u.add(f),
              c(f, a).forEach((t) => {
                h.insert(t);
              })),
            u.has(d) ||
              (u.add(d),
              c(d, a).forEach((t) => {
                h.insert(t);
              })));
        }
        return n;
      };
      const D = function (t, e) {
        const n = [];
        const r = t.nodes;
        const i = void 0 === r ? [] : r;
        const o = t.edges;
        const a = void 0 === o ? [] : o;
        if (i.length === 0) return n;
        const s = a.map((t) => {
          return t;
        });
        e &&
          s.sort((t, e) => {
            return t.weight - e.weight;
          });
        for (
          let u = new N(
            i.map((t) => {
              return t.id;
            }),
          );
          s.length > 0;

        ) {
          const c = s.shift();
          const h = c.source;
          const l = c.target;
          u.connected(h, l) || (n.push(c), u.union(h, l));
        }
        return n;
      };
      var R = function (t, e, n) {
        return n ? { prim: L, kruskal: D }[n](t, e) : D(t, e);
      };
      var Y = function (t, e, n) {
        typeof e !== 'number' && (e = 1e-6), typeof n !== 'number' && (n = 0.85);
        for (
          var r,
            i = 1,
            o = 0,
            a = 1e3,
            s = t.nodes,
            c = void 0 === s ? [] : s,
            h = t.edges,
            l = void 0 === h ? [] : h,
            f = c.length,
            d = {},
            p = {},
            v = 0;
          v < f;
          ++v
        ) {
          (d[(m = (w = c[v]).id)] = 1 / f), (p[m] = 1 / f);
        }
        for (let y = g(t); a > 0 && i > e; ) {
          o = 0;
          for (v = 0; v < f; ++v) {
            var m = (w = c[v]).id;
            if (((r = 0), y[w.id].inDegree === 0)) d[m] = 0;
            else {
              for (let b = u(m, l, 'source'), x = 0; x < b.length; ++x) {
                const M = b[x];
                const S = y[M].outDegree;
                S > 0 && (r += p[M] / S);
              }
              (d[m] = n * r), (o += d[m]);
            }
          }
          (o = (1 - o) / f), (i = 0);
          for (v = 0; v < f; ++v) {
            var w;
            (r = d[(m = (w = c[v]).id)] + o), (i += Math.abs(r - p[m])), (p[m] = r);
          }
          a -= 1;
        }
        return p;
      };
      const F = function (t, e, n, r) {
        void 0 === t && (t = -1),
          void 0 === e && (e = -1),
          void 0 === n && (n = -1),
          void 0 === r && (r = '-1'),
          (this.id = t),
          (this.from = e),
          (this.to = n),
          (this.label = r);
      };
      const X = (function () {
        function t(t, e) {
          void 0 === t && (t = -1),
            void 0 === e && (e = '-1'),
            (this.id = t),
            (this.label = e),
            (this.edges = []),
            (this.edgeMap = {});
        }
        return (
          (t.prototype.addEdge = function (t) {
            this.edges.push(t), (this.edgeMap[t.id] = t);
          }),
          t
        );
      })();
      const z = (function () {
        function t(t, e, n) {
          void 0 === t && (t = -1),
            void 0 === e && (e = !0),
            void 0 === n && (n = !1),
            (this.id = t),
            (this.edgeIdAutoIncrease = e),
            (this.edges = []),
            (this.nodes = []),
            (this.nodeMap = {}),
            (this.edgeMap = {}),
            (this.nodeLabelMap = {}),
            (this.edgeLabelMap = {}),
            (this.counter = 0),
            (this.directed = n);
        }
        return (
          (t.prototype.getNodeNum = function () {
            return this.nodes.length;
          }),
          (t.prototype.addNode = function (t, e) {
            if (!this.nodeMap[t]) {
              const n = new X(t, e);
              this.nodes.push(n),
                (this.nodeMap[t] = n),
                this.nodeLabelMap[e] || (this.nodeLabelMap[e] = []),
                this.nodeLabelMap[e].push(t);
            }
          }),
          (t.prototype.addEdge = function (t, e, n, r) {
            if (
              ((this.edgeIdAutoIncrease || void 0 === t) && (t = this.counter++),
              !(this.nodeMap[e] && this.nodeMap[n] && this.nodeMap[n].edgeMap[t]))
            ) {
              const i = new F(t, e, n, r);
              if (
                (this.edges.push(i),
                (this.edgeMap[t] = i),
                this.nodeMap[e].addEdge(i),
                this.edgeLabelMap[r] || (this.edgeLabelMap[r] = []),
                this.edgeLabelMap[r].push(i),
                !this.directed)
              ) {
                const o = new F(t, n, e, r);
                this.nodeMap[n].addEdge(o), this.edgeLabelMap[r].push(o);
              }
            }
          }),
          t
        );
      })();
      const W = (function () {
        function t(t, e, n, r, i) {
          (this.fromNode = t),
            (this.toNode = e),
            (this.nodeEdgeNodeLabel = {
              nodeLabel1: n || '-1',
              edgeLabel: r || '-1',
              nodeLabel2: i || '-1',
            });
        }
        return (
          (t.prototype.equalTo = function (t) {
            return (
              this.fromNode === t.formNode &&
              this.toNode === t.toNode &&
              this.nodeEdgeNodeLabel === t.nodeEdgeNodeLabel
            );
          }),
          (t.prototype.notEqualTo = function (t) {
            return !this.equalTo(t);
          }),
          t
        );
      })();
      const G = (function () {
        function t() {
          (this.rmpath = []), (this.dfsEdgeList = []);
        }
        return (
          (t.prototype.equalTo = function (t) {
            const e = this.dfsEdgeList.length;
            if (e !== t.length) return !1;
            for (let n = 0; n < e; n++) if (this.dfsEdgeList[n] !== t[n]) return !1;
            return !0;
          }),
          (t.prototype.notEqualTo = function (t) {
            return !this.equalTo(t);
          }),
          (t.prototype.pushBack = function (t, e, n, r, i) {
            return this.dfsEdgeList.push(new W(t, e, n, r, i)), this.dfsEdgeList;
          }),
          (t.prototype.toGraph = function (t, e) {
            void 0 === t && (t = -1), void 0 === e && (e = !1);
            const n = new z(t, !0, e);
            return (
              this.dfsEdgeList.forEach((t) => {
                const e = t.fromNode;
                const r = t.toNode;
                const i = t.nodeEdgeNodeLabel;
                const o = i.nodeLabel1;
                const a = i.edgeLabel;
                const s = i.nodeLabel2;
                o !== '-1' && n.addNode(e, o),
                  s !== '-1' && n.addNode(r, s),
                  n.addEdge(void 0, e, r, a);
              }),
              n
            );
          }),
          (t.prototype.buildRmpath = function () {
            this.rmpath = [];
            for (let t = void 0, e = this.dfsEdgeList.length - 1; e >= 0; e--) {
              const n = this.dfsEdgeList[e];
              const r = n.fromNode;
              const i = n.toNode;
              r < i && (void 0 === t || i === t) && (this.rmpath.push(e), (t = r));
            }
            return this.rmpath;
          }),
          (t.prototype.getNodeNum = function () {
            const t = {};
            return (
              this.dfsEdgeList.forEach((e) => {
                t[e.fromNode] || (t[e.fromNode] = !0), t[e.toNode] || (t[e.toNode] = !0);
              }),
              Object.keys(t).length
            );
          }),
          t
        );
      })();
      const U = (function () {
        function t(t) {
          if (
            ((this.his = {}), (this.nodesUsed = {}), (this.edgesUsed = {}), (this.edges = []), t)
          ) {
            for (; t; ) {
              const e = t.edge;
              this.edges.push(e),
                (this.nodesUsed[e.from] = 1),
                (this.nodesUsed[e.to] = 1),
                (this.edgesUsed[e.id] = 1),
                (t = t.preNode);
            }
            this.edges = this.edges.reverse();
          }
        }
        return (
          (t.prototype.hasNode = function (t) {
            return this.nodesUsed[t.id] === 1;
          }),
          (t.prototype.hasEdge = function (t) {
            return this.edgesUsed[t.id] === 1;
          }),
          t
        );
      })();
      const H = (function () {
        function t(t) {
          const e = t.graphs;
          const n = t.minSupport;
          const r = void 0 === n ? 2 : n;
          const i = t.minNodeNum;
          const o = void 0 === i ? 1 : i;
          const a = t.maxNodeNum;
          const s = void 0 === a ? 4 : a;
          const u = t.top;
          const c = void 0 === u ? 10 : u;
          const h = t.directed;
          const l = void 0 !== h && h;
          const f = t.verbose;
          const d = void 0 !== f && f;
          (this.graphs = e),
            (this.dfsCode = new G()),
            (this.support = 0),
            (this.frequentSize1Subgraphs = []),
            (this.frequentSubgraphs = []),
            (this.minSupport = r),
            (this.top = c),
            (this.directed = l),
            (this.counter = 0),
            (this.maxNodeNum = s),
            (this.minNodeNum = o),
            (this.verbose = d),
            this.maxNodeNum < this.minNodeNum && (this.maxNodeNum = this.minNodeNum),
            (this.reportDF = []);
        }
        return (
          (t.prototype.findForwardRootEdges = function (t, e) {
            const n = this;
            const r = [];
            const i = t.nodeMap;
            return (
              e.edges.forEach((t) => {
                (n.directed || e.label <= i[t.to].label) && r.push(t);
              }),
              r
            );
          }),
          (t.prototype.findBackwardEdge = function (t, e, n, r) {
            if (!this.directed && e === n) return null;
            for (let i = t.nodeMap, o = i[n.to].edges, a = o.length, s = 0; s < a; s++) {
              const u = o[s];
              if (!r.hasEdge(u) && u.to === e.from)
                if (this.directed) {
                  if (
                    i[e.from].label < i[n.to].label ||
                    (i[e.from].label === i[n.to].label && e.label <= u.label)
                  )
                    return u;
                } else if (
                  e.label < u.label ||
                  (e.label === u.label && i[e.to].label <= i[n.to].label)
                )
                  return u;
            }
            return null;
          }),
          (t.prototype.findForwardPureEdges = function (t, e, n, r) {
            for (var i = [], o = e.to, a = t.nodeMap[o].edges, s = a.length, u = 0; u < s; u++) {
              const c = a[u];
              const h = t.nodeMap[c.to];
              n <= h.label && !r.hasNode(h) && i.push(c);
            }
            return i;
          }),
          (t.prototype.findForwardRmpathEdges = function (t, e, n, r) {
            for (
              var i = [],
                o = t.nodeMap,
                a = o[e.to].label,
                s = o[e.from].edges,
                u = s.length,
                c = 0;
              c < u;
              c++
            ) {
              const h = s[c];
              const l = o[h.to].label;
              e.to === h.to ||
                n > l ||
                r.hasNode(o[h.to]) ||
                ((e.label < h.label || (e.label === h.label && a <= l)) && i.push(h));
            }
            return i;
          }),
          (t.prototype.getSupport = function (t) {
            const e = {};
            return (
              t.forEach((t) => {
                e[t.graphId] || (e[t.graphId] = !0);
              }),
              Object.keys(e).length
            );
          }),
          (t.prototype.findMinLabel = function (t) {
            let e = void 0;
            return (
              Object.keys(t).forEach((n) => {
                const r = t[n];
                const i = r.nodeLabel1;
                const o = r.edgeLabel;
                const a = r.nodeLabel2;
                e
                  ? (i < e.nodeLabel1 ||
                      (i === e.nodeLabel1 && o < e.edgeLabel) ||
                      (i === e.nodeLabel1 && o === e.edgeLabel && a < e.nodeLabel2)) &&
                    (e = { nodeLabel1: i, edgeLabel: o, nodeLabel2: a })
                  : (e = { nodeLabel1: i, edgeLabel: o, nodeLabel2: a });
              }),
              e
            );
          }),
          (t.prototype.isMin = function () {
            const t = this;
            const e = this.dfsCode;
            if ((this.verbose && console.log('isMin checking', e), e.dfsEdgeList.length === 1))
              return !0;
            const n = this.directed;
            const r = e.toGraph(-1, n);
            const i = r.nodeMap;
            const o = new G();
            const a = {};
            r.nodes.forEach((e) => {
              t.findForwardRootEdges(r, e).forEach((t) => {
                const n = i[t.to];
                const o = `${e.label}-${t.label}-${n.label}`;
                a[o] ||
                  (a[o] = {
                    projected: [],
                    nodeLabel1: e.label,
                    edgeLabel: t.label,
                    nodeLabel2: n.label,
                  });
                const s = { graphId: r.id, edge: t, preNode: null };
                a[o].projected.push(s);
              });
            });
            const s = this.findMinLabel(a);
            o.dfsEdgeList.push(new W(0, 1, s.nodeLabel1, s.edgeLabel, s.nodeLabel2));
            const u = `${s.nodeLabel1}-${s.edgeLabel}-${s.nodeLabel2}`;
            return (function a(s) {
              for (
                var u = o.buildRmpath(),
                  c = o.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1,
                  h = o.dfsEdgeList[u[0]].toNode,
                  l = {},
                  f = !1,
                  d = 0,
                  p = n ? -1 : 0,
                  g = function (e) {
                    if (f) return 'break';
                    s.forEach((n) => {
                      const i = new U(n);
                      const a = t.findBackwardEdge(r, i.edges[u[e]], i.edges[u[0]], i);
                      a &&
                        (l[a.label] || (l[a.label] = { projected: [], edgeLabel: a.label }),
                        l[a.label].projected.push({ graphId: r.id, edge: l, preNode: n }),
                        (d = o.dfsEdgeList[u[e]].fromNode),
                        (f = !0));
                    });
                  },
                  v = u.length - 1;
                v > p;
                v--
              ) {
                if (g(v) === 'break') break;
              }
              if (f) {
                const y = t.findMinLabel(l);
                o.dfsEdgeList.push(new W(h, d, '-1', y.edgeLabel, '-1'));
                const m = o.dfsEdgeList.length - 1;
                return t.dfsCode.dfsEdgeList[m] === o.dfsEdgeList[m] && a(l[y.edgeLabel].projected);
              }
              const b = {};
              f = !1;
              let x = 0;
              s.forEach((e) => {
                const n = new U(e);
                const o = t.findForwardPureEdges(r, n.edges[u[0]], c, n);
                o.length > 0 &&
                  ((f = !0),
                  (x = h),
                  o.forEach((t) => {
                    const n = `${t.label}-${i[t.to].label}`;
                    b[n] ||
                      (b[n] = { projected: [], edgeLabel: t.label, nodeLabel2: i[t.to].label }),
                      b[n].projected.push({ graphId: r.id, edge: t, preNode: e });
                  }));
              });
              const M = u.length;
              const S = function (e) {
                if (f) return 'break';
                const n = u[e];
                s.forEach((e) => {
                  const a = new U(e);
                  const s = t.findForwardRmpathEdges(r, a.edges[n], c, a);
                  s.length > 0 &&
                    ((f = !0),
                    (x = o.dfsEdgeList[n].fromNode),
                    s.forEach((t) => {
                      const n = `${t.label}-${i[t.to].label}`;
                      b[n] ||
                        (b[n] = { projected: [], edgeLabel: t.label, nodeLabel2: i[t.to].label }),
                        b[n].projected.push({ graphId: r.id, edge: t, preNode: e });
                    }));
                });
              };
              for (v = 0; v < M; v++) {
                if (S(v) === 'break') break;
              }
              if (!f) return !0;
              const w = t.findMinLabel(b);
              o.dfsEdgeList.push(new W(x, h + 1, '-1', w.edgeLabel, w.nodeLabel2));
              const O = o.dfsEdgeList.length - 1;
              return (
                e.dfsEdgeList[O] === o.dfsEdgeList[O] &&
                a(b[`${w.edgeLabel}-${w.nodeLabel2}`].projected)
              );
            })(a[u].projected);
          }),
          (t.prototype.report = function () {
            if (!(this.dfsCode.getNodeNum() < this.minNodeNum)) {
              this.counter++;
              const t = this.dfsCode.toGraph(this.counter, this.directed);
              this.frequentSubgraphs.push(Object(O.a)(t));
            }
          }),
          (t.prototype.subGraphMining = function (t) {
            const e = this;
            if (!(this.getSupport(t) < this.minSupport) && this.isMin()) {
              this.report();
              const n = this.dfsCode.getNodeNum();
              const r = this.dfsCode.buildRmpath();
              const i = this.dfsCode.dfsEdgeList[r[0]].toNode;
              const o = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
              const a = {};
              const s = {};
              t.forEach((t) => {
                for (
                  var u = e.graphs[t.graphId], c = u.nodeMap, h = new U(t), l = r.length - 1;
                  l >= 0;
                  l--
                ) {
                  const f = e.findBackwardEdge(u, h.edges[r[l]], h.edges[r[0]], h);
                  if (f) {
                    const d = `${e.dfsCode.dfsEdgeList[r[l]].fromNode}-${f.label}`;
                    s[d] ||
                      (s[d] = {
                        projected: [],
                        toNodeId: e.dfsCode.dfsEdgeList[r[l]].fromNode,
                        edgeLabel: f.label,
                      }),
                      s[d].projected.push({ graphId: t.graphId, edge: f, preNode: t });
                  }
                }
                if (!(n >= e.maxNodeNum)) {
                  e.findForwardPureEdges(u, h.edges[r[0]], o, h).forEach((e) => {
                    const n = `${i}-${e.label}-${c[e.to].label}`;
                    a[n] ||
                      (a[n] = {
                        projected: [],
                        fromNodeId: i,
                        edgeLabel: e.label,
                        nodeLabel2: c[e.to].label,
                      }),
                      a[n].projected.push({ graphId: t.graphId, edge: e, preNode: t });
                  });
                  const p = function (n) {
                    e.findForwardRmpathEdges(u, h.edges[r[n]], o, h).forEach((i) => {
                      const o = `${e.dfsCode.dfsEdgeList[r[n]].fromNode}-${i.label}-${
                        c[i.to].label
                      }`;
                      a[o] ||
                        (a[o] = {
                          projected: [],
                          fromNodeId: e.dfsCode.dfsEdgeList[r[n]].fromNode,
                          edgeLabel: i.label,
                          nodeLabel2: c[i.to].label,
                        }),
                        a[o].projected.push({ graphId: t.graphId, edge: i, preNode: t });
                    });
                  };
                  for (l = 0; l < r.length; l++) p(l);
                }
              }),
                Object.keys(s).forEach((t) => {
                  const n = s[t];
                  const r = n.toNodeId;
                  const o = n.edgeLabel;
                  e.dfsCode.dfsEdgeList.push(new W(i, r, '-1', o, '-1')),
                    e.subGraphMining(s[t].projected),
                    e.dfsCode.dfsEdgeList.pop();
                }),
                Object.keys(a).forEach((t) => {
                  const n = a[t];
                  const r = n.fromNodeId;
                  const o = n.edgeLabel;
                  const s = n.nodeLabel2;
                  e.dfsCode.dfsEdgeList.push(new W(r, i + 1, '-1', o, s)),
                    e.subGraphMining(a[t].projected),
                    e.dfsCode.dfsEdgeList.pop();
                });
            }
          }),
          (t.prototype.generate1EdgeFrequentSubGraphs = function () {
            const t = this.graphs;
            const e = this.directed;
            const n = this.minSupport;
            const r = this.frequentSize1Subgraphs;
            const i = {};
            const o = {};
            const a = {};
            const s = {};
            return (
              Object.keys(t).forEach((n) => {
                const r = t[n];
                const u = r.nodeMap;
                r.nodes.forEach((t, r) => {
                  const c = t.label;
                  const h = `${n}-${c}`;
                  if (!a[h]) {
                    let l = i[c] || 0;
                    l++, (i[c] = l);
                  }
                  (a[h] = { graphKey: n, label: c }),
                    t.edges.forEach((t) => {
                      let r = c;
                      let i = u[t.to].label;
                      if (!e && r > i) {
                        const a = i;
                        (i = r), (r = a);
                      }
                      const h = t.label;
                      const l = `${n}-${r}-${h}-${i}`;
                      const f = `${r}-${h}-${i}`;
                      if (!o[f]) {
                        let d = o[f] || 0;
                        d++, (o[f] = d);
                      }
                      s[l] = { graphId: n, nodeLabel1: r, edgeLabel: h, nodeLabel2: i };
                    });
                });
              }),
              Object.keys(i).forEach((t) => {
                if (!(i[t] < n)) {
                  const e = { nodes: [], edges: [] };
                  e.nodes.push({ id: '0', label: t }), r.push(e);
                }
              }),
              r
            );
          }),
          (t.prototype.run = function () {
            const t = this;
            if (
              ((this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs()),
              !(this.maxNodeNum < 2))
            ) {
              const e = this.graphs;
              const n = (this.directed, {});
              Object.keys(e).forEach((r) => {
                const i = e[r];
                const o = i.nodeMap;
                i.nodes.forEach((e) => {
                  t.findForwardRootEdges(i, e).forEach((t) => {
                    const i = o[t.to];
                    const a = `${e.label}-${t.label}-${i.label}`;
                    n[a] ||
                      (n[a] = {
                        projected: [],
                        nodeLabel1: e.label,
                        edgeLabel: t.label,
                        nodeLabel2: i.label,
                      });
                    const s = { graphId: r, edge: t, preNode: null };
                    n[a].projected.push(s);
                  });
                });
              }),
                Object.keys(n).forEach((e) => {
                  const r = n[e];
                  const i = r.projected;
                  const o = r.nodeLabel1;
                  const a = r.edgeLabel;
                  const s = r.nodeLabel2;
                  t.dfsCode.dfsEdgeList.push(new W(0, 1, o, a, s)),
                    t.subGraphMining(i),
                    t.dfsCode.dfsEdgeList.pop();
                });
            }
          }),
          t
        );
      })();
      const q = function (t) {
        const e = t.graphs;
        const n = t.directed;
        const r = void 0 !== n && n;
        const i = t.nodeLabelProp;
        const o = void 0 === i ? 'cluster' : i;
        const a = t.edgeLabelProp;
        const s = void 0 === a ? 'cluster' : a;
        const u = (function (t, e, n, r) {
          const i = {};
          return (
            Object.keys(t).forEach((o, a) => {
              const s = t[o];
              const u = new z(a, !0, e);
              const c = {};
              s.nodes.forEach((t, e) => {
                u.addNode(e, t[n]), (c[t.id] = e);
              }),
                s.edges.forEach((t, e) => {
                  const n = c[t.source];
                  const i = c[t.target];
                  u.addEdge(-1, n, i, t[r]);
                }),
                u && u.getNodeNum() && (i[u.id] = u);
            }),
            i
          );
        })(e, r, o, s);
        const c = t.minSupport;
        const h = t.maxNodeNum;
        const l = t.minNodeNum;
        const f = t.verbose;
        const d = t.top;
        const p = new H({
          graphs: u,
          minSupport: c,
          maxNodeNum: h,
          minNodeNum: l,
          top: d,
          verbose: f,
          directed: r,
        });
        return (
          p.run(),
          (function (t, e, n) {
            const r = [];
            return (
              t.forEach((t) => {
                const i = { nodes: [], edges: [] };
                t.nodes.forEach((t) => {
                  let n;
                  i.nodes.push((((n = { id: `${t.id}` })[e] = t.label), n));
                }),
                  t.edges.forEach((t) => {
                    let e;
                    i.edges.push(
                      (((e = { source: `${t.from}`, target: `${t.to}` })[n] = t.label), e),
                    );
                  }),
                  r.push(i);
              }),
              r
            );
          })(p.frequentSubgraphs, o, s)
        );
      };
      function V(t) {
        return (V =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const Z = function (t, e, n, r) {
        void 0 === n && (n = 'cluster'), void 0 === r && (r = 2);
        const i = [];
        const o = t.nodes;
        return (
          e.forEach((t, e) => {
            i.push(K(o, t, e, n, r));
          }),
          i
        );
      };
      var K = function (t, e, n, r, i) {
        const o = [n];
        const a = [];
        const s = {};
        return (
          e.forEach((e, u) => {
            if (e <= i && n !== u) {
              o.push(u), a.push(t[u]);
              const c = t[u][r];
              s[c] ? (s[c].count++, s[c].dists.push(e)) : (s[c] = { count: 1, dists: [e] });
            }
          }),
          Object.keys(s).forEach((t) => {
            s[t].dists = s[t].dists.sort((t, e) => {
              return t - e;
            });
          }),
          {
            nodeIdx: n,
            nodeId: t[n].id,
            nodeIdxs: o,
            neighbors: a,
            neighborNum: o.length - 1,
            nodeLabelCountMap: s,
          }
        );
      };
      const $ = function (t, e, n, r) {
        const i = n.nodes;
        return (
          r || (r = {}),
          Object.keys(t).forEach((o) => {
            let a;
            let s;
            if (!r || !r[o]) {
              r[o] = { nodes: [], edges: [] };
              const u = t[o];
              const c = (a = e[u.start]) === null || void 0 === a ? void 0 : a.nodeIdxs;
              const h = (s = e[u.end]) === null || void 0 === s ? void 0 : s.nodeIdxs;
              if (c && h) {
                const l = new Set(h);
                const f = c.filter((t) => {
                  return l.has(t);
                });
                if (f && f.length) {
                  for (var d = {}, p = f.length, g = 0; g < p; g++) {
                    const v = i[f[g]];
                    r[o].nodes.push(v), (d[v.id] = !0);
                  }
                  n.edges.forEach((t) => {
                    d[t.source] && d[t.target] && r[o].edges.push(t);
                  });
                }
              }
            }
          }),
          r
        );
      };
      const Q = function (t, e, n, r) {
        const i = {};
        t.nodes.forEach((t) => {
          i[t.id] = t;
        });
        let o = 0;
        return (
          t.edges.forEach((t) => {
            const a = i[t.source][n];
            const s = i[t.target][n];
            const u = e.nodes[0][n];
            const c = e.nodes[1][n];
            const h = e.edges[0][r];
            t[r] === h && ((a === u && s === c) || (a === c && s === u)) && o++;
          }),
          o
        );
      };
      const J = function (t, e) {
        const n = {};
        const r = {};
        return (
          t.forEach((t, i) => {
            n[t.id] = { idx: i, node: t, degree: 0 };
            const o = t[e];
            r[o] || (r[o] = []), r[o].push(t);
          }),
          { nodeMap: n, nodeLabelMap: r }
        );
      };
      const tt = function (t, e, n) {
        const r = {};
        const i = {};
        return (
          t.forEach((t, o) => {
            r[`${h}`] = { idx: o, edge: t };
            const a = t[e];
            i[a] || (i[a] = []), i[a].push(t);
            const s = n[t.source];
            s && s.degree++;
            const u = n[t.target];
            u && u.degree++;
          }),
          { edgeMap: r, edgeLabelMap: i }
        );
      };
      const et = function (t, e, n) {
        const r = e.length;
        const i = {};
        return (
          e.forEach((e, o) => {
            for (let a = n ? 0 : o + 1, s = t[o].id, u = a; u < r; u++)
              if (o !== u) {
                const c = t[u].id;
                const h = e[u];
                (i[`${s}-${c}`] = h), n || (i[`${c}-${s}`] = h);
              }
          }),
          i
        );
      };
      var nt = function (t, e, n, r, i, o, a) {
        if (
          (void 0 === n && (n = !1),
          void 0 === o && (o = 'cluster'),
          void 0 === a && (a = 'cluster'),
          t && t.nodes)
        ) {
          const s = t.nodes.length;
          if (s) {
            const u = P(t, n);
            const c = P(e, n);
            const h = et(t.nodes, u, n);
            const l = et(e.nodes, c, n);
            const f = J(t.nodes, o);
            const d = f.nodeMap;
            const p = f.nodeLabelMap;
            const g = J(e.nodes, o);
            const v = g.nodeMap;
            const y = g.nodeLabelMap;
            tt(t.edges, a, d);
            const m = tt(e.edges, a, v).edgeLabelMap;
            i || (i = Math.max.apply(Math, Object(w.f)(Object(w.f)([], c[0]), [2]))), r || (r = i);
            const b = Z(t, u, o, r);
            const x = Z(e, c, o, r);
            const M = (function (t, e, n, r, i) {
              let o = Math.ceil(n / e);
              const a = {};
              let s = 0;
              return (
                r.forEach((t, r) => {
                  for (var u = 0, c = 0, h = t.nodeIdxs, l = t.neighborNum - 1; u < o; ) {
                    for (
                      var f = h[1 + Math.floor(Math.random() * l)], d = 0;
                      (a[`${r}-${f}`] || a[`${f}-${r}`]) &&
                      ((f = Math.floor(Math.random() * e)), !(++d > 2 * e));

                    );
                    if (
                      d < 2 * e &&
                      ((a[`${r}-${f}`] = { start: r, end: f, distance: i[r][f] }), u++, ++s >= n)
                    )
                      return a;
                    if (++c > 2 * e) break;
                  }
                  u < o && (o = (o + (o - u)) / (e - r - 1));
                }),
                a
              );
            })(0, s, Math.min(100, (s * (s - 1)) / 2), x, u);
            let S = $(M, b, t);
            const O = q({
              graphs: S,
              nodeLabelProp: o,
              edgeLabelProp: a,
              minSupport: 1,
              minNodeNum: 1,
              maxNodeNum: 4,
              directed: n,
            }).slice(0, 10);
            const E = O.length;
            const k = [];
            O.forEach((t, e) => {
              (k[e] = {}),
                Object.keys(S).forEach((n) => {
                  const r = S[n];
                  const i = Q(r, t, o, a);
                  k[e][n] = i;
                });
            });
            const T = (function (t, e, n) {
              for (
                var r = 1 / 0,
                  i = 0,
                  o = function (e) {
                    const n = t[e];
                    const o = Object.keys(n).sort((t, e) => {
                      return n[t] - n[e];
                    });
                    const a = [];
                    o.forEach((t, e) => {
                      a[e % 10] || (a[e % 10] = { graphs: [], totalCount: 0, aveCount: 0 }),
                        a[e % 10].graphs.push(t),
                        (a[e % 10].totalCount += n[t]);
                    });
                    let s = 0;
                    const u = [];
                    a.forEach((t) => {
                      const e = t.totalCount / t.graphs.length;
                      (t.aveCount = e), u.push(e);
                      let r = 0;
                      const i = t.length;
                      t.graphs.forEach((e, i) => {
                        const o = n[e];
                        t.graphs.forEach((t, e) => {
                          i !== e && (r += Math.abs(o - n[t]));
                        });
                      }),
                        (s += r /= (i * (i - 1)) / 2);
                    }),
                      (s /= a.length);
                    let c = 0;
                    u.forEach((t, e) => {
                      u.forEach((n, r) => {
                        e !== r && (c += Math.abs(t - n));
                      }),
                        (c /= (u.length * (u.length - 1)) / 2);
                    });
                    const h = c - s;
                    r < h && ((r = h), (i = e));
                  },
                  a = 0;
                a < e;
                a++
              )
                o(a);
              return { structure: n[i], structureCountMap: t[i] };
            })(k, E, O);
            const I = T.structure;
            const A = T.structureCountMap;
            const j = e.nodes[0];
            const N = j[o];
            const _ = p[N];
            const B = {};
            let L = {};
            const D = {};
            const R = {};
            const Y = {};
            Object.keys(y).forEach((n, r) => {
              Y[n] = [];
              let i = -1 / 0;
              const s = y[n];
              const u = {};
              s.forEach((t) => {
                const e = l[`${j.id}-${t.id}`];
                e && Y[n].push(e),
                  i < e && (i = e),
                  (u[`${j.id}-${t.id}`] = { start: 0, end: v[t.id].idx, distance: e });
              }),
                (Y[n] = Y[n].sort((t, e) => {
                  return t - e;
                })),
                (L = $(u, x, e, L));
              let c = [];
              if (
                (Object.keys(u).forEach((t) => {
                  if (D[t]) c.push(D[t]);
                  else {
                    const e = L[t];
                    (D[t] = Q(e, I, o, a)), c.push(D[t]);
                  }
                }),
                (c = c.sort((t, e) => {
                  return e - t;
                })),
                (R[`${j.id}-${n}`] = c),
                n !== N)
              )
                for (
                  let f = function (e) {
                      const r = _[e];
                      const i = b[d[r.id].idx];
                      const s = i.nodeLabelCountMap[n];
                      const u = y[n].length;
                      if (!s || s.count < u) return _.splice(e, 1), 'continue';
                      for (var l = !1, f = 0; f < u; f++)
                        if (s.dists[f] > Y[n][f]) {
                          l = !0;
                          break;
                        }
                      if (l) return _.splice(e, 1), 'continue';
                      const p = {};
                      i.neighbors.forEach((t) => {
                        const e = h[`${r.id}-${t.id}`];
                        p[`${r.id}-${t.id}`] = {
                          start: d[r.id].idx,
                          end: d[t.id].idx,
                          distance: e,
                        };
                      }),
                        (S = $(p, b, t, S));
                      let g = [];
                      Object.keys(p).forEach((t) => {
                        if (A[t]) g.push(A[t]);
                        else {
                          const e = S[t];
                          (A[t] = Q(e, I, o, a)), g.push(A[t]);
                        }
                      }),
                        (g = g.sort((t, e) => {
                          return e - t;
                        }));
                      let v = !1;
                      for (f = 0; f < u; f++)
                        if (g[f] < c[f]) {
                          v = !0;
                          break;
                        }
                      return v ? (_.splice(e, 1), 'continue') : void 0;
                    },
                    p = _.length - 1;
                  p >= 0;
                  p--
                )
                  f(p);
            });
            const F = [];
            _.forEach((n) => {
              for (
                var r = d[n.id].idx,
                  s = K(t.nodes, u[r], r, o, i).neighbors,
                  c = s.length,
                  l = !1,
                  f = function (r) {
                    if (s.length + 1 < e.nodes.length) return (l = !0), { value: void 0 };
                    const i = s[r];
                    const u = i[o];
                    if (!y[u] || !y[u].length) return s.splice(r, 1), 'continue';
                    const c = `${n.id}-${i.id}`;
                    if (!Y[u] || !Y[u].length) return s.splice(r, 1), 'continue';
                    const f = h[c];
                    if (f > Y[u][Y[u].length - 1]) return s.splice(r, 1), 'continue';
                    const p = A[c]
                      ? A[c]
                      : (function (t, e, n, r, i, o, a, s, u, c, h) {
                          let l;
                          const f = `${e.id}-${n.id}`;
                          if (c && c[f]) return c[f];
                          let d = h ? h[f] : void 0;
                          if (!d) {
                            const p =
                              (((l = {})[f] = {
                                start: r[e.id].idx,
                                end: r[n.id].idx,
                                distance: i,
                              }),
                              l);
                            d = (h = $(p, o, t, h))[f];
                          }
                          return Q(d, a, s, u);
                        })(t, n, i, d, f, b, I, o, a, A, S);
                    const g = `${j.id}-${u}`;
                    if (p < R[g][R[g].length - 1]) return s.splice(r, 1), 'continue';
                    let m = B[u];
                    return (
                      void 0 === m &&
                        ((m = 1 / 0),
                        y[u].forEach((t) => {
                          const e = v[t.id].degree;
                          m > e && (m = e);
                        }),
                        (B[u] = m)),
                      d[i.id].degree < m ? (s.splice(r, 1), 'continue') : void 0
                    );
                  },
                  p = c - 1;
                p >= 0;
                p--
              ) {
                const g = f(p);
                if (V(g) === 'object') return g.value;
              }
              l || F.push({ nodes: [n].concat(s) });
            });
            const X = C(e, j.id, !1).length;
            let z = {};
            n
              ? (Object.keys(X).forEach((t) => {
                  const e = v[t].node[o];
                  z[e] ? z[e].push(X[t]) : (z[e] = [X[t]]);
                }),
                Object.keys(z).forEach((t) => {
                  z[t].sort((t, e) => {
                    return t - e;
                  });
                }))
              : (z = Y);
            for (
              var W = function (r) {
                  const i = F[r];
                  const s = i.nodes[0];
                  const u = {};
                  const c = {};
                  i.nodes.forEach((t, e) => {
                    c[t.id] = { idx: e, node: t, degree: 0 };
                    const n = t[o];
                    u[n] ? u[n]++ : (u[n] = 1);
                  });
                  const h = [];
                  const l = {};
                  t.edges.forEach((t) => {
                    c[t.source] &&
                      c[t.target] &&
                      (h.push(t),
                      l[t[a]] ? l[t[a]]++ : (l[t[a]] = 1),
                      c[t.source].degree++,
                      c[t.target].degree++);
                  });
                  for (var f = Object.keys(m).length, p = !1, g = 0; g < f; g++) {
                    const b = Object.keys(m)[g];
                    if (!l[b] || l[b] < m[b].length) {
                      p = !0;
                      break;
                    }
                  }
                  if (p) return F.splice(r, 1), 'continue';
                  let x = h.length;
                  if (x < e.edges.length) return F.splice(r, 1), 'break';
                  let M = !1;
                  const S = function (t) {
                    const e = h[t];
                    const r = e[a];
                    const i = m[r];
                    if (!i || !i.length)
                      return (
                        l[r]--,
                        i && l[r] < i.length
                          ? ((M = !0), 'break')
                          : (h.splice(t, 1), c[e.source].degree--, c[e.target].degree--, 'continue')
                      );
                    const s = c[e.source].node[o];
                    const u = c[e.target].node[o];
                    let f = !1;
                    return (
                      i.forEach((t) => {
                        const e = v[t.source].node;
                        const r = v[t.target].node;
                        e[o] === s && r[o] === u && (f = !0),
                          n || e[o] !== u || r[o] !== s || (f = !0);
                      }),
                      f
                        ? void 0
                        : (l[r]--,
                          i && l[r] < i.length
                            ? ((M = !0), 'break')
                            : (h.splice(t, 1),
                              c[e.source].degree--,
                              c[e.target].degree--,
                              'continue'))
                    );
                  };
                  for (g = x - 1; g >= 0; g--) {
                    if (S(g) === 'break') break;
                  }
                  if (M) return F.splice(r, 1), 'continue';
                  i.edges = h;
                  const w = C(i, i.nodes[0].id, !1).length;
                  if (
                    (Object.keys(w)
                      .reverse()
                      .forEach((t) => {
                        if (t !== i.nodes[0].id && !M) {
                          if (w[t] === 1 / 0) {
                            var e = c[t].node[o];
                            if ((u[e]--, u[e] < y[e].length)) return void (M = !0);
                            var n = i.nodes.indexOf(c[t].node);
                            return i.nodes.splice(n, 1), void (c[t] = void 0);
                          }
                          const r = d[t].node[o];
                          if (!z[r] || !z[r].length || w[t] > z[r][z[r].length - 1]) {
                            e = c[t].node[o];
                            if ((u[e]--, u[e] < y[e].length)) return void (M = !0);
                            n = i.nodes.indexOf(c[t].node);
                            i.nodes.splice(n, 1), (c[t] = void 0);
                          }
                        }
                      }),
                    M)
                  )
                    return F.splice(r, 1), 'continue';
                  for (let O = !0, E = 0; O && !M; ) {
                    if (((O = !1), c[s.id].degree < v[j.id].degree)) {
                      M = !0;
                      break;
                    }
                    if (u[s[o]] < y[s[o]].length) {
                      M = !0;
                      break;
                    }
                    for (let k = i.nodes.length - 1; k >= 0; k--) {
                      const T = i.nodes[k];
                      const P = c[T.id].degree;
                      const I = T[o];
                      if (P < B[I]) {
                        if ((u[T[o]]--, u[T[o]] < y[T[o]].length)) {
                          M = !0;
                          break;
                        }
                        i.nodes.splice(k, 1), (c[T.id] = void 0), (O = !0);
                      }
                    }
                    if (M || (!O && E !== 0)) break;
                    for (let A = (x = h.length) - 1; A >= 0; A--) {
                      const N = h[A];
                      if (!c[N.source] || !c[N.target]) {
                        h.splice(A, 1);
                        const _ = N[a];
                        if (
                          (l[_]--,
                          c[N.source] && c[N.source].degree--,
                          c[N.target] && c[N.target].degree--,
                          m[_] && l[_] < m[_].length)
                        ) {
                          M = !0;
                          break;
                        }
                        O = !0;
                      }
                    }
                    E++;
                  }
                  return M || M || i.nodes.length < e.nodes.length || h.length < e.edges.length
                    ? (F.splice(r, 1), 'continue')
                    : void 0;
                },
                G = F.length - 1;
              G >= 0;
              G--
            ) {
              if (W(G) === 'break') break;
            }
            let U = F.length;
            const H = function (t) {
              const e = F[t];
              const n = {};
              e.edges.forEach((t) => {
                const e = `${t.source}-${t.target}-${t.label}`;
                n[e] ? n[e]++ : (n[e] = 1);
              });
              for (
                let r = function (t) {
                    const e = F[t];
                    const r = {};
                    e.edges.forEach((t) => {
                      const e = `${t.source}-${t.target}-${t.label}`;
                      r[e] ? r[e]++ : (r[e] = 1);
                    });
                    let i = !0;
                    Object.keys(r).length !== Object.keys(n).length
                      ? (i = !1)
                      : Object.keys(n).forEach((t) => {
                          r[t] !== n[t] && (i = !1);
                        }),
                      i && F.splice(t, 1);
                  },
                  i = U - 1;
                i > t;
                i--
              )
                r(i);
              U = F.length;
            };
            for (G = 0; G <= U - 1; G++) H(G);
            return F;
          }
        }
      };
      var rt = (function () {
        function t(t) {
          void 0 === t && (t = 10), (this.linkedList = new a()), (this.maxStep = t);
        }
        return (
          Object.defineProperty(t.prototype, 'length', {
            get() {
              return this.linkedList.toArray().length;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype.isEmpty = function () {
            return !this.linkedList.head;
          }),
          (t.prototype.isMaxStack = function () {
            return this.toArray().length >= this.maxStep;
          }),
          (t.prototype.peek = function () {
            return this.isEmpty() ? null : this.linkedList.head.value;
          }),
          (t.prototype.push = function (t) {
            this.linkedList.prepend(t), this.length > this.maxStep && this.linkedList.deleteTail();
          }),
          (t.prototype.pop = function () {
            const t = this.linkedList.deleteHead();
            return t ? t.value : null;
          }),
          (t.prototype.toArray = function () {
            return this.linkedList.toArray().map((t) => {
              return t.value;
            });
          }),
          (t.prototype.clear = function () {
            for (; !this.isEmpty(); ) this.pop();
          }),
          t
        );
      })();
      var it = S;
      e.default = {
        getAdjMatrix: r,
        breadthFirstSearch: l,
        connectedComponent: d,
        getDegree: g,
        getInDegree: v,
        getOutDegree: y,
        detectCycle: S,
        detectDirectedCycle: it,
        detectAllCycles: M,
        detectAllDirectedCycle: x,
        detectAllUndirectedCycle: b,
        depthFirstSearch: m,
        dijkstra: C,
        findAllPath: T,
        findShortestPath: k,
        floydWarshall: P,
        labelPropagation: I,
        louvain: j,
        minimumSpanningTree: R,
        pageRank: Y,
        getNeighbors: u,
        Stack: rt,
        GADDI: nt,
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.now = e.abs = e.round = e.TYPE_FUNCTION = void 0);
      e.TYPE_FUNCTION = 'function';
      const { round: r, abs: i } = Math;
      (e.abs = i), (e.round = r);
      const { now: o } = Date;
      e.now = o;
    },
    ,
    ,
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = N(n(124));
      const i = N(n(65));
      const o = n(18);
      const a = n(26);
      const s = N(n(135));
      const u = N(n(97));
      const c = N(n(136));
      const h = N(n(142));
      const l = N(n(249));
      const f = N(n(55));
      const d = N(n(54));
      const p = N(n(131));
      const g = N(n(94));
      const v = N(n(129));
      const y = N(n(128));
      const m = N(n(126));
      const b = N(n(134));
      const x = N(n(143));
      const M = N(n(250));
      const S = N(n(44));
      const w = N(n(251));
      const O = N(n(147));
      const C = N(n(252));
      const E = N(n(133));
      const k = N(n(144));
      const T = N(n(145));
      const P = N(n(67));
      const I = N(n(56));
      const A = N(n(66));
      const j = N(n(96));
      function N(t) {
        return t && t.__esModule ? t : { default: t };
      }
      const _ = (0, i.default)(r.default, {
        INPUT_START: o.INPUT_START,
        INPUT_MOVE: o.INPUT_MOVE,
        INPUT_END: o.INPUT_END,
        INPUT_CANCEL: o.INPUT_CANCEL,
        STATE_POSSIBLE: a.STATE_POSSIBLE,
        STATE_BEGAN: a.STATE_BEGAN,
        STATE_CHANGED: a.STATE_CHANGED,
        STATE_ENDED: a.STATE_ENDED,
        STATE_RECOGNIZED: a.STATE_RECOGNIZED,
        STATE_CANCELLED: a.STATE_CANCELLED,
        STATE_FAILED: a.STATE_FAILED,
        DIRECTION_NONE: o.DIRECTION_NONE,
        DIRECTION_LEFT: o.DIRECTION_LEFT,
        DIRECTION_RIGHT: o.DIRECTION_RIGHT,
        DIRECTION_UP: o.DIRECTION_UP,
        DIRECTION_DOWN: o.DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: o.DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: o.DIRECTION_VERTICAL,
        DIRECTION_ALL: o.DIRECTION_ALL,
        Manager: s.default,
        Input: u.default,
        TouchAction: c.default,
        TouchInput: h.default,
        PointerEventInput: l.default,
        Recognizer: f.default,
        AttrRecognizer: d.default,
        Tap: p.default,
        Pan: g.default,
        Swipe: v.default,
        Pinch: y.default,
        Rotate: m.default,
        Press: b.default,
        on: x.default,
        off: M.default,
        each: S.default,
        merge: w.default,
        extend: O.default,
        assign: i.default,
        inherit: C.default,
        bindFn: E.default,
        toArray: k.default,
        inArray: I.default,
        uniqueArray: T.default,
        splitStr: P.default,
        boolOrFn: A.default,
        hasParent: j.default,
        addEventListeners: x.default,
        removeEventListeners: M.default,
      });
      e.default = _;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.TOUCH_ACTION_MAP =
          e.TOUCH_ACTION_PAN_Y =
          e.TOUCH_ACTION_PAN_X =
          e.TOUCH_ACTION_NONE =
          e.TOUCH_ACTION_MANIPULATION =
          e.TOUCH_ACTION_COMPUTE =
          e.TOUCH_ACTION_AUTO =
            void 0);
      n(31);
      let r;
      const i = (r = n(236)) && r.__esModule ? r : { default: r };
      e.TOUCH_ACTION_COMPUTE = 'compute';
      e.TOUCH_ACTION_AUTO = 'auto';
      e.TOUCH_ACTION_MANIPULATION = 'manipulation';
      e.TOUCH_ACTION_NONE = 'none';
      e.TOUCH_ACTION_PAN_X = 'pan-x';
      e.TOUCH_ACTION_PAN_Y = 'pan-y';
      const o = (0, i.default)();
      e.TOUCH_ACTION_MAP = o;
    },
    ,
    function (t, e, n) {
      'use strict';
      const r = {};
      n.r(r),
        n.d(r, 'proccessToFunc', () => {
          return c;
        }),
        n.d(r, 'buildTextureData', () => {
          return h;
        }),
        n.d(r, 'buildTextureDataWithOneEdgeAttr', () => {
          return l;
        }),
        n.d(r, 'buildTextureDataWithTwoEdgeAttr', () => {
          return f;
        }),
        n.d(r, 'attributesToTextureData', () => {
          return d;
        }),
        n.d(r, 'arrayToTextureData', () => {
          return p;
        }),
        n.d(r, 'radialLayout', () => {
          return g;
        });
      const i = n(1);
      const o = n(93);
      const a = n(2);
      const s = n(0);
      const u = a.n.traverseTree;
      var c = function (t, e) {
        return t
          ? Object(s.k)(t)
            ? function (e) {
                return t;
              }
            : t
          : function (t) {
              return e || 1;
            };
      };
      var h = function (t, e) {
        const n = [];
        const r = [];
        const i = {};
        let o = 0;
        for (o = 0; o < t.length; o++) {
          const a = t[o];
          (i[a.id] = o), n.push(a.x), n.push(a.y), n.push(0), n.push(0), r.push([]);
        }
        for (o = 0; o < e.length; o++) {
          const s = e[o];
          r[i[s.source]].push(i[s.target]), r[i[s.target]].push(i[s.source]);
        }
        let u = 0;
        for (o = 0; o < t.length; o++) {
          const c = n.length;
          const h = r[o];
          const l = h.length;
          (n[4 * o + 2] = c), (n[4 * o + 3] = h.length), (u = Math.max(u, h.length));
          for (let f = 0; f < l; ++f) {
            const d = h[f];
            n.push(+d);
          }
        }
        for (; n.length % 4 != 0; ) n.push(0);
        return { array: new Float32Array(n), maxEdgePerVetex: u };
      };
      var l = function (t, e, n) {
        const r = [];
        const i = [];
        const o = {};
        let a = 0;
        for (a = 0; a < t.length; a++) {
          const s = t[a];
          (o[s.id] = a), r.push(s.x), r.push(s.y), r.push(0), r.push(0), i.push([]);
        }
        for (a = 0; a < e.length; a++) {
          const u = e[a];
          i[o[u.source]].push(o[u.target]),
            i[o[u.source]].push(n(u)),
            i[o[u.target]].push(o[u.source]),
            i[o[u.target]].push(n(u));
        }
        let c = 0;
        for (a = 0; a < t.length; a++) {
          const h = r.length;
          const l = i[a];
          const f = l.length;
          (r[4 * a + 2] = h), (r[4 * a + 3] = f / 2), (c = Math.max(c, f / 2));
          for (let d = 0; d < f; ++d) {
            const p = l[d];
            r.push(+p);
          }
        }
        for (; r.length % 4 != 0; ) r.push(0);
        return { array: new Float32Array(r), maxEdgePerVetex: c };
      };
      var f = function (t, e, n, r) {
        const i = [];
        const o = [];
        const a = {};
        let s = 0;
        for (s = 0; s < t.length; s++) {
          const u = t[s];
          (a[u.id] = s), i.push(u.x), i.push(u.y), i.push(0), i.push(0), o.push([]);
        }
        for (s = 0; s < e.length; s++) {
          const c = e[s];
          o[a[c.source]].push(a[c.target]),
            o[a[c.source]].push(n(c)),
            o[a[c.source]].push(r(c)),
            o[a[c.source]].push(0),
            o[a[c.target]].push(a[c.source]),
            o[a[c.target]].push(n(c)),
            o[a[c.target]].push(r(c)),
            o[a[c.target]].push(0);
        }
        let h = 0;
        for (s = 0; s < t.length; s++) {
          const l = i.length;
          const f = o[s];
          const d = f.length;
          (i[4 * s + 2] = l + (1048576 * d) / 4), (i[4 * s + 3] = 0), (h = Math.max(h, d / 4));
          for (let p = 0; p < d; ++p) {
            const g = f[p];
            i.push(+g);
          }
        }
        for (; i.length % 4 != 0; ) i.push(0);
        return { array: new Float32Array(i), maxEdgePerVetex: h };
      };
      var d = function (t, e) {
        const n = [];
        const r = t.length;
        const i = {};
        return (
          e.forEach((e) => {
            t.forEach((t, o) => {
              if (
                (void 0 === i[e[t]] && (i[e[t]] = Object.keys(i).length),
                n.push(i[e[t]]),
                o === r - 1)
              )
                for (; n.length % 4 != 0; ) n.push(0);
            });
          }),
          { array: new Float32Array(n), count: Object.keys(i).length }
        );
      };
      var p = function (t) {
        for (
          var e = [],
            n = t.length,
            r = t[0].length,
            i = function (r) {
              t.forEach((t, i) => {
                if ((e.push(t[r]), i === n - 1)) for (; e.length % 4 != 0; ) e.push(0);
              });
            },
            o = 0;
          o < r;
          o++
        )
          i(o);
        return new Float32Array(e);
      };
      var g = function (t, e) {
        const n = { x: 1 / 0, y: 1 / 0 };
        const r = { x: -1 / 0, y: -1 / 0 };
        let i = 'x';
        let o = 'y';
        e && ['V', 'TB', 'BT'].indexOf(e) >= 0 && ((o = 'x'), (i = 'y'));
        let a = 0;
        u(t, (t) => {
          return (
            a++,
            t.x > r.x && (r.x = t.x),
            t.x < n.x && (n.x = t.x),
            t.y > r.y && (r.y = t.y),
            t.y < n.y && (n.y = t.y),
            !0
          );
        });
        const s = (2 * Math.PI) / a;
        const c = r[o] - n[o];
        return (
          c === 0 ||
            u(t, (e) => {
              const r = ((e[o] - n[o]) / c) * (2 * Math.PI - s) + s;
              const a = Math.abs(i === 'x' ? e.x - t.x : e.y - t.y);
              return (e.x = a * Math.cos(r)), (e.y = a * Math.sin(r)), !0;
            }),
          t
        );
      };
      const v = Object(i.a)(Object(i.a)(Object(i.a)({}, a.n), o), r);
      e.a = v;
    },
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      n.d(e, 'b', () => {
        return o;
      }),
        n.d(e, 'c', () => {
          return a;
        }),
        n.d(e, 'a', () => {
          return s;
        });
      const r = n(5);
      const i = n(88);
      function o(t, e, n) {
        let i = 1;
        return (
          Object(r.h)(t) && (i = t.split('\n').length),
          i > 1
            ? e * i +
              (function (t, e) {
                return e ? e - t : 0.14 * t;
              })(e, n) *
                (i - 1)
            : e
        );
      }
      function a(t, e) {
        const n = Object(i.a)();
        let o = 0;
        if (Object(r.e)(t) || t === '') return o;
        if ((n.save(), (n.font = e), Object(r.h)(t) && t.includes('\n'))) {
          const a = t.split('\n');
          Object(r.a)(a, (t) => {
            const e = n.measureText(t).width;
            o < e && (o = e);
          });
        } else o = n.measureText(t).width;
        return n.restore(), o;
      }
      function s(t) {
        const e = t.fontSize;
        const n = t.fontFamily;
        const r = t.fontWeight;
        return [t.fontStyle, t.fontVariant, r, `${e}px`, n].join(' ').trim();
      }
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'a', () => {
        return s;
      }),
        n.d(e, 'b', () => {
          return l;
        }),
        n.d(e, 'c', () => {
          return m;
        });
      const r = n(0);
      const i = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
      const o = /[^\s\,]+/gi;
      const a = function (t) {
        let e = t || [];
        return Object(r.f)(e)
          ? e
          : Object(r.o)(e)
          ? ((e = e.match(i)),
            Object(r.c)(e, (t, n) => {
              if ((t = t.match(o))[0].length > 1) {
                const i = t[0].charAt(0);
                t.splice(1, 0, t[0].substr(1)), (t[0] = i);
              }
              Object(r.c)(t, (e, n) => {
                isNaN(e) || (t[n] = +e);
              }),
                (e[n] = t);
            }),
            e)
          : void 0;
      };
      function s(t, e) {
        for (var n = [], r = 0, i = t.length; i - 2 * !e > r; r += 2) {
          const o = [
            { x: +t[r - 2], y: +t[r - 1] },
            { x: +t[r], y: +t[r + 1] },
            { x: +t[r + 2], y: +t[r + 3] },
            { x: +t[r + 4], y: +t[r + 5] },
          ];
          e
            ? r
              ? i - 4 === r
                ? (o[3] = { x: +t[0], y: +t[1] })
                : i - 2 === r && ((o[2] = { x: +t[0], y: +t[1] }), (o[3] = { x: +t[2], y: +t[3] }))
              : (o[0] = { x: +t[i - 2], y: +t[i - 1] })
            : i - 4 === r
            ? (o[3] = o[2])
            : r || (o[0] = { x: +t[r], y: +t[r + 1] }),
            n.push([
              'C',
              (-o[0].x + 6 * o[1].x + o[2].x) / 6,
              (-o[0].y + 6 * o[1].y + o[2].y) / 6,
              (o[1].x + 6 * o[2].x - o[3].x) / 6,
              (o[1].y + 6 * o[2].y - o[3].y) / 6,
              o[2].x,
              o[2].y,
            ]);
        }
        return n;
      }
      const u = '\t\n\v\f\r   ᠎             　\u2028\u2029';
      const c = new RegExp(
        `([a-z])[${u},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${u}]*,?[${u}]*)+)`,
        'ig',
      );
      const h = new RegExp(`(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${u}]*,?[${u}]*`, 'ig');
      function l(t) {
        if (!t) return null;
        if (Object(r.f)(t)) return t;
        const e = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 };
        const n = [];
        return (
          String(t).replace(c, (t, r, i) => {
            const o = [];
            let a = r.toLowerCase();
            if (
              (i.replace(h, (t, e) => {
                e && o.push(+e);
              }),
              a === 'm' &&
                o.length > 2 &&
                (n.push([r].concat(o.splice(0, 2))), (a = 'l'), (r = r === 'm' ? 'l' : 'L')),
              a === 'o' && o.length === 1 && n.push([r, o[0]]),
              a === 'r')
            )
              n.push([r].concat(o));
            else for (; o.length >= e[a] && (n.push([r].concat(o.splice(0, e[a]))), e[a]); );
            return '';
          }),
          n
        );
      }
      function f(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      }
      function d(t, e) {
        return f(t) * f(e) ? (t[0] * e[0] + t[1] * e[1]) / (f(t) * f(e)) : 1;
      }
      function p(t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(d(t, e));
      }
      function g(t, e) {
        return t[0] === e[0] && t[1] === e[1];
      }
      function v(t, e) {
        let n = e[1];
        let i = e[2];
        const o = Object(r.s)(Object(r.u)(e[3]), 2 * Math.PI);
        const a = e[4];
        const s = e[5];
        const u = t[0];
        const c = t[1];
        const h = e[6];
        const l = e[7];
        const f = (Math.cos(o) * (u - h)) / 2 + (Math.sin(o) * (c - l)) / 2;
        const v = (-1 * Math.sin(o) * (u - h)) / 2 + (Math.cos(o) * (c - l)) / 2;
        const y = (f * f) / (n * n) + (v * v) / (i * i);
        y > 1 && ((n *= Math.sqrt(y)), (i *= Math.sqrt(y)));
        const m = n * n * (v * v) + i * i * (f * f);
        let b = m ? Math.sqrt((n * n * (i * i) - m) / m) : 1;
        a === s && (b *= -1), isNaN(b) && (b = 0);
        const x = i ? (b * n * v) / i : 0;
        const M = n ? (b * -i * f) / n : 0;
        const S = (u + h) / 2 + Math.cos(o) * x - Math.sin(o) * M;
        const w = (c + l) / 2 + Math.sin(o) * x + Math.cos(o) * M;
        const O = [(f - x) / n, (v - M) / i];
        const C = [(-1 * f - x) / n, (-1 * v - M) / i];
        const E = p([1, 0], O);
        let k = p(O, C);
        return (
          d(O, C) <= -1 && (k = Math.PI),
          d(O, C) >= 1 && (k = 0),
          s === 0 && k > 0 && (k -= 2 * Math.PI),
          s === 1 && k < 0 && (k += 2 * Math.PI),
          {
            cx: S,
            cy: w,
            rx: g(t, [h, l]) ? 0 : n,
            ry: g(t, [h, l]) ? 0 : i,
            startAngle: E,
            endAngle: E + k,
            xRotation: o,
            arcFlag: a,
            sweepFlag: s,
          }
        );
      }
      function y(t, e) {
        return [e[0] + (e[0] - t[0]), e[1] + (e[1] - t[1])];
      }
      function m(t) {
        for (
          var e = [], n = null, r = null, i = null, o = 0, s = (t = a(t)).length, u = 0;
          u < s;
          u++
        ) {
          const c = t[u];
          r = t[u + 1];
          const h = c[0];
          const l = { command: h, prePoint: n, params: c, startTangent: null, endTangent: null };
          switch (h) {
            case 'M':
              (i = [c[1], c[2]]), (o = u);
              break;
            case 'A':
              var f = v(n, c);
              l.arcParams = f;
          }
          if (h === 'Z') (n = i), (r = t[o + 1]);
          else {
            const d = c.length;
            n = [c[d - 2], c[d - 1]];
          }
          r && r[0] === 'Z' && ((r = t[o]), e[o] && (e[o].prePoint = n)),
            (l.currentPoint = n),
            e[o] && g(n, e[o].currentPoint) && (e[o].prePoint = l.prePoint);
          const p = r ? [r[r.length - 2], r[r.length - 1]] : null;
          l.nextPoint = p;
          const m = l.prePoint;
          if (['L', 'H', 'V'].includes(h))
            (l.startTangent = [m[0] - n[0], m[1] - n[1]]),
              (l.endTangent = [n[0] - m[0], n[1] - m[1]]);
          else if (h === 'Q') {
            var b = [c[1], c[2]];
            (l.startTangent = [m[0] - b[0], m[1] - b[1]]),
              (l.endTangent = [n[0] - b[0], n[1] - b[1]]);
          } else if (h === 'T') {
            b = y((S = e[u - 1]).currentPoint, m);
            S.command === 'Q'
              ? ((l.command = 'Q'),
                (l.startTangent = [m[0] - b[0], m[1] - b[1]]),
                (l.endTangent = [n[0] - b[0], n[1] - b[1]]))
              : ((l.command = 'TL'),
                (l.startTangent = [m[0] - n[0], m[1] - n[1]]),
                (l.endTangent = [n[0] - m[0], n[1] - m[1]]));
          } else if (h === 'C') {
            var x = [c[1], c[2]];
            var M = [c[3], c[4]];
            (l.startTangent = [m[0] - x[0], m[1] - x[1]]),
              (l.endTangent = [n[0] - M[0], n[1] - M[1]]);
          } else if (h === 'S') {
            var S;
            (x = y((S = e[u - 1]).currentPoint, m)), (M = [c[1], c[2]]);
            S.command === 'C'
              ? ((l.command = 'C'),
                (l.startTangent = [m[0] - x[0], m[1] - x[1]]),
                (l.endTangent = [n[0] - M[0], n[1] - M[1]]))
              : ((l.command = 'SQ'),
                (l.startTangent = [m[0] - M[0], m[1] - M[1]]),
                (l.endTangent = [n[0] - M[0], n[1] - M[1]]));
          } else if (h === 'A') {
            let w = 0.001;
            const O = l.arcParams || {};
            const C = O.cx;
            const E = void 0 === C ? 0 : C;
            const k = O.cy;
            const T = void 0 === k ? 0 : k;
            const P = O.rx;
            const I = void 0 === P ? 0 : P;
            const A = O.ry;
            const j = void 0 === A ? 0 : A;
            const N = O.sweepFlag;
            const _ = void 0 === N ? 0 : N;
            const B = O.startAngle;
            const L = void 0 === B ? 0 : B;
            const D = O.endAngle;
            const R = void 0 === D ? 0 : D;
            _ === 0 && (w *= -1);
            const Y = I * Math.cos(L - w) + E;
            const F = j * Math.sin(L - w) + T;
            l.startTangent = [Y - i[0], F - i[1]];
            const X = I * Math.cos(L + R + w) + E;
            const z = j * Math.sin(L + R - w) + T;
            l.endTangent = [m[0] - X, m[1] - z];
          }
          e.push(l);
        }
        return e;
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          let r;
          if (!t) return;
          if (t.forEach) t.forEach(e, n);
          else if (void 0 !== t.length) for (r = 0; r < t.length; ) e.call(n, t[r], r, t), r++;
          else for (r in t) t.hasOwnProperty(r) && e.call(n, t[r], r, t);
        });
    },
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      n(29);
      const r = n(119);
      n.o(r, 'ICanvas') &&
        n.d(e, 'ICanvas', () => {
          return r.ICanvas;
        }),
        n.o(r, 'IGroup') &&
          n.d(e, 'IGroup', () => {
            return r.IGroup;
          }),
        n.o(r, 'IShape') &&
          n.d(e, 'IShape', () => {
            return r.IShape;
          });
      const i = n(120);
      n.o(i, 'ICanvas') &&
        n.d(e, 'ICanvas', () => {
          return i.ICanvas;
        }),
        n.o(i, 'IGroup') &&
          n.d(e, 'IGroup', () => {
            return i.IGroup;
          }),
        n.o(i, 'IShape') &&
          n.d(e, 'IShape', () => {
            return i.IShape;
          });
      const o = n(86);
      n.d(e, 'Event', () => {
        return o.a;
      });
      n(87), n(204), n(122), n(123), n(206), n(42), n(5), n(21), n(88);
    },
    function (t, e, n) {
      'use strict';
      n.r(e),
        n.d(e, 'create', () => {
          return i;
        }),
        n.d(e, 'clone', () => {
          return o;
        }),
        n.d(e, 'fromValues', () => {
          return a;
        }),
        n.d(e, 'copy', () => {
          return s;
        }),
        n.d(e, 'set', () => {
          return u;
        }),
        n.d(e, 'add', () => {
          return c;
        }),
        n.d(e, 'subtract', () => {
          return h;
        }),
        n.d(e, 'multiply', () => {
          return l;
        }),
        n.d(e, 'divide', () => {
          return f;
        }),
        n.d(e, 'ceil', () => {
          return d;
        }),
        n.d(e, 'floor', () => {
          return p;
        }),
        n.d(e, 'min', () => {
          return g;
        }),
        n.d(e, 'max', () => {
          return v;
        }),
        n.d(e, 'round', () => {
          return y;
        }),
        n.d(e, 'scale', () => {
          return m;
        }),
        n.d(e, 'scaleAndAdd', () => {
          return b;
        }),
        n.d(e, 'distance', () => {
          return x;
        }),
        n.d(e, 'squaredDistance', () => {
          return M;
        }),
        n.d(e, 'length', () => {
          return S;
        }),
        n.d(e, 'squaredLength', () => {
          return w;
        }),
        n.d(e, 'negate', () => {
          return O;
        }),
        n.d(e, 'inverse', () => {
          return C;
        }),
        n.d(e, 'normalize', () => {
          return E;
        }),
        n.d(e, 'dot', () => {
          return k;
        }),
        n.d(e, 'cross', () => {
          return T;
        }),
        n.d(e, 'lerp', () => {
          return P;
        }),
        n.d(e, 'random', () => {
          return I;
        }),
        n.d(e, 'transformMat2', () => {
          return A;
        }),
        n.d(e, 'transformMat2d', () => {
          return j;
        }),
        n.d(e, 'transformMat3', () => {
          return N;
        }),
        n.d(e, 'transformMat4', () => {
          return _;
        }),
        n.d(e, 'rotate', () => {
          return B;
        }),
        n.d(e, 'angle', () => {
          return L;
        }),
        n.d(e, 'zero', () => {
          return D;
        }),
        n.d(e, 'str', () => {
          return R;
        }),
        n.d(e, 'exactEquals', () => {
          return Y;
        }),
        n.d(e, 'equals', () => {
          return F;
        }),
        n.d(e, 'len', () => {
          return z;
        }),
        n.d(e, 'sub', () => {
          return W;
        }),
        n.d(e, 'mul', () => {
          return G;
        }),
        n.d(e, 'div', () => {
          return U;
        }),
        n.d(e, 'dist', () => {
          return H;
        }),
        n.d(e, 'sqrDist', () => {
          return q;
        }),
        n.d(e, 'sqrLen', () => {
          return V;
        }),
        n.d(e, 'forEach', () => {
          return Z;
        });
      const r = n(6);
      function i() {
        const t = new r.a(2);
        return r.a != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
      }
      function o(t) {
        const e = new r.a(2);
        return (e[0] = t[0]), (e[1] = t[1]), e;
      }
      function a(t, e) {
        const n = new r.a(2);
        return (n[0] = t), (n[1] = e), n;
      }
      function s(t, e) {
        return (t[0] = e[0]), (t[1] = e[1]), t;
      }
      function u(t, e, n) {
        return (t[0] = e), (t[1] = n), t;
      }
      function c(t, e, n) {
        return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), t;
      }
      function h(t, e, n) {
        return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), t;
      }
      function l(t, e, n) {
        return (t[0] = e[0] * n[0]), (t[1] = e[1] * n[1]), t;
      }
      function f(t, e, n) {
        return (t[0] = e[0] / n[0]), (t[1] = e[1] / n[1]), t;
      }
      function d(t, e) {
        return (t[0] = Math.ceil(e[0])), (t[1] = Math.ceil(e[1])), t;
      }
      function p(t, e) {
        return (t[0] = Math.floor(e[0])), (t[1] = Math.floor(e[1])), t;
      }
      function g(t, e, n) {
        return (t[0] = Math.min(e[0], n[0])), (t[1] = Math.min(e[1], n[1])), t;
      }
      function v(t, e, n) {
        return (t[0] = Math.max(e[0], n[0])), (t[1] = Math.max(e[1], n[1])), t;
      }
      function y(t, e) {
        return (t[0] = Math.round(e[0])), (t[1] = Math.round(e[1])), t;
      }
      function m(t, e, n) {
        return (t[0] = e[0] * n), (t[1] = e[1] * n), t;
      }
      function b(t, e, n, r) {
        return (t[0] = e[0] + n[0] * r), (t[1] = e[1] + n[1] * r), t;
      }
      function x(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        return Math.hypot(n, r);
      }
      function M(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        return n * n + r * r;
      }
      function S(t) {
        const e = t[0];
        const n = t[1];
        return Math.hypot(e, n);
      }
      function w(t) {
        const e = t[0];
        const n = t[1];
        return e * e + n * n;
      }
      function O(t, e) {
        return (t[0] = -e[0]), (t[1] = -e[1]), t;
      }
      function C(t, e) {
        return (t[0] = 1 / e[0]), (t[1] = 1 / e[1]), t;
      }
      function E(t, e) {
        const n = e[0];
        const r = e[1];
        let i = n * n + r * r;
        return i > 0 && (i = 1 / Math.sqrt(i)), (t[0] = e[0] * i), (t[1] = e[1] * i), t;
      }
      function k(t, e) {
        return t[0] * e[0] + t[1] * e[1];
      }
      function T(t, e, n) {
        const r = e[0] * n[1] - e[1] * n[0];
        return (t[0] = t[1] = 0), (t[2] = r), t;
      }
      function P(t, e, n, r) {
        const i = e[0];
        const o = e[1];
        return (t[0] = i + r * (n[0] - i)), (t[1] = o + r * (n[1] - o)), t;
      }
      function I(t, e) {
        e = e || 1;
        const n = 2 * r.c() * Math.PI;
        return (t[0] = Math.cos(n) * e), (t[1] = Math.sin(n) * e), t;
      }
      function A(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[2] * i), (t[1] = n[1] * r + n[3] * i), t;
      }
      function j(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[2] * i + n[4]), (t[1] = n[1] * r + n[3] * i + n[5]), t;
      }
      function N(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[3] * i + n[6]), (t[1] = n[1] * r + n[4] * i + n[7]), t;
      }
      function _(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[4] * i + n[12]), (t[1] = n[1] * r + n[5] * i + n[13]), t;
      }
      function B(t, e, n, r) {
        const i = e[0] - n[0];
        const o = e[1] - n[1];
        const a = Math.sin(r);
        const s = Math.cos(r);
        return (t[0] = i * s - o * a + n[0]), (t[1] = i * a + o * s + n[1]), t;
      }
      function L(t, e) {
        const n = t[0];
        const r = t[1];
        const i = e[0];
        const o = e[1];
        const a = Math.sqrt(n * n + r * r) * Math.sqrt(i * i + o * o);
        const s = a && (n * i + r * o) / a;
        return Math.acos(Math.min(Math.max(s, -1), 1));
      }
      function D(t) {
        return (t[0] = 0), (t[1] = 0), t;
      }
      function R(t) {
        return `vec2(${t[0]}, ${t[1]})`;
      }
      function Y(t, e) {
        return t[0] === e[0] && t[1] === e[1];
      }
      function F(t, e) {
        const n = t[0];
        const i = t[1];
        const o = e[0];
        const a = e[1];
        return (
          Math.abs(n - o) <= r.b * Math.max(1, Math.abs(n), Math.abs(o)) &&
          Math.abs(i - a) <= r.b * Math.max(1, Math.abs(i), Math.abs(a))
        );
      }
      let X;
      var z = S;
      var W = h;
      var G = l;
      var U = f;
      var H = x;
      var q = M;
      var V = w;
      var Z =
        ((X = i()),
        function (t, e, n, r, i, o) {
          let a;
          let s;
          for (
            e || (e = 2), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n;
            a < s;
            a += e
          )
            (X[0] = t[a]), (X[1] = t[a + 1]), i(X, X, o), (t[a] = X[0]), (t[a + 1] = X[1]);
          return t;
        });
    },
    function (t, e, n) {
      'use strict';
      let r;
      let i;
      let o;
      let a;
      function s(t) {
        r ||
          ((r = document.createElement('table')),
          (i = document.createElement('tr')),
          (o = /^\s*<(\w+|!)[^>]*>/),
          (a = {
            tr: document.createElement('tbody'),
            tbody: r,
            thead: r,
            tfoot: r,
            td: i,
            th: i,
            '*': document.createElement('div'),
          }));
        let e = o.test(t) && RegExp.$1;
        (e && e in a) || (e = '*');
        const n = a[e];
        (t = t.replace(/(^\s*)|(\s*$)/g, '')), (n.innerHTML = `${t}`);
        const s = n.childNodes[0];
        return n.removeChild(s), s;
      }
      function u(t, e) {
        if (t) for (const n in e) e.hasOwnProperty(n) && (t.style[n] = e[n]);
        return t;
      }
      n.d(e, 'a', () => {
        return s;
      }),
        n.d(e, 'b', () => {
          return u;
        });
    },
    function (t, e, n) {
      'use strict';
      function r(t) {
        return (r =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const i = n(255);
      const o = n(259);
      const a = [].slice;
      const s = ['keyword', 'gray', 'hex'];
      const u = {};
      Object.keys(o).forEach((t) => {
        u[a.call(o[t].labels).sort().join('')] = t;
      });
      const c = {};
      function h(t, e) {
        if (!(this instanceof h)) return new h(t, e);
        if ((e && e in s && (e = null), e && !(e in o))) throw new Error(`Unknown model: ${e}`);
        let n;
        let r;
        if (t == null) (this.model = 'rgb'), (this.color = [0, 0, 0]), (this.valpha = 1);
        else if (t instanceof h)
          (this.model = t.model), (this.color = t.color.slice()), (this.valpha = t.valpha);
        else if (typeof t === 'string') {
          const l = i.get(t);
          if (l === null) throw new Error(`Unable to parse color from string: ${t}`);
          (this.model = l.model),
            (r = o[this.model].channels),
            (this.color = l.value.slice(0, r)),
            (this.valpha = typeof l.value[r] === 'number' ? l.value[r] : 1);
        } else if (t.length) {
          (this.model = e || 'rgb'), (r = o[this.model].channels);
          const f = a.call(t, 0, r);
          (this.color = p(f, r)), (this.valpha = typeof t[r] === 'number' ? t[r] : 1);
        } else if (typeof t === 'number')
          (t &= 16777215),
            (this.model = 'rgb'),
            (this.color = [(t >> 16) & 255, (t >> 8) & 255, 255 & t]),
            (this.valpha = 1);
        else {
          this.valpha = 1;
          const d = Object.keys(t);
          'alpha' in t &&
            (d.splice(d.indexOf('alpha'), 1),
            (this.valpha = typeof t.alpha === 'number' ? t.alpha : 0));
          const g = d.sort().join('');
          if (!(g in u)) throw new Error(`Unable to parse color from object: ${JSON.stringify(t)}`);
          this.model = u[g];
          const v = o[this.model].labels;
          const y = [];
          for (n = 0; n < v.length; n++) y.push(t[v[n]]);
          this.color = p(y);
        }
        if (c[this.model])
          for (r = o[this.model].channels, n = 0; n < r; n++) {
            const m = c[this.model][n];
            m && (this.color[n] = m(this.color[n]));
          }
        (this.valpha = Math.max(0, Math.min(1, this.valpha))), Object.freeze && Object.freeze(this);
      }
      function l(t, e, n) {
        return (
          (t = Array.isArray(t) ? t : [t]).forEach((t) => {
            (c[t] || (c[t] = []))[e] = n;
          }),
          (t = t[0]),
          function (r) {
            let i;
            return arguments.length
              ? (n && (r = n(r)), ((i = this[t]()).color[e] = r), i)
              : ((i = this[t]().color[e]), n && (i = n(i)), i);
          }
        );
      }
      function f(t) {
        return function (e) {
          return Math.max(0, Math.min(t, e));
        };
      }
      function d(t) {
        return Array.isArray(t) ? t : [t];
      }
      function p(t, e) {
        for (let n = 0; n < e; n++) typeof t[n] !== 'number' && (t[n] = 0);
        return t;
      }
      (h.prototype = {
        toString() {
          return this.string();
        },
        toJSON() {
          return this[this.model]();
        },
        string(t) {
          let e = this.model in i.to ? this : this.rgb();
          const n =
            (e = e.round(typeof t === 'number' ? t : 1)).valpha === 1
              ? e.color
              : e.color.concat(this.valpha);
          return i.to[e.model](n);
        },
        percentString(t) {
          const e = this.rgb().round(typeof t === 'number' ? t : 1);
          const n = e.valpha === 1 ? e.color : e.color.concat(this.valpha);
          return i.to.rgb.percent(n);
        },
        array() {
          return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
        },
        object() {
          for (var t = {}, e = o[this.model].channels, n = o[this.model].labels, r = 0; r < e; r++)
            t[n[r]] = this.color[r];
          return this.valpha !== 1 && (t.alpha = this.valpha), t;
        },
        unitArray() {
          const t = this.rgb().color;
          return (
            (t[0] /= 255), (t[1] /= 255), (t[2] /= 255), this.valpha !== 1 && t.push(this.valpha), t
          );
        },
        unitObject() {
          const t = this.rgb().object();
          return (
            (t.r /= 255),
            (t.g /= 255),
            (t.b /= 255),
            this.valpha !== 1 && (t.alpha = this.valpha),
            t
          );
        },
        round(t) {
          return (
            (t = Math.max(t || 0, 0)),
            new h(
              this.color
                .map(
                  (function (t) {
                    return function (e) {
                      return (function (t, e) {
                        return Number(t.toFixed(e));
                      })(e, t);
                    };
                  })(t),
                )
                .concat(this.valpha),
              this.model,
            )
          );
        },
        alpha(t) {
          return arguments.length
            ? new h(this.color.concat(Math.max(0, Math.min(1, t))), this.model)
            : this.valpha;
        },
        red: l('rgb', 0, f(255)),
        green: l('rgb', 1, f(255)),
        blue: l('rgb', 2, f(255)),
        hue: l(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, (t) => {
          return ((t % 360) + 360) % 360;
        }),
        saturationl: l('hsl', 1, f(100)),
        lightness: l('hsl', 2, f(100)),
        saturationv: l('hsv', 1, f(100)),
        value: l('hsv', 2, f(100)),
        chroma: l('hcg', 1, f(100)),
        gray: l('hcg', 2, f(100)),
        white: l('hwb', 1, f(100)),
        wblack: l('hwb', 2, f(100)),
        cyan: l('cmyk', 0, f(100)),
        magenta: l('cmyk', 1, f(100)),
        yellow: l('cmyk', 2, f(100)),
        black: l('cmyk', 3, f(100)),
        x: l('xyz', 0, f(100)),
        y: l('xyz', 1, f(100)),
        z: l('xyz', 2, f(100)),
        l: l('lab', 0, f(100)),
        a: l('lab', 1),
        b: l('lab', 2),
        keyword(t) {
          return arguments.length ? new h(t) : o[this.model].keyword(this.color);
        },
        hex(t) {
          return arguments.length ? new h(t) : i.to.hex(this.rgb().round().color);
        },
        rgbNumber() {
          const t = this.rgb().color;
          return ((255 & t[0]) << 16) | ((255 & t[1]) << 8) | (255 & t[2]);
        },
        luminosity() {
          for (var t = this.rgb().color, e = [], n = 0; n < t.length; n++) {
            const r = t[n] / 255;
            e[n] = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2];
        },
        contrast(t) {
          const e = this.luminosity();
          const n = t.luminosity();
          return e > n ? (e + 0.05) / (n + 0.05) : (n + 0.05) / (e + 0.05);
        },
        level(t) {
          const e = this.contrast(t);
          return e >= 7.1 ? 'AAA' : e >= 4.5 ? 'AA' : '';
        },
        isDark() {
          const t = this.rgb().color;
          return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128;
        },
        isLight() {
          return !this.isDark();
        },
        negate() {
          for (var t = this.rgb(), e = 0; e < 3; e++) t.color[e] = 255 - t.color[e];
          return t;
        },
        lighten(t) {
          const e = this.hsl();
          return (e.color[2] += e.color[2] * t), e;
        },
        darken(t) {
          const e = this.hsl();
          return (e.color[2] -= e.color[2] * t), e;
        },
        saturate(t) {
          const e = this.hsl();
          return (e.color[1] += e.color[1] * t), e;
        },
        desaturate(t) {
          const e = this.hsl();
          return (e.color[1] -= e.color[1] * t), e;
        },
        whiten(t) {
          const e = this.hwb();
          return (e.color[1] += e.color[1] * t), e;
        },
        blacken(t) {
          const e = this.hwb();
          return (e.color[2] += e.color[2] * t), e;
        },
        grayscale() {
          const t = this.rgb().color;
          const e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2];
          return h.rgb(e, e, e);
        },
        fade(t) {
          return this.alpha(this.valpha - this.valpha * t);
        },
        opaquer(t) {
          return this.alpha(this.valpha + this.valpha * t);
        },
        rotate(t) {
          const e = this.hsl();
          let n = e.color[0];
          return (n = (n = (n + t) % 360) < 0 ? 360 + n : n), (e.color[0] = n), e;
        },
        mix(t, e) {
          if (!t || !t.rgb)
            throw new Error(
              `Argument to "mix" was not a Color instance, but rather an instance of ${r(t)}`,
            );
          const n = t.rgb();
          const i = this.rgb();
          const o = void 0 === e ? 0.5 : e;
          const a = 2 * o - 1;
          const s = n.alpha() - i.alpha();
          const u = ((a * s == -1 ? a : (a + s) / (1 + a * s)) + 1) / 2;
          const c = 1 - u;
          return h.rgb(
            u * n.red() + c * i.red(),
            u * n.green() + c * i.green(),
            u * n.blue() + c * i.blue(),
            n.alpha() * o + i.alpha() * (1 - o),
          );
        },
      }),
        Object.keys(o).forEach((t) => {
          if (s.indexOf(t) === -1) {
            const e = o[t].channels;
            (h.prototype[t] = function () {
              if (this.model === t) return new h(this);
              if (arguments.length) return new h(arguments, t);
              const n = typeof arguments[e] === 'number' ? e : this.valpha;
              return new h(d(o[this.model][t].raw(this.color)).concat(n), t);
            }),
              (h[t] = function (n) {
                return typeof n === 'number' && (n = p(a.call(arguments), e)), new h(n, t);
              });
          }
        }),
        (t.exports = h);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      let r;
      const i = (r = n(55)) && r.__esModule ? r : { default: r };
      const o = n(26);
      const a = n(18);
      class s extends i.default {
        constructor() {
          super(...arguments);
        }

        attrTest(t) {
          const e = this.options.pointers;
          return e === 0 || t.pointers.length === e;
        }

        process(t) {
          const { state: e } = this;
          const { eventType: n } = t;
          const r = e & (o.STATE_BEGAN | o.STATE_CHANGED);
          const i = this.attrTest(t);
          return r && (n & a.INPUT_CANCEL || !i)
            ? e | o.STATE_CANCELLED
            : r || i
            ? n & a.INPUT_END
              ? e | o.STATE_ENDED
              : e & o.STATE_BEGAN
              ? e | o.STATE_CHANGED
              : o.STATE_BEGAN
            : o.STATE_FAILED;
        }
      }
      (e.default = s), (s.prototype.defaults = { pointers: 1 });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = n(26);
      const i = f(n(65));
      const o = f(n(237));
      const a = f(n(125));
      const s = f(n(127));
      const u = f(n(56));
      const c = f(n(66));
      const h = f(n(238));
      const l = f(n(239));
      function f(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class d {
        constructor(t) {
          (this.options = (0, i.default)({}, this.defaults, t || {})),
            (this.id = (0, o.default)()),
            (this.manager = null),
            (this.options.enable = (0, a.default)(this.options.enable, !0)),
            (this.state = r.STATE_POSSIBLE),
            (this.simultaneous = {}),
            (this.requireFail = []);
        }

        set(t) {
          return (
            (0, i.default)(this.options, t), this.manager && this.manager.touchAction.update(), this
          );
        }

        recognizeWith(t) {
          if ((0, s.default)(t, 'recognizeWith', this)) return this;
          const { simultaneous: e } = this;
          return (
            e[(t = (0, h.default)(t, this)).id] || ((e[t.id] = t), t.recognizeWith(this)), this
          );
        }

        dropRecognizeWith(t) {
          return (
            (0, s.default)(t, 'dropRecognizeWith', this) ||
              ((t = (0, h.default)(t, this)), delete this.simultaneous[t.id]),
            this
          );
        }

        requireFailure(t) {
          if ((0, s.default)(t, 'requireFailure', this)) return this;
          const { requireFail: e } = this;
          return (
            (t = (0, h.default)(t, this)),
            (0, u.default)(e, t) === -1 && (e.push(t), t.requireFailure(this)),
            this
          );
        }

        dropRequireFailure(t) {
          if ((0, s.default)(t, 'dropRequireFailure', this)) return this;
          t = (0, h.default)(t, this);
          const e = (0, u.default)(this.requireFail, t);
          return e > -1 && this.requireFail.splice(e, 1), this;
        }

        hasRequireFailures() {
          return this.requireFail.length > 0;
        }

        canRecognizeWith(t) {
          return !!this.simultaneous[t.id];
        }

        emit(t) {
          const e = this;
          const { state: n } = this;
          function i(n) {
            e.manager.emit(n, t);
          }
          n < r.STATE_ENDED && i(e.options.event + (0, l.default)(n)),
            i(e.options.event),
            t.additionalEvent && i(t.additionalEvent),
            n >= r.STATE_ENDED && i(e.options.event + (0, l.default)(n));
        }

        tryEmit(t) {
          if (this.canEmit()) return this.emit(t);
          this.state = r.STATE_FAILED;
        }

        canEmit() {
          let t = 0;
          for (; t < this.requireFail.length; ) {
            if (!(this.requireFail[t].state & (r.STATE_FAILED | r.STATE_POSSIBLE))) return !1;
            t++;
          }
          return !0;
        }

        recognize(t) {
          const e = (0, i.default)({}, t);
          if (!(0, c.default)(this.options.enable, [this, e]))
            return this.reset(), void (this.state = r.STATE_FAILED);
          this.state & (r.STATE_RECOGNIZED | r.STATE_CANCELLED | r.STATE_FAILED) &&
            (this.state = r.STATE_POSSIBLE),
            (this.state = this.process(e)),
            this.state & (r.STATE_BEGAN | r.STATE_CHANGED | r.STATE_ENDED | r.STATE_CANCELLED) &&
              this.tryEmit(e);
        }

        process(t) {}

        getTouchAction() {}

        reset() {}
      }
      (e.default = d), (d.prototype.defaults = {});
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          if (t.indexOf && !n) return t.indexOf(e);
          {
            let r = 0;
            for (; r < t.length; ) {
              if ((n && t[r][n] == e) || (!n && t[r] === e)) return r;
              r++;
            }
            return -1;
          }
        });
    },
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      let r;
      const i =
        (this && this.__extends) ||
        ((r = function (t, e) {
          return (r =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (t, e) {
                t.__proto__ = e;
              }) ||
            function (t, e) {
              for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            })(t, e);
        }),
        function (t, e) {
          if (typeof e !== 'function' && e !== null)
            throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`);
          function n() {
            this.constructor = t;
          }
          r(t, e),
            (t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n()));
        });
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.getLayoutByName = e.unRegisterLayout = e.registerLayout = void 0);
      const o = n(7);
      const a = n(10);
      const s = new Map();
      e.registerLayout = function (t, e) {
        if (
          (s.get(t) &&
            console.warn(`The layout with the name ${t} exists already, it will be overridden`),
          a.isObject(e))
        ) {
          const n = (function (t) {
            function n(n) {
              const r = t.call(this) || this;
              const i = r;
              const o = {};
              const a = i.getDefaultCfg();
              return (
                Object.assign(o, a, e, n),
                Object.keys(o).forEach((t) => {
                  const e = o[t];
                  i[t] = e;
                }),
                r
              );
            }
            return i(n, t), n;
          })(o.Base);
          s.set(t, n);
        } else s.set(t, e);
      };
      e.unRegisterLayout = function (t) {
        s.has(t) && s.delete(t);
      };
      e.getLayoutByName = function (t) {
        return s.has(t) ? s.get(t) : null;
      };
    },
    function (t, e, n) {
      'use strict';
      let r;
      const i =
        (this && this.__extends) ||
        ((r = function (t, e) {
          return (r =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (t, e) {
                t.__proto__ = e;
              }) ||
            function (t, e) {
              for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            })(t, e);
        }),
        function (t, e) {
          if (typeof e !== 'function' && e !== null)
            throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`);
          function n() {
            this.constructor = t;
          }
          r(t, e),
            (t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n()));
        });
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.RandomLayout = void 0);
      const o = (function (t) {
        function e(e) {
          const n = t.call(this) || this;
          return (
            (n.center = [0, 0]),
            (n.width = 300),
            (n.height = 300),
            (n.nodes = []),
            (n.edges = []),
            (n.onLayoutEnd = function () {}),
            n.updateCfg(e),
            n
          );
        }
        return (
          i(e, t),
          (e.prototype.getDefaultCfg = function () {
            return { center: [0, 0], width: 300, height: 300 };
          }),
          (e.prototype.execute = function () {
            const t = this;
            const e = t.nodes;
            const n = t.center;
            return (
              t.width || typeof window === 'undefined' || (t.width = window.innerWidth),
              t.height || typeof window === 'undefined' || (t.height = window.innerHeight),
              e &&
                e.forEach((e) => {
                  (e.x = 0.9 * (Math.random() - 0.5) * t.width + n[0]),
                    (e.y = 0.9 * (Math.random() - 0.5) * t.height + n[1]);
                }),
              t.onLayoutEnd && t.onLayoutEnd(),
              { nodes: e, edges: this.edges }
            );
          }),
          (e.prototype.getType = function () {
            return 'random';
          }),
          e
        );
      })(n(7).Base);
      e.RandomLayout = o;
    },
    function (t, e, n) {
      'use strict';
      let r;
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = void 0),
        (r =
          typeof Object.assign !== 'function'
            ? function (t) {
                if (t == null) throw new TypeError('Cannot convert undefined or null to object');
                const e = Object(t);
                for (let t = 1; t < arguments.length; t++) {
                  const n = arguments[t];
                  if (n != null) for (const t in n) n.hasOwnProperty(t) && (e[t] = n[t]);
                }
                return e;
              }
            : Object.assign);
      const i = r;
      e.default = i;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          if (typeof t === r.TYPE_FUNCTION) return t.apply((e && e[0]) || void 0, e);
          return t;
        });
      var r = n(31);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          return t.trim().split(/\s+/g);
        });
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      const r = (function () {
        function t(t, e) {
          (this.bubbles = !0),
            (this.target = null),
            (this.currentTarget = null),
            (this.delegateTarget = null),
            (this.delegateObject = null),
            (this.defaultPrevented = !1),
            (this.propagationStopped = !1),
            (this.shape = null),
            (this.fromShape = null),
            (this.toShape = null),
            (this.propagationPath = []),
            (this.type = t),
            (this.name = t),
            (this.originalEvent = e),
            (this.timeStamp = e.timeStamp);
        }
        return (
          (t.prototype.preventDefault = function () {
            (this.defaultPrevented = !0),
              this.originalEvent.preventDefault && this.originalEvent.preventDefault();
          }),
          (t.prototype.stopPropagation = function () {
            this.propagationStopped = !0;
          }),
          (t.prototype.toString = function () {
            return `[Event (type=${this.type})]`;
          }),
          (t.prototype.save = function () {}),
          (t.prototype.restore = function () {}),
          t
        );
      })();
      e.a = r;
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      const i = n(89);
      const o = n(5);
      const a = (function (t) {
        function e(e) {
          const n = t.call(this) || this;
          n.destroyed = !1;
          const r = n.getDefaultCfg();
          return (n.cfg = Object(o.i)(r, e)), n;
        }
        return (
          Object(r.c)(e, t),
          (e.prototype.getDefaultCfg = function () {
            return {};
          }),
          (e.prototype.get = function (t) {
            return this.cfg[t];
          }),
          (e.prototype.set = function (t, e) {
            this.cfg[t] = e;
          }),
          (e.prototype.destroy = function () {
            (this.cfg = { destroyed: !0 }), this.off(), (this.destroyed = !0);
          }),
          e
        );
      })(i.a);
      e.a = a;
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'a', () => {
        return i;
      });
      let r = null;
      function i() {
        if (!r) {
          const t = document.createElement('canvas');
          (t.width = 1), (t.height = 1), (r = t.getContext('2d'));
        }
        return r;
      }
    },
    function (t, e, n) {
      'use strict';
      const r = (function () {
        function t() {
          this._events = {};
        }
        return (
          (t.prototype.on = function (t, e, n) {
            return (
              this._events[t] || (this._events[t] = []),
              this._events[t].push({ callback: e, once: !!n }),
              this
            );
          }),
          (t.prototype.once = function (t, e) {
            return this.on(t, e, !0), this;
          }),
          (t.prototype.emit = function (t) {
            for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
            const i = this._events[t] || [];
            const o = this._events['*'] || [];
            const a = function (r) {
              for (let i = r.length, o = 0; o < i; o++)
                if (r[o]) {
                  const a = r[o];
                  const s = a.callback;
                  a.once && (r.splice(o, 1), r.length === 0 && delete e._events[t], i--, o--),
                    s.apply(e, n);
                }
            };
            a(i), a(o);
          }),
          (t.prototype.off = function (t, e) {
            if (t)
              if (e) {
                for (var n = this._events[t] || [], r = n.length, i = 0; i < r; i++)
                  n[i].callback === e && (n.splice(i, 1), r--, i--);
                n.length === 0 && delete this._events[t];
              } else delete this._events[t];
            else this._events = {};
            return this;
          }),
          (t.prototype.getEvents = function () {
            return this._events;
          }),
          t
        );
      })();
      e.a = r;
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      const i = n(0);
      const o = n(91);
      const a = n(5);
      const s = {};
      const u = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          Object(r.c)(e, t),
          (e.prototype.isCanvas = function () {
            return !1;
          }),
          (e.prototype.getBBox = function () {
            let t = 1 / 0;
            let e = -1 / 0;
            let n = 1 / 0;
            let r = -1 / 0;
            const o = [];
            const s = [];
            const u = this.getChildren().filter((t) => {
              return (
                t.get('visible') && (!t.isGroup() || (t.isGroup() && t.getChildren().length > 0))
              );
            });
            return (
              u.length > 0
                ? (Object(a.a)(u, (t) => {
                    const e = t.getBBox();
                    o.push(e.minX, e.maxX), s.push(e.minY, e.maxY);
                  }),
                  (t = Object(i.q)(o)),
                  (e = Object(i.p)(o)),
                  (n = Object(i.q)(s)),
                  (r = Object(i.p)(s)))
                : ((t = 0), (e = 0), (n = 0), (r = 0)),
              { x: t, y: n, minX: t, minY: n, maxX: e, maxY: r, width: e - t, height: r - n }
            );
          }),
          (e.prototype.getCanvasBBox = function () {
            let t = 1 / 0;
            let e = -1 / 0;
            let n = 1 / 0;
            let r = -1 / 0;
            const o = [];
            const s = [];
            const u = this.getChildren().filter((t) => {
              return (
                t.get('visible') && (!t.isGroup() || (t.isGroup() && t.getChildren().length > 0))
              );
            });
            return (
              u.length > 0
                ? (Object(a.a)(u, (t) => {
                    const e = t.getCanvasBBox();
                    o.push(e.minX, e.maxX), s.push(e.minY, e.maxY);
                  }),
                  (t = Object(i.q)(o)),
                  (e = Object(i.p)(o)),
                  (n = Object(i.q)(s)),
                  (r = Object(i.p)(s)))
                : ((t = 0), (e = 0), (n = 0), (r = 0)),
              { x: t, y: n, minX: t, minY: n, maxX: e, maxY: r, width: e - t, height: r - n }
            );
          }),
          (e.prototype.getDefaultCfg = function () {
            const e = t.prototype.getDefaultCfg.call(this);
            return (e.children = []), e;
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            if ((t.prototype.onAttrChange.call(this, e, n, r), e === 'matrix')) {
              const i = this.getTotalMatrix();
              this._applyChildrenMarix(i);
            }
          }),
          (e.prototype.applyMatrix = function (e) {
            const n = this.getTotalMatrix();
            t.prototype.applyMatrix.call(this, e);
            const r = this.getTotalMatrix();
            r !== n && this._applyChildrenMarix(r);
          }),
          (e.prototype._applyChildrenMarix = function (t) {
            const e = this.getChildren();
            Object(a.a)(e, (e) => {
              e.applyMatrix(t);
            });
          }),
          (e.prototype.addShape = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            const n = t[0];
            let r = t[1];
            Object(a.f)(n) ? (r = n) : (r.type = n);
            let i = s[r.type];
            i || ((i = Object(a.k)(r.type)), (s[r.type] = i));
            const o = this.getShapeBase();
            const u = new o[i](r);
            return this.add(u), u;
          }),
          (e.prototype.addGroup = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            let n;
            const r = t[0];
            const i = t[1];
            if (Object(a.d)(r)) n = new r(i || { parent: this });
            else {
              const o = r || {};
              const s = this.getGroupBase();
              n = new s(o);
            }
            return this.add(n), n;
          }),
          (e.prototype.getCanvas = function () {
            return this.isCanvas() ? this : this.get('canvas');
          }),
          (e.prototype.getShape = function (t, e, n) {
            if (!Object(a.b)(this)) return null;
            let r;
            const i = this.getChildren();
            if (this.isCanvas()) r = this._findShape(i, t, e, n);
            else {
              let o = [t, e, 1];
              (o = this.invertFromMatrix(o)),
                this.isClipped(o[0], o[1]) || (r = this._findShape(i, o[0], o[1], n));
            }
            return r;
          }),
          (e.prototype._findShape = function (t, e, n, r) {
            for (var i = null, o = t.length - 1; o >= 0; o--) {
              const s = t[o];
              if (
                (Object(a.b)(s) &&
                  (s.isGroup() ? (i = s.getShape(e, n, r)) : s.isHit(e, n) && (i = s)),
                i)
              )
                break;
            }
            return i;
          }),
          (e.prototype.add = function (t) {
            const e = this.getCanvas();
            const n = this.getChildren();
            const r = this.get('timeline');
            const i = t.getParent();
            i &&
              (function (t, e, n) {
                void 0 === n && (n = !0),
                  n ? e.destroy() : (e.set('parent', null), e.set('canvas', null)),
                  Object(a.j)(t.getChildren(), e);
              })(i, t, !1),
              t.set('parent', this),
              e &&
                (function t(e, n) {
                  if ((e.set('canvas', n), e.isGroup())) {
                    const r = e.get('children');
                    r.length &&
                      r.forEach((e) => {
                        t(e, n);
                      });
                  }
                })(t, e),
              r &&
                (function t(e, n) {
                  if ((e.set('timeline', n), e.isGroup())) {
                    const r = e.get('children');
                    r.length &&
                      r.forEach((e) => {
                        t(e, n);
                      });
                  }
                })(t, r),
              n.push(t),
              t.onCanvasChange('add'),
              this._applyElementMatrix(t);
          }),
          (e.prototype._applyElementMatrix = function (t) {
            const e = this.getTotalMatrix();
            e && t.applyMatrix(e);
          }),
          (e.prototype.getChildren = function () {
            return this.get('children');
          }),
          (e.prototype.sort = function () {
            let t;
            const e = this.getChildren();
            Object(a.a)(e, (t, e) => {
              return (t._INDEX = e), t;
            }),
              e.sort(
                ((t = function (t, e) {
                  return t.get('zIndex') - e.get('zIndex');
                }),
                function (e, n) {
                  const r = t(e, n);
                  return r === 0 ? e._INDEX - n._INDEX : r;
                }),
              ),
              this.onCanvasChange('sort');
          }),
          (e.prototype.clear = function () {
            if ((this.set('clearing', !0), !this.destroyed)) {
              for (let t = this.getChildren(), e = t.length - 1; e >= 0; e--) t[e].destroy();
              this.set('children', []), this.onCanvasChange('clear'), this.set('clearing', !1);
            }
          }),
          (e.prototype.destroy = function () {
            this.get('destroyed') || (this.clear(), t.prototype.destroy.call(this));
          }),
          (e.prototype.getFirst = function () {
            return this.getChildByIndex(0);
          }),
          (e.prototype.getLast = function () {
            const t = this.getChildren();
            return this.getChildByIndex(t.length - 1);
          }),
          (e.prototype.getChildByIndex = function (t) {
            return this.getChildren()[t];
          }),
          (e.prototype.getCount = function () {
            return this.getChildren().length;
          }),
          (e.prototype.contain = function (t) {
            return this.getChildren().indexOf(t) > -1;
          }),
          (e.prototype.removeChild = function (t, e) {
            void 0 === e && (e = !0), this.contain(t) && t.remove(e);
          }),
          (e.prototype.findAll = function (t) {
            let e = [];
            const n = this.getChildren();
            return (
              Object(a.a)(n, (n) => {
                t(n) && e.push(n), n.isGroup() && (e = e.concat(n.findAll(t)));
              }),
              e
            );
          }),
          (e.prototype.find = function (t) {
            let e = null;
            const n = this.getChildren();
            return (
              Object(a.a)(n, (n) => {
                if ((t(n) ? (e = n) : n.isGroup() && (e = n.find(t)), e)) return !1;
              }),
              e
            );
          }),
          (e.prototype.findById = function (t) {
            return this.find((e) => {
              return e.get('id') === t;
            });
          }),
          (e.prototype.findByClassName = function (t) {
            return this.find((e) => {
              return e.get('className') === t;
            });
          }),
          (e.prototype.findAllByName = function (t) {
            return this.findAll((e) => {
              return e.get('name') === t;
            });
          }),
          e
        );
      })(o.a);
      e.a = u;
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      const i = n(0);
      const o = n(4);
      const a = n(5);
      const s = n(21);
      const u = n(87);
      const c = o.a.transform;
      const h = ['zIndex', 'capture', 'visible', 'type'];
      const l = ['repeat'];
      function f(t, e) {
        const n = {};
        const r = e.attrs;
        for (const i in t) n[i] = r[i];
        return n;
      }
      function d(t, e) {
        const n = {};
        const r = e.attr();
        return (
          Object(i.c)(t, (t, e) => {
            l.indexOf(e) !== -1 || Object(i.h)(r[e], t) || (n[e] = t);
          }),
          n
        );
      }
      function p(t, e) {
        if (e.onFrame) return t;
        const n = e.startTime;
        const r = e.delay;
        const o = e.duration;
        const a = Object.prototype.hasOwnProperty;
        return (
          Object(i.c)(t, (t) => {
            n + r < t.startTime + t.delay + t.duration &&
              o > t.delay &&
              Object(i.c)(e.toAttrs, (e, n) => {
                a.call(t.toAttrs, n) && (delete t.toAttrs[n], delete t.fromAttrs[n]);
              });
          }),
          t
        );
      }
      const g = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          n.attrs = {};
          const r = n.getDefaultAttrs();
          return Object(i.r)(r, e.attrs), (n.attrs = r), n.initAttrs(r), n.initAnimate(), n;
        }
        return (
          Object(r.c)(e, t),
          (e.prototype.getDefaultCfg = function () {
            return { visible: !0, capture: !0, zIndex: 0 };
          }),
          (e.prototype.getDefaultAttrs = function () {
            return { matrix: this.getDefaultMatrix(), opacity: 1 };
          }),
          (e.prototype.onCanvasChange = function (t) {}),
          (e.prototype.initAttrs = function (t) {}),
          (e.prototype.initAnimate = function () {
            this.set('animable', !0), this.set('animating', !1);
          }),
          (e.prototype.isGroup = function () {
            return !1;
          }),
          (e.prototype.getParent = function () {
            return this.get('parent');
          }),
          (e.prototype.getCanvas = function () {
            return this.get('canvas');
          }),
          (e.prototype.attr = function () {
            for (var t, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
            const r = e[0];
            const o = e[1];
            if (!r) return this.attrs;
            if (Object(i.m)(r)) {
              for (const a in r) this.setAttr(a, r[a]);
              return this.afterAttrsChange(r), this;
            }
            return e.length === 2
              ? (this.setAttr(r, o), this.afterAttrsChange((((t = {})[r] = o), t)), this)
              : this.attrs[r];
          }),
          (e.prototype.isClipped = function (t, e) {
            const n = this.getClip();
            return n && !n.isHit(t, e);
          }),
          (e.prototype.setAttr = function (t, e) {
            const n = this.attrs[t];
            n !== e && ((this.attrs[t] = e), this.onAttrChange(t, e, n));
          }),
          (e.prototype.onAttrChange = function (t, e, n) {
            t === 'matrix' && this.set('totalMatrix', null);
          }),
          (e.prototype.afterAttrsChange = function (t) {
            if (this.cfg.isClipShape) {
              const e = this.cfg.applyTo;
              e && e.onCanvasChange('clip');
            } else this.onCanvasChange('attr');
          }),
          (e.prototype.show = function () {
            return this.set('visible', !0), this.onCanvasChange('show'), this;
          }),
          (e.prototype.hide = function () {
            return this.set('visible', !1), this.onCanvasChange('hide'), this;
          }),
          (e.prototype.setZIndex = function (t) {
            this.set('zIndex', t);
            const e = this.getParent();
            return e && e.sort(), this;
          }),
          (e.prototype.toFront = function () {
            const t = this.getParent();
            if (t) {
              const e = t.getChildren();
              const n = (this.get('el'), e.indexOf(this));
              e.splice(n, 1), e.push(this), this.onCanvasChange('zIndex');
            }
          }),
          (e.prototype.toBack = function () {
            const t = this.getParent();
            if (t) {
              const e = t.getChildren();
              const n = (this.get('el'), e.indexOf(this));
              e.splice(n, 1), e.unshift(this), this.onCanvasChange('zIndex');
            }
          }),
          (e.prototype.remove = function (t) {
            void 0 === t && (t = !0);
            const e = this.getParent();
            e
              ? (Object(a.j)(e.getChildren(), this),
                e.get('clearing') || this.onCanvasChange('remove'))
              : this.onCanvasChange('remove'),
              t && this.destroy();
          }),
          (e.prototype.resetMatrix = function () {
            this.attr('matrix', this.getDefaultMatrix()), this.onCanvasChange('matrix');
          }),
          (e.prototype.getMatrix = function () {
            return this.attr('matrix');
          }),
          (e.prototype.setMatrix = function (t) {
            this.attr('matrix', t), this.onCanvasChange('matrix');
          }),
          (e.prototype.getTotalMatrix = function () {
            let t = this.cfg.totalMatrix;
            if (!t) {
              const e = this.attr('matrix');
              const n = this.cfg.parentMatrix;
              (t = n && e ? Object(s.b)(n, e) : e || n), this.set('totalMatrix', t);
            }
            return t;
          }),
          (e.prototype.applyMatrix = function (t) {
            const e = this.attr('matrix');
            let n = null;
            (n = t && e ? Object(s.b)(t, e) : e || t),
              this.set('totalMatrix', n),
              this.set('parentMatrix', t);
          }),
          (e.prototype.getDefaultMatrix = function () {
            return null;
          }),
          (e.prototype.applyToMatrix = function (t) {
            const e = this.attr('matrix');
            return e ? Object(s.c)(e, t) : t;
          }),
          (e.prototype.invertFromMatrix = function (t) {
            const e = this.attr('matrix');
            if (e) {
              const n = Object(s.a)(e);
              if (n) return Object(s.c)(n, t);
            }
            return t;
          }),
          (e.prototype.setClip = function (t) {
            const e = this.getCanvas();
            let n = null;
            if (t) {
              const r = this.getShapeBase()[Object(i.w)(t.type)];
              r &&
                (n = new r({
                  type: t.type,
                  isClipShape: !0,
                  applyTo: this,
                  attrs: t.attrs,
                  canvas: e,
                }));
            }
            return this.set('clipShape', n), this.onCanvasChange('clip'), n;
          }),
          (e.prototype.getClip = function () {
            const t = this.cfg.clipShape;
            return t || null;
          }),
          (e.prototype.clone = function () {
            const t = this;
            const e = this.attrs;
            const n = {};
            Object(i.c)(e, (t, r) => {
              Object(i.f)(e[r])
                ? (n[r] = (function (t) {
                    for (var e = [], n = 0; n < t.length; n++)
                      Object(i.f)(t[n]) ? e.push([].concat(t[n])) : e.push(t[n]);
                    return e;
                  })(e[r]))
                : (n[r] = e[r]);
            });
            const r = new (0, this.constructor)({ attrs: n });
            return (
              Object(i.c)(h, (e) => {
                r.set(e, t.get(e));
              }),
              r
            );
          }),
          (e.prototype.destroy = function () {
            this.destroyed || ((this.attrs = {}), t.prototype.destroy.call(this));
          }),
          (e.prototype.isAnimatePaused = function () {
            return this.get('_pause').isPaused;
          }),
          (e.prototype.animate = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            if (this.get('timeline') || this.get('canvas')) {
              this.set('animating', !0);
              let n = this.get('timeline');
              n || ((n = this.get('canvas').get('timeline')), this.set('timeline', n));
              let r = this.get('animations') || [];
              n.timer || n.initTimer();
              let o;
              let a;
              let s;
              let u;
              let c;
              let h = t[0];
              let l = t[1];
              const g = t[2];
              let v = void 0 === g ? 'easeLinear' : g;
              const y = t[3];
              let m = void 0 === y ? i.t : y;
              const b = t[4];
              let x = void 0 === b ? 0 : b;
              Object(i.i)(h)
                ? ((o = h), (h = {}))
                : Object(i.m)(h) && h.onFrame && ((o = h.onFrame), (a = h.repeat)),
                Object(i.m)(l)
                  ? ((l = (c = l).duration),
                    (v = c.easing || 'easeLinear'),
                    (x = c.delay || 0),
                    (a = c.repeat || a || !1),
                    (m = c.callback || i.t),
                    (s = c.pauseCallback || i.t),
                    (u = c.resumeCallback || i.t))
                  : (Object(i.k)(m) && ((x = m), (m = null)),
                    Object(i.i)(v) ? ((m = v), (v = 'easeLinear')) : (v = v || 'easeLinear'));
              const M = d(h, this);
              const S = {
                fromAttrs: f(M, this),
                toAttrs: M,
                duration: l,
                easing: v,
                repeat: a,
                callback: m,
                pauseCallback: s,
                resumeCallback: u,
                delay: x,
                startTime: n.getTime(),
                id: Object(i.v)(),
                onFrame: o,
                pathFormatted: !1,
              };
              r.length > 0 ? (r = p(r, S)) : n.addAnimator(this),
                r.push(S),
                this.set('animations', r),
                this.set('_pause', { isPaused: !1 });
            }
          }),
          (e.prototype.stopAnimate = function (t) {
            const e = this;
            void 0 === t && (t = !0);
            const n = this.get('animations');
            Object(i.c)(n, (n) => {
              t && (n.onFrame ? e.attr(n.onFrame(1)) : e.attr(n.toAttrs)),
                n.callback && n.callback();
            }),
              this.set('animating', !1),
              this.set('animations', []);
          }),
          (e.prototype.pauseAnimate = function () {
            const t = this.get('timeline');
            const e = this.get('animations');
            const n = t.getTime();
            return (
              Object(i.c)(e, (t) => {
                (t._paused = !0), (t._pauseTime = n), t.pauseCallback && t.pauseCallback();
              }),
              this.set('_pause', { isPaused: !0, pauseTime: n }),
              this
            );
          }),
          (e.prototype.resumeAnimate = function () {
            const t = this.get('timeline').getTime();
            const e = this.get('animations');
            const n = this.get('_pause').pauseTime;
            return (
              Object(i.c)(e, (e) => {
                (e.startTime += t - n),
                  (e._paused = !1),
                  (e._pauseTime = null),
                  e.resumeCallback && e.resumeCallback();
              }),
              this.set('_pause', { isPaused: !1 }),
              this.set('animations', e),
              this
            );
          }),
          (e.prototype.emitDelegation = function (t, e) {
            let n;
            const r = this;
            const o = e.propagationPath;
            this.getEvents();
            t === 'mouseenter' ? (n = e.fromShape) : t === 'mouseleave' && (n = e.toShape);
            for (
              var s = function (t) {
                  const s = o[t];
                  const c = s.get('name');
                  if (c) {
                    if ((s.isGroup() || (s.isCanvas && s.isCanvas())) && n && Object(a.g)(s, n))
                      return 'break';
                    Object(i.f)(c)
                      ? Object(i.c)(c, (t) => {
                          r.emitDelegateEvent(s, t, e);
                        })
                      : u.emitDelegateEvent(s, c, e);
                  }
                },
                u = this,
                c = 0;
              c < o.length;
              c++
            ) {
              if (s(c) === 'break') break;
            }
          }),
          (e.prototype.emitDelegateEvent = function (t, e, n) {
            const r = this.getEvents();
            const i = `${e}:${n.type}`;
            (r[i] || r['*']) &&
              ((n.name = i),
              (n.currentTarget = t),
              (n.delegateTarget = this),
              (n.delegateObject = t.get('delegateObject')),
              this.emit(i, n));
          }),
          (e.prototype.translate = function (t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            const n = this.getMatrix();
            const r = c(n, [['t', t, e]]);
            return this.setMatrix(r), this;
          }),
          (e.prototype.move = function (t, e) {
            const n = this.attr('x') || 0;
            const r = this.attr('y') || 0;
            return this.translate(t - n, e - r), this;
          }),
          (e.prototype.moveTo = function (t, e) {
            return this.move(t, e);
          }),
          (e.prototype.scale = function (t, e) {
            const n = this.getMatrix();
            const r = c(n, [['s', t, e || t]]);
            return this.setMatrix(r), this;
          }),
          (e.prototype.rotate = function (t) {
            const e = this.getMatrix();
            const n = c(e, [['r', t]]);
            return this.setMatrix(n), this;
          }),
          (e.prototype.rotateAtStart = function (t) {
            const e = this.attr();
            const n = e.x;
            const r = e.y;
            const i = this.getMatrix();
            const o = c(i, [
              ['t', -n, -r],
              ['r', t],
              ['t', n, r],
            ]);
            return this.setMatrix(o), this;
          }),
          (e.prototype.rotateAtPoint = function (t, e, n) {
            const r = this.getMatrix();
            const i = c(r, [
              ['t', -t, -e],
              ['r', n],
              ['t', t, e],
            ]);
            return this.setMatrix(i), this;
          }),
          e
        );
      })(u.a);
      e.a = g;
    },
    function (t, e, n) {
      'use strict';
      n.d(e, 'b', () => {
        return Qa;
      });
      const r = {};
      n.r(r),
        n.d(r, 'catmullRomToBezier', () => {
          return b;
        }),
        n.d(r, 'fillPath', () => {
          return X;
        }),
        n.d(r, 'fillPathByDiff', () => {
          return G;
        }),
        n.d(r, 'formatPath', () => {
          return q;
        }),
        n.d(r, 'intersection', () => {
          return R;
        }),
        n.d(r, 'parsePathArray', () => {
          return k;
        }),
        n.d(r, 'parsePathString', () => {
          return m;
        }),
        n.d(r, 'pathToAbsolute', () => {
          return M;
        }),
        n.d(r, 'pathToCurve', () => {
          return C;
        }),
        n.d(r, 'rectPath', () => {
          return N;
        });
      const i = {};
      n.r(i),
        n.d(i, 'create', () => {
          return it;
        }),
        n.d(i, 'fromMat4', () => {
          return ot;
        }),
        n.d(i, 'clone', () => {
          return at;
        }),
        n.d(i, 'copy', () => {
          return st;
        }),
        n.d(i, 'fromValues', () => {
          return ut;
        }),
        n.d(i, 'set', () => {
          return ct;
        }),
        n.d(i, 'identity', () => {
          return ht;
        }),
        n.d(i, 'transpose', () => {
          return lt;
        }),
        n.d(i, 'invert', () => {
          return ft;
        }),
        n.d(i, 'adjoint', () => {
          return dt;
        }),
        n.d(i, 'determinant', () => {
          return pt;
        }),
        n.d(i, 'multiply', () => {
          return gt;
        }),
        n.d(i, 'translate', () => {
          return vt;
        }),
        n.d(i, 'rotate', () => {
          return yt;
        }),
        n.d(i, 'scale', () => {
          return mt;
        }),
        n.d(i, 'fromTranslation', () => {
          return bt;
        }),
        n.d(i, 'fromRotation', () => {
          return xt;
        }),
        n.d(i, 'fromScaling', () => {
          return Mt;
        }),
        n.d(i, 'fromMat2d', () => {
          return St;
        }),
        n.d(i, 'fromQuat', () => {
          return wt;
        }),
        n.d(i, 'normalFromMat4', () => {
          return Ot;
        }),
        n.d(i, 'projection', () => {
          return Ct;
        }),
        n.d(i, 'str', () => {
          return Et;
        }),
        n.d(i, 'frob', () => {
          return kt;
        }),
        n.d(i, 'add', () => {
          return Tt;
        }),
        n.d(i, 'subtract', () => {
          return Pt;
        }),
        n.d(i, 'multiplyScalar', () => {
          return It;
        }),
        n.d(i, 'multiplyScalarAndAdd', () => {
          return At;
        }),
        n.d(i, 'exactEquals', () => {
          return jt;
        }),
        n.d(i, 'equals', () => {
          return Nt;
        }),
        n.d(i, 'mul', () => {
          return _t;
        }),
        n.d(i, 'sub', () => {
          return Bt;
        });
      const o = {};
      n.r(o),
        n.d(o, 'create', () => {
          return Lt;
        }),
        n.d(o, 'clone', () => {
          return Dt;
        }),
        n.d(o, 'fromValues', () => {
          return Rt;
        }),
        n.d(o, 'copy', () => {
          return Yt;
        }),
        n.d(o, 'set', () => {
          return Ft;
        }),
        n.d(o, 'add', () => {
          return Xt;
        }),
        n.d(o, 'subtract', () => {
          return zt;
        }),
        n.d(o, 'multiply', () => {
          return Wt;
        }),
        n.d(o, 'divide', () => {
          return Gt;
        }),
        n.d(o, 'ceil', () => {
          return Ut;
        }),
        n.d(o, 'floor', () => {
          return Ht;
        }),
        n.d(o, 'min', () => {
          return qt;
        }),
        n.d(o, 'max', () => {
          return Vt;
        }),
        n.d(o, 'round', () => {
          return Zt;
        }),
        n.d(o, 'scale', () => {
          return Kt;
        }),
        n.d(o, 'scaleAndAdd', () => {
          return $t;
        }),
        n.d(o, 'distance', () => {
          return Qt;
        }),
        n.d(o, 'squaredDistance', () => {
          return Jt;
        }),
        n.d(o, 'length', () => {
          return te;
        }),
        n.d(o, 'squaredLength', () => {
          return ee;
        }),
        n.d(o, 'negate', () => {
          return ne;
        }),
        n.d(o, 'inverse', () => {
          return re;
        }),
        n.d(o, 'normalize', () => {
          return ie;
        }),
        n.d(o, 'dot', () => {
          return oe;
        }),
        n.d(o, 'cross', () => {
          return ae;
        }),
        n.d(o, 'lerp', () => {
          return se;
        }),
        n.d(o, 'random', () => {
          return ue;
        }),
        n.d(o, 'transformMat2', () => {
          return ce;
        }),
        n.d(o, 'transformMat2d', () => {
          return he;
        }),
        n.d(o, 'transformMat3', () => {
          return le;
        }),
        n.d(o, 'transformMat4', () => {
          return fe;
        }),
        n.d(o, 'rotate', () => {
          return de;
        }),
        n.d(o, 'angle', () => {
          return pe;
        }),
        n.d(o, 'zero', () => {
          return ge;
        }),
        n.d(o, 'str', () => {
          return ve;
        }),
        n.d(o, 'exactEquals', () => {
          return ye;
        }),
        n.d(o, 'equals', () => {
          return me;
        }),
        n.d(o, 'len', () => {
          return xe;
        }),
        n.d(o, 'sub', () => {
          return Me;
        }),
        n.d(o, 'mul', () => {
          return Se;
        }),
        n.d(o, 'div', () => {
          return we;
        }),
        n.d(o, 'dist', () => {
          return Oe;
        }),
        n.d(o, 'sqrDist', () => {
          return Ce;
        }),
        n.d(o, 'sqrLen', () => {
          return Ee;
        }),
        n.d(o, 'forEach', () => {
          return ke;
        });
      const a = {};
      n.r(a),
        n.d(a, 'leftTranslate', () => {
          return Te;
        }),
        n.d(a, 'leftRotate', () => {
          return Pe;
        }),
        n.d(a, 'leftScale', () => {
          return Ie;
        }),
        n.d(a, 'transform', () => {
          return Ae;
        }),
        n.d(a, 'direction', () => {
          return je;
        }),
        n.d(a, 'angleTo', () => {
          return Ne;
        }),
        n.d(a, 'vertical', () => {
          return _e;
        });
      const s = {};
      n.r(s),
        n.d(s, 'easeLinear', () => {
          return fn;
        }),
        n.d(s, 'easeQuad', () => {
          return gn;
        }),
        n.d(s, 'easeQuadIn', () => {
          return dn;
        }),
        n.d(s, 'easeQuadOut', () => {
          return pn;
        }),
        n.d(s, 'easeQuadInOut', () => {
          return gn;
        }),
        n.d(s, 'easeCubic', () => {
          return mn;
        }),
        n.d(s, 'easeCubicIn', () => {
          return vn;
        }),
        n.d(s, 'easeCubicOut', () => {
          return yn;
        }),
        n.d(s, 'easeCubicInOut', () => {
          return mn;
        }),
        n.d(s, 'easePoly', () => {
          return Mn;
        }),
        n.d(s, 'easePolyIn', () => {
          return bn;
        }),
        n.d(s, 'easePolyOut', () => {
          return xn;
        }),
        n.d(s, 'easePolyInOut', () => {
          return Mn;
        }),
        n.d(s, 'easeSin', () => {
          return En;
        }),
        n.d(s, 'easeSinIn', () => {
          return On;
        }),
        n.d(s, 'easeSinOut', () => {
          return Cn;
        }),
        n.d(s, 'easeSinInOut', () => {
          return En;
        }),
        n.d(s, 'easeExp', () => {
          return In;
        }),
        n.d(s, 'easeExpIn', () => {
          return Tn;
        }),
        n.d(s, 'easeExpOut', () => {
          return Pn;
        }),
        n.d(s, 'easeExpInOut', () => {
          return In;
        }),
        n.d(s, 'easeCircle', () => {
          return Nn;
        }),
        n.d(s, 'easeCircleIn', () => {
          return An;
        }),
        n.d(s, 'easeCircleOut', () => {
          return jn;
        }),
        n.d(s, 'easeCircleInOut', () => {
          return Nn;
        }),
        n.d(s, 'easeBounce', () => {
          return Bn;
        }),
        n.d(s, 'easeBounceIn', () => {
          return _n;
        }),
        n.d(s, 'easeBounceOut', () => {
          return Bn;
        }),
        n.d(s, 'easeBounceInOut', () => {
          return Ln;
        }),
        n.d(s, 'easeBack', () => {
          return Yn;
        }),
        n.d(s, 'easeBackIn', () => {
          return Dn;
        }),
        n.d(s, 'easeBackOut', () => {
          return Rn;
        }),
        n.d(s, 'easeBackInOut', () => {
          return Yn;
        }),
        n.d(s, 'easeElastic', () => {
          return zn;
        }),
        n.d(s, 'easeElasticIn', () => {
          return Xn;
        }),
        n.d(s, 'easeElasticOut', () => {
          return zn;
        }),
        n.d(s, 'easeElasticInOut', () => {
          return Wn;
        });
      const u = {};
      n.r(u),
        n.d(u, 'distance', () => {
          return gi;
        }),
        n.d(u, 'isNumberEqual', () => {
          return vi;
        }),
        n.d(u, 'getBBoxByArray', () => {
          return yi;
        }),
        n.d(u, 'getBBoxRange', () => {
          return mi;
        }),
        n.d(u, 'piMod', () => {
          return bi;
        });
      const c = {};
      n.r(c),
        n.d(c, 'Base', () => {
          return na;
        }),
        n.d(c, 'Circle', () => {
          return ra;
        }),
        n.d(c, 'Ellipse', () => {
          return oa;
        }),
        n.d(c, 'Image', () => {
          return ua;
        }),
        n.d(c, 'Line', () => {
          return ha;
        }),
        n.d(c, 'Marker', () => {
          return fa;
        }),
        n.d(c, 'Path', () => {
          return Ma;
        }),
        n.d(c, 'Polygon', () => {
          return wa;
        }),
        n.d(c, 'Polyline', () => {
          return Oa;
        }),
        n.d(c, 'Rect', () => {
          return Ca;
        }),
        n.d(c, 'Text', () => {
          return Ea;
        });
      const h = n(1);
      /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
      var l = function (t, e) {
        return (l =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, e) {
              t.__proto__ = e;
            }) ||
          function (t, e) {
            for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
          })(t, e);
      };
      function f(t, e) {
        if (typeof e !== 'function' && e !== null)
          throw new TypeError(`Class extends value ${String(e)} is not a constructor or null`);
        function n() {
          this.constructor = t;
        }
        l(t, e),
          (t.prototype = e === null ? Object.create(e) : ((n.prototype = e.prototype), new n()));
      }
      var d = function () {
        return (d =
          Object.assign ||
          function (t) {
            for (var e, n = 1, r = arguments.length; n < r; n++)
              for (const i in (e = arguments[n]))
                Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t;
          }).apply(this, arguments);
      };
      Object.create;
      Object.create;
      const p = n(3);
      const g = '\t\n\v\f\r   ᠎             　\u2028\u2029';
      const v = new RegExp(
        `([a-z])[${g},]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[${g}]*,?[${g}]*)+)`,
        'ig',
      );
      const y = new RegExp(`(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[${g}]*,?[${g}]*`, 'ig');
      var m = function (t) {
        if (!t) return null;
        if (Object(p.isArray)(t)) return t;
        const e = { a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0 };
        const n = [];
        return (
          String(t).replace(v, (r, i, o) => {
            const a = [];
            let s = i.toLowerCase();
            if (
              (o.replace(y, (t, e) => {
                e && a.push(+e);
              }),
              s === 'm' &&
                a.length > 2 &&
                (n.push([i].concat(a.splice(0, 2))), (s = 'l'), (i = i === 'm' ? 'l' : 'L')),
              s === 'o' && a.length === 1 && n.push([i, a[0]]),
              s === 'r')
            )
              n.push([i].concat(a));
            else for (; a.length >= e[s] && (n.push([i].concat(a.splice(0, e[s]))), e[s]); );
            return t;
          }),
          n
        );
      };
      var b = function (t, e) {
        for (var n = [], r = 0, i = t.length; i - 2 * !e > r; r += 2) {
          const o = [
            { x: +t[r - 2], y: +t[r - 1] },
            { x: +t[r], y: +t[r + 1] },
            { x: +t[r + 2], y: +t[r + 3] },
            { x: +t[r + 4], y: +t[r + 5] },
          ];
          e
            ? r
              ? i - 4 === r
                ? (o[3] = { x: +t[0], y: +t[1] })
                : i - 2 === r && ((o[2] = { x: +t[0], y: +t[1] }), (o[3] = { x: +t[2], y: +t[3] }))
              : (o[0] = { x: +t[i - 2], y: +t[i - 1] })
            : i - 4 === r
            ? (o[3] = o[2])
            : r || (o[0] = { x: +t[r], y: +t[r + 1] }),
            n.push([
              'C',
              (-o[0].x + 6 * o[1].x + o[2].x) / 6,
              (-o[0].y + 6 * o[1].y + o[2].y) / 6,
              (o[1].x + 6 * o[2].x - o[3].x) / 6,
              (o[1].y + 6 * o[2].y - o[3].y) / 6,
              o[2].x,
              o[2].y,
            ]);
        }
        return n;
      };
      const x = function (t, e, n, r, i) {
        let o = [];
        if (
          (i === null && r === null && (r = n), (t = +t), (e = +e), (n = +n), (r = +r), i !== null)
        ) {
          const a = Math.PI / 180;
          const s = t + n * Math.cos(-r * a);
          const u = t + n * Math.cos(-i * a);
          o = [
            ['M', s, e + n * Math.sin(-r * a)],
            ['A', n, n, 0, +(i - r > 180), 0, u, e + n * Math.sin(-i * a)],
          ];
        } else
          o = [
            ['M', t, e],
            ['m', 0, -r],
            ['a', n, r, 0, 1, 1, 0, 2 * r],
            ['a', n, r, 0, 1, 1, 0, -2 * r],
            ['z'],
          ];
        return o;
      };
      var M = function (t) {
        if (!(t = m(t)) || !t.length) return [['M', 0, 0]];
        let e;
        let n;
        let r = [];
        let i = 0;
        let o = 0;
        let a = 0;
        let s = 0;
        let u = 0;
        t[0][0] === 'M' && ((a = i = +t[0][1]), (s = o = +t[0][2]), u++, (r[0] = ['M', i, o]));
        for (
          let c =
              t.length === 3 &&
              t[0][0] === 'M' &&
              t[1][0].toUpperCase() === 'R' &&
              t[2][0].toUpperCase() === 'Z',
            h = void 0,
            l = void 0,
            f = u,
            d = t.length;
          f < d;
          f++
        ) {
          if ((r.push((h = [])), (e = (l = t[f])[0]) !== e.toUpperCase()))
            switch (((h[0] = e.toUpperCase()), h[0])) {
              case 'A':
                (h[1] = l[1]),
                  (h[2] = l[2]),
                  (h[3] = l[3]),
                  (h[4] = l[4]),
                  (h[5] = l[5]),
                  (h[6] = +l[6] + i),
                  (h[7] = +l[7] + o);
                break;
              case 'V':
                h[1] = +l[1] + o;
                break;
              case 'H':
                h[1] = +l[1] + i;
                break;
              case 'R':
                for (var p = 2, g = (n = [i, o].concat(l.slice(1))).length; p < g; p++)
                  (n[p] = +n[p] + i), (n[++p] = +n[p] + o);
                r.pop(), (r = r.concat(b(n, c)));
                break;
              case 'O':
                r.pop(), (n = x(i, o, l[1], l[2])).push(n[0]), (r = r.concat(n));
                break;
              case 'U':
                r.pop(),
                  (r = r.concat(x(i, o, l[1], l[2], l[3]))),
                  (h = ['U'].concat(r[r.length - 1].slice(-2)));
                break;
              case 'M':
                (a = +l[1] + i), (s = +l[2] + o);
                break;
              default:
                for (p = 1, g = l.length; p < g; p++) h[p] = +l[p] + (p % 2 ? i : o);
            }
          else if (e === 'R')
            (n = [i, o].concat(l.slice(1))),
              r.pop(),
              (r = r.concat(b(n, c))),
              (h = ['R'].concat(l.slice(-2)));
          else if (e === 'O') r.pop(), (n = x(i, o, l[1], l[2])).push(n[0]), (r = r.concat(n));
          else if (e === 'U')
            r.pop(),
              (r = r.concat(x(i, o, l[1], l[2], l[3]))),
              (h = ['U'].concat(r[r.length - 1].slice(-2)));
          else for (let v = 0, y = l.length; v < y; v++) h[v] = l[v];
          if ((e = e.toUpperCase()) !== 'O')
            switch (h[0]) {
              case 'Z':
                (i = +a), (o = +s);
                break;
              case 'H':
                i = h[1];
                break;
              case 'V':
                o = h[1];
                break;
              case 'M':
                (a = h[h.length - 2]), (s = h[h.length - 1]);
                break;
              default:
                (i = h[h.length - 2]), (o = h[h.length - 1]);
            }
        }
        return r;
      };
      const S = function (t, e, n, r) {
        return [t, e, n, r, n, r];
      };
      const w = function (t, e, n, r, i, o) {
        return [
          (1 / 3) * t + (2 / 3) * n,
          (1 / 3) * e + (2 / 3) * r,
          (1 / 3) * i + (2 / 3) * n,
          (1 / 3) * o + (2 / 3) * r,
          i,
          o,
        ];
      };
      var O = function (t, e, n, r, i, o, a, s, u, c) {
        n === r && (n += 1);
        let h;
        let l;
        let f;
        let d;
        let p;
        const g = (120 * Math.PI) / 180;
        const v = (Math.PI / 180) * (+i || 0);
        let y = [];
        const m = function (t, e, n) {
          return { x: t * Math.cos(n) - e * Math.sin(n), y: t * Math.sin(n) + e * Math.cos(n) };
        };
        if (c) (l = c[0]), (f = c[1]), (d = c[2]), (p = c[3]);
        else {
          (t = (h = m(t, e, -v)).x),
            (e = h.y),
            (s = (h = m(s, u, -v)).x),
            (u = h.y),
            t === s && e === u && ((s += 1), (u += 1));
          const b = (t - s) / 2;
          const x = (e - u) / 2;
          let M = (b * b) / (n * n) + (x * x) / (r * r);
          M > 1 && ((n *= M = Math.sqrt(M)), (r *= M));
          const S = n * n;
          const w = r * r;
          const C =
            (o === a ? -1 : 1) *
            Math.sqrt(Math.abs((S * w - S * x * x - w * b * b) / (S * x * x + w * b * b)));
          (d = (C * n * x) / r + (t + s) / 2),
            (p = (C * -r * b) / n + (e + u) / 2),
            (l = Math.asin(((e - p) / r).toFixed(9))),
            (f = Math.asin(((u - p) / r).toFixed(9))),
            (l = t < d ? Math.PI - l : l),
            (f = s < d ? Math.PI - f : f),
            l < 0 && (l = 2 * Math.PI + l),
            f < 0 && (f = 2 * Math.PI + f),
            a && l > f && (l -= 2 * Math.PI),
            !a && f > l && (f -= 2 * Math.PI);
        }
        let E = f - l;
        if (Math.abs(E) > g) {
          const k = f;
          const T = s;
          const P = u;
          (f = l + g * (a && f > l ? 1 : -1)),
            (s = d + n * Math.cos(f)),
            (u = p + r * Math.sin(f)),
            (y = O(s, u, n, r, i, 0, a, T, P, [f, k, d, p]));
        }
        E = f - l;
        const I = Math.cos(l);
        const A = Math.sin(l);
        const j = Math.cos(f);
        const N = Math.sin(f);
        const _ = Math.tan(E / 4);
        const B = (4 / 3) * n * _;
        const L = (4 / 3) * r * _;
        const D = [t, e];
        const R = [t + B * A, e - L * I];
        const Y = [s + B * N, u - L * j];
        const F = [s, u];
        if (((R[0] = 2 * D[0] - R[0]), (R[1] = 2 * D[1] - R[1]), c)) return [R, Y, F].concat(y);
        for (var X = [], z = 0, W = (y = [R, Y, F].concat(y).join().split(',')).length; z < W; z++)
          X[z] = z % 2 ? m(y[z - 1], y[z], v).y : m(y[z], y[z + 1], v).x;
        return X;
      };
      var C = function (t, e) {
        let n;
        const r = M(t);
        const i = e && M(e);
        const o = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
        const a = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
        const s = [];
        const u = [];
        let c = '';
        let h = '';
        const l = function (t, e, n) {
          let r;
          let i;
          if (!t) return ['C', e.x, e.y, e.x, e.y, e.x, e.y];
          switch ((!(t[0] in { T: 1, Q: 1 }) && (e.qx = e.qy = null), t[0])) {
            case 'M':
              (e.X = t[1]), (e.Y = t[2]);
              break;
            case 'A':
              t = ['C'].concat(O.apply(0, [e.x, e.y].concat(t.slice(1))));
              break;
            case 'S':
              n === 'C' || n === 'S'
                ? ((r = 2 * e.x - e.bx), (i = 2 * e.y - e.by))
                : ((r = e.x), (i = e.y)),
                (t = ['C', r, i].concat(t.slice(1)));
              break;
            case 'T':
              n === 'Q' || n === 'T'
                ? ((e.qx = 2 * e.x - e.qx), (e.qy = 2 * e.y - e.qy))
                : ((e.qx = e.x), (e.qy = e.y)),
                (t = ['C'].concat(w(e.x, e.y, e.qx, e.qy, t[1], t[2])));
              break;
            case 'Q':
              (e.qx = t[1]), (e.qy = t[2]), (t = ['C'].concat(w(e.x, e.y, t[1], t[2], t[3], t[4])));
              break;
            case 'L':
              t = ['C'].concat(S(e.x, e.y, t[1], t[2]));
              break;
            case 'H':
              t = ['C'].concat(S(e.x, e.y, t[1], e.y));
              break;
            case 'V':
              t = ['C'].concat(S(e.x, e.y, e.x, t[1]));
              break;
            case 'Z':
              t = ['C'].concat(S(e.x, e.y, e.X, e.Y));
          }
          return t;
        };
        const f = function (t, e) {
          if (t[e].length > 7) {
            t[e].shift();
            for (let o = t[e]; o.length; )
              (s[e] = 'A'), i && (u[e] = 'A'), t.splice(e++, 0, ['C'].concat(o.splice(0, 6)));
            t.splice(e, 1), (n = Math.max(r.length, (i && i.length) || 0));
          }
        };
        const d = function (t, e, o, a, s) {
          t &&
            e &&
            t[s][0] === 'M' &&
            e[s][0] !== 'M' &&
            (e.splice(s, 0, ['M', a.x, a.y]),
            (o.bx = 0),
            (o.by = 0),
            (o.x = t[s][1]),
            (o.y = t[s][2]),
            (n = Math.max(r.length, (i && i.length) || 0)));
        };
        n = Math.max(r.length, (i && i.length) || 0);
        for (let p = 0; p < n; p++) {
          r[p] && (c = r[p][0]),
            c !== 'C' && ((s[p] = c), p && (h = s[p - 1])),
            (r[p] = l(r[p], o, h)),
            s[p] !== 'A' && c === 'C' && (s[p] = 'C'),
            f(r, p),
            i &&
              (i[p] && (c = i[p][0]),
              c !== 'C' && ((u[p] = c), p && (h = u[p - 1])),
              (i[p] = l(i[p], a, h)),
              u[p] !== 'A' && c === 'C' && (u[p] = 'C'),
              f(i, p)),
            d(r, i, o, a, p),
            d(i, r, a, o, p);
          const g = r[p];
          const v = i && i[p];
          const y = g.length;
          const m = i && v.length;
          (o.x = g[y - 2]),
            (o.y = g[y - 1]),
            (o.bx = parseFloat(g[y - 4]) || o.x),
            (o.by = parseFloat(g[y - 3]) || o.y),
            (a.bx = i && (parseFloat(v[m - 4]) || a.x)),
            (a.by = i && (parseFloat(v[m - 3]) || a.y)),
            (a.x = i && v[m - 2]),
            (a.y = i && v[m - 1]);
        }
        return i ? [r, i] : r;
      };
      const E = /,?([a-z]),?/gi;
      var k = function (t) {
        return t.join(',').replace(E, '$1');
      };
      const T = function (t, e, n, r, i) {
        return t * (t * (-3 * e + 9 * n - 9 * r + 3 * i) + 6 * e - 12 * n + 6 * r) - 3 * e + 3 * n;
      };
      const P = function (t, e, n, r, i, o, a, s, u) {
        u === null && (u = 1);
        for (
          var c = (u = u > 1 ? 1 : u < 0 ? 0 : u) / 2,
            h = [
              -0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041,
              -0.9816, 0.9816,
            ],
            l = [
              0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069,
              0.0472, 0.0472,
            ],
            f = 0,
            d = 0;
          d < 12;
          d++
        ) {
          const p = c * h[d] + c;
          const g = T(p, t, n, i, a);
          const v = T(p, e, r, o, s);
          const y = g * g + v * v;
          f += l[d] * Math.sqrt(y);
        }
        return c * f;
      };
      const I = function (t, e, n, r, i, o, a, s) {
        for (var u, c, h, l, f = [], d = [[], []], p = 0; p < 2; ++p)
          if (
            (p === 0
              ? ((c = 6 * t - 12 * n + 6 * i),
                (u = -3 * t + 9 * n - 9 * i + 3 * a),
                (h = 3 * n - 3 * t))
              : ((c = 6 * e - 12 * r + 6 * o),
                (u = -3 * e + 9 * r - 9 * o + 3 * s),
                (h = 3 * r - 3 * e)),
            Math.abs(u) < 1e-12)
          ) {
            if (Math.abs(c) < 1e-12) continue;
            (l = -h / c) > 0 && l < 1 && f.push(l);
          } else {
            const g = c * c - 4 * h * u;
            const v = Math.sqrt(g);
            if (!(g < 0)) {
              const y = (-c + v) / (2 * u);
              y > 0 && y < 1 && f.push(y);
              const m = (-c - v) / (2 * u);
              m > 0 && m < 1 && f.push(m);
            }
          }
        for (var b, x = f.length, M = x; x--; )
          (b = 1 - (l = f[x])),
            (d[0][x] = b * b * b * t + 3 * b * b * l * n + 3 * b * l * l * i + l * l * l * a),
            (d[1][x] = b * b * b * e + 3 * b * b * l * r + 3 * b * l * l * o + l * l * l * s);
        return (
          (d[0][M] = t),
          (d[1][M] = e),
          (d[0][M + 1] = a),
          (d[1][M + 1] = s),
          (d[0].length = d[1].length = M + 2),
          {
            min: { x: Math.min.apply(0, d[0]), y: Math.min.apply(0, d[1]) },
            max: { x: Math.max.apply(0, d[0]), y: Math.max.apply(0, d[1]) },
          }
        );
      };
      const A = function (t, e, n, r, i, o, a, s) {
        if (
          !(
            Math.max(t, n) < Math.min(i, a) ||
            Math.min(t, n) > Math.max(i, a) ||
            Math.max(e, r) < Math.min(o, s) ||
            Math.min(e, r) > Math.max(o, s)
          )
        ) {
          const u = (t - n) * (o - s) - (e - r) * (i - a);
          if (u) {
            const c = ((t * r - e * n) * (i - a) - (t - n) * (i * s - o * a)) / u;
            const h = ((t * r - e * n) * (o - s) - (e - r) * (i * s - o * a)) / u;
            const l = +c.toFixed(2);
            const f = +h.toFixed(2);
            if (
              !(
                l < +Math.min(t, n).toFixed(2) ||
                l > +Math.max(t, n).toFixed(2) ||
                l < +Math.min(i, a).toFixed(2) ||
                l > +Math.max(i, a).toFixed(2) ||
                f < +Math.min(e, r).toFixed(2) ||
                f > +Math.max(e, r).toFixed(2) ||
                f < +Math.min(o, s).toFixed(2) ||
                f > +Math.max(o, s).toFixed(2)
              )
            )
              return { x: c, y: h };
          }
        }
      };
      const j = function (t, e, n) {
        return e >= t.x && e <= t.x + t.width && n >= t.y && n <= t.y + t.height;
      };
      var N = function (t, e, n, r, i) {
        if (i)
          return [
            ['M', +t + +i, e],
            ['l', n - 2 * i, 0],
            ['a', i, i, 0, 0, 1, i, i],
            ['l', 0, r - 2 * i],
            ['a', i, i, 0, 0, 1, -i, i],
            ['l', 2 * i - n, 0],
            ['a', i, i, 0, 0, 1, -i, -i],
            ['l', 0, 2 * i - r],
            ['a', i, i, 0, 0, 1, i, -i],
            ['z'],
          ];
        const o = [['M', t, e], ['l', n, 0], ['l', 0, r], ['l', -n, 0], ['z']];
        return (o.parsePathArray = k), o;
      };
      const _ = function (t, e, n, r) {
        return (
          t === null && (t = e = n = r = 0),
          e === null && ((e = t.y), (n = t.width), (r = t.height), (t = t.x)),
          {
            x: t,
            y: e,
            width: n,
            w: n,
            height: r,
            h: r,
            x2: t + n,
            y2: e + r,
            cx: t + n / 2,
            cy: e + r / 2,
            r1: Math.min(n, r) / 2,
            r2: Math.max(n, r) / 2,
            r0: Math.sqrt(n * n + r * r) / 2,
            path: N(t, e, n, r),
            vb: [t, e, n, r].join(' '),
          }
        );
      };
      const B = function (t, e, n, r, i, o, a, s) {
        Object(p.isArray)(t) || (t = [t, e, n, r, i, o, a, s]);
        const u = I.apply(null, t);
        return _(u.min.x, u.min.y, u.max.x - u.min.x, u.max.y - u.min.y);
      };
      const L = function (t, e, n, r, i, o, a, s, u) {
        const c = 1 - u;
        const h = Math.pow(c, 3);
        const l = Math.pow(c, 2);
        const f = u * u;
        const d = f * u;
        const p = t + 2 * u * (n - t) + f * (i - 2 * n + t);
        const g = e + 2 * u * (r - e) + f * (o - 2 * r + e);
        const v = n + 2 * u * (i - n) + f * (a - 2 * i + n);
        const y = r + 2 * u * (o - r) + f * (s - 2 * o + r);
        return {
          x: h * t + 3 * l * u * n + 3 * c * u * u * i + d * a,
          y: h * e + 3 * l * u * r + 3 * c * u * u * o + d * s,
          m: { x: p, y: g },
          n: { x: v, y },
          start: { x: c * t + u * n, y: c * e + u * r },
          end: { x: c * i + u * a, y: c * o + u * s },
          alpha: 90 - (180 * Math.atan2(p - v, g - y)) / Math.PI,
        };
      };
      const D = function (t, e, n) {
        if (
          !(function (t, e) {
            return (
              (t = _(t)),
              (e = _(e)),
              j(e, t.x, t.y) ||
                j(e, t.x2, t.y) ||
                j(e, t.x, t.y2) ||
                j(e, t.x2, t.y2) ||
                j(t, e.x, e.y) ||
                j(t, e.x2, e.y) ||
                j(t, e.x, e.y2) ||
                j(t, e.x2, e.y2) ||
                (((t.x < e.x2 && t.x > e.x) || (e.x < t.x2 && e.x > t.x)) &&
                  ((t.y < e.y2 && t.y > e.y) || (e.y < t.y2 && e.y > t.y)))
            );
          })(B(t), B(e))
        )
          return n ? 0 : [];
        for (
          var r = ~~(P.apply(0, t) / 8),
            i = ~~(P.apply(0, e) / 8),
            o = [],
            a = [],
            s = {},
            u = n ? 0 : [],
            c = 0;
          c < r + 1;
          c++
        ) {
          var h = L.apply(0, t.concat(c / r));
          o.push({ x: h.x, y: h.y, t: c / r });
        }
        for (c = 0; c < i + 1; c++) {
          h = L.apply(0, e.concat(c / i));
          a.push({ x: h.x, y: h.y, t: c / i });
        }
        for (c = 0; c < r; c++)
          for (let l = 0; l < i; l++) {
            const f = o[c];
            const d = o[c + 1];
            const p = a[l];
            const g = a[l + 1];
            const v = Math.abs(d.x - f.x) < 0.001 ? 'y' : 'x';
            const y = Math.abs(g.x - p.x) < 0.001 ? 'y' : 'x';
            const m = A(f.x, f.y, d.x, d.y, p.x, p.y, g.x, g.y);
            if (m) {
              if (s[m.x.toFixed(4)] === m.y.toFixed(4)) continue;
              s[m.x.toFixed(4)] = m.y.toFixed(4);
              const b = f.t + Math.abs((m[v] - f[v]) / (d[v] - f[v])) * (d.t - f.t);
              const x = p.t + Math.abs((m[y] - p[y]) / (g[y] - p[y])) * (g.t - p.t);
              b >= 0 &&
                b <= 1 &&
                x >= 0 &&
                x <= 1 &&
                (n ? (u += 1) : u.push({ x: m.x, y: m.y, t1: b, t2: x }));
            }
          }
        return u;
      };
      var R = function (t, e) {
        return (function (t, e, n) {
          let r;
          let i;
          let o;
          let a;
          let s;
          let u;
          let c;
          let h;
          let l;
          let f;
          (t = C(t)), (e = C(e));
          for (var d = n ? 0 : [], p = 0, g = t.length; p < g; p++) {
            const v = t[p];
            if (v[0] === 'M') (r = s = v[1]), (i = u = v[2]);
            else {
              v[0] === 'C'
                ? ((l = [r, i].concat(v.slice(1))), (r = l[6]), (i = l[7]))
                : ((l = [r, i, r, i, s, u, s, u]), (r = s), (i = u));
              for (let y = 0, m = e.length; y < m; y++) {
                const b = e[y];
                if (b[0] === 'M') (o = c = b[1]), (a = h = b[2]);
                else {
                  b[0] === 'C'
                    ? ((f = [o, a].concat(b.slice(1))), (o = f[6]), (a = f[7]))
                    : ((f = [o, a, o, a, c, h, c, h]), (o = c), (a = h));
                  const x = D(l, f, n);
                  if (n) d += x;
                  else {
                    for (let M = 0, S = x.length; M < S; M++)
                      (x[M].segment1 = p), (x[M].segment2 = y), (x[M].bez1 = l), (x[M].bez2 = f);
                    d = d.concat(x);
                  }
                }
              }
            }
          }
          return d;
        })(t, e);
      };
      function Y(t, e) {
        const n = [];
        const r = [];
        return (
          t.length &&
            (function t(e, i) {
              if (e.length === 1) n.push(e[0]), r.push(e[0]);
              else {
                for (var o = [], a = 0; a < e.length - 1; a++)
                  a === 0 && n.push(e[0]),
                    a === e.length - 2 && r.push(e[a + 1]),
                    (o[a] = [
                      (1 - i) * e[a][0] + i * e[a + 1][0],
                      (1 - i) * e[a][1] + i * e[a + 1][1],
                    ]);
                t(o, i);
              }
            })(t, e),
          { left: n, right: r.reverse() }
        );
      }
      const F = function (t, e, n) {
        if (n === 1) return [[].concat(t)];
        let r = [];
        if (e[0] === 'L' || e[0] === 'C' || e[0] === 'Q')
          r = r.concat(
            (function (t, e, n) {
              const r = [[t[1], t[2]]];
              n = n || 2;
              const i = [];
              e[0] === 'A'
                ? (r.push(e[6]), r.push(e[7]))
                : e[0] === 'C'
                ? (r.push([e[1], e[2]]), r.push([e[3], e[4]]), r.push([e[5], e[6]]))
                : e[0] === 'S' || e[0] === 'Q'
                ? (r.push([e[1], e[2]]), r.push([e[3], e[4]]))
                : r.push([e[1], e[2]]);
              for (var o = r, a = 1 / n, s = 0; s < n - 1; s++) {
                const u = Y(o, a / (1 - a * s));
                i.push(u.left), (o = u.right);
              }
              return (
                i.push(o),
                i.map((t) => {
                  let e = [];
                  return (
                    t.length === 4 && (e.push('C'), (e = e.concat(t[2]))),
                    t.length >= 3 && (t.length === 3 && e.push('Q'), (e = e.concat(t[1]))),
                    t.length === 2 && e.push('L'),
                    (e = e.concat(t[t.length - 1]))
                  );
                })
              );
            })(t, e, n),
          );
        else {
          const i = [].concat(t);
          i[0] === 'M' && (i[0] = 'L');
          for (let o = 0; o <= n - 1; o++) r.push(i);
        }
        return r;
      };
      var X = function (t, e) {
        if (t.length === 1) return t;
        const n = t.length - 1;
        const r = e.length - 1;
        const i = n / r;
        const o = [];
        if (t.length === 1 && t[0][0] === 'M') {
          for (var a = 0; a < r - n; a++) t.push(t[0]);
          return t;
        }
        for (a = 0; a < r; a++) {
          const s = Math.floor(i * a);
          o[s] = (o[s] || 0) + 1;
        }
        const u = o.reduce((e, r, i) => {
          return i === n ? e.concat(t[n]) : e.concat(F(t[i], t[i + 1], r));
        }, []);
        return u.unshift(t[0]), (e[r] !== 'Z' && e[r] !== 'z') || u.push('Z'), u;
      };
      const z = function (t, e) {
        if (t.length !== e.length) return !1;
        let n = !0;
        return (
          Object(p.each)(t, (t, r) => {
            if (t !== e[r]) return (n = !1), !1;
          }),
          n
        );
      };
      function W(t, e, n) {
        let r = null;
        let i = n;
        return (
          e < i && ((i = e), (r = 'add')), t < i && ((i = t), (r = 'del')), { type: r, min: i }
        );
      }
      var G = function (t, e) {
        const n = (function (t, e) {
          let n;
          let r;
          const i = t.length;
          const o = e.length;
          let a = 0;
          if (i === 0 || o === 0) return null;
          for (var s = [], u = 0; u <= i; u++) (s[u] = []), (s[u][0] = { min: u });
          for (var c = 0; c <= o; c++) s[0][c] = { min: c };
          for (u = 1; u <= i; u++) {
            n = t[u - 1];
            for (c = 1; c <= o; c++) {
              (r = e[c - 1]), (a = z(n, r) ? 0 : 1);
              const h = s[u - 1][c].min + 1;
              const l = s[u][c - 1].min + 1;
              const f = s[u - 1][c - 1].min + a;
              s[u][c] = W(h, l, f);
            }
          }
          return s;
        })(t, e);
        let r = t.length;
        const i = e.length;
        const o = [];
        let a = 1;
        let s = 1;
        if (n[r][i].min !== r) {
          for (var u = 1; u <= r; u++) {
            let c = n[u][u].min;
            s = u;
            for (let h = a; h <= i; h++) n[u][h].min < c && ((c = n[u][h].min), (s = h));
            (a = s), n[u][a].type && o.push({ index: u - 1, type: n[u][a].type });
          }
          for (u = o.length - 1; u >= 0; u--)
            (a = o[u].index),
              o[u].type === 'add' ? t.splice(a, 0, [].concat(t[a])) : t.splice(a, 1);
        }
        const l = i - (r = t.length);
        if (r < i)
          for (u = 0; u < l; u++)
            t[r - 1][0] === 'z' || t[r - 1][0] === 'Z'
              ? t.splice(r - 2, 0, t[r - 2])
              : t.push(t[r - 1]),
              (r += 1);
        return t;
      };
      function U(t, e, n) {
        for (var r, i = [].concat(t), o = 1 / (n + 1), a = H(e)[0], s = 1; s <= n; s++)
          (o *= s),
            (r = Math.floor(t.length * o)) === 0
              ? i.unshift([a[0] * o + t[r][0] * (1 - o), a[1] * o + t[r][1] * (1 - o)])
              : i.splice(r, 0, [a[0] * o + t[r][0] * (1 - o), a[1] * o + t[r][1] * (1 - o)]);
        return i;
      }
      function H(t) {
        const e = [];
        switch (t[0]) {
          case 'M':
          case 'L':
            e.push([t[1], t[2]]);
            break;
          case 'A':
            e.push([t[6], t[7]]);
            break;
          case 'Q':
            e.push([t[3], t[4]]), e.push([t[1], t[2]]);
            break;
          case 'T':
            e.push([t[1], t[2]]);
            break;
          case 'C':
            e.push([t[5], t[6]]), e.push([t[1], t[2]]), e.push([t[3], t[4]]);
            break;
          case 'S':
            e.push([t[3], t[4]]), e.push([t[1], t[2]]);
            break;
          case 'H':
          case 'V':
            e.push([t[1], t[1]]);
        }
        return e;
      }
      var q = function (t, e) {
        if (t.length <= 1) return t;
        for (var n, r = 0; r < e.length; r++)
          if (t[r][0] !== e[r][0])
            switch (((n = H(t[r])), e[r][0])) {
              case 'M':
                t[r] = ['M'].concat(n[0]);
                break;
              case 'L':
                t[r] = ['L'].concat(n[0]);
                break;
              case 'A':
                (t[r] = [].concat(e[r])), (t[r][6] = n[0][0]), (t[r][7] = n[0][1]);
                break;
              case 'Q':
                if (n.length < 2) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = U(n, t[r - 1], 1);
                }
                t[r] = ['Q'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              case 'T':
                t[r] = ['T'].concat(n[0]);
                break;
              case 'C':
                if (n.length < 3) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = U(n, t[r - 1], 2);
                }
                t[r] = ['C'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              case 'S':
                if (n.length < 2) {
                  if (!(r > 0)) {
                    t[r] = e[r];
                    break;
                  }
                  n = U(n, t[r - 1], 1);
                }
                t[r] = ['S'].concat(
                  n.reduce((t, e) => {
                    return t.concat(e);
                  }, []),
                );
                break;
              default:
                t[r] = e[r];
            }
        return t;
      };
      const V = (function () {
        function t(t, e) {
          (this.bubbles = !0),
            (this.target = null),
            (this.currentTarget = null),
            (this.delegateTarget = null),
            (this.delegateObject = null),
            (this.defaultPrevented = !1),
            (this.propagationStopped = !1),
            (this.shape = null),
            (this.fromShape = null),
            (this.toShape = null),
            (this.propagationPath = []),
            (this.type = t),
            (this.name = t),
            (this.originalEvent = e),
            (this.timeStamp = e.timeStamp);
        }
        return (
          (t.prototype.preventDefault = function () {
            (this.defaultPrevented = !0),
              this.originalEvent.preventDefault && this.originalEvent.preventDefault();
          }),
          (t.prototype.stopPropagation = function () {
            this.propagationStopped = !0;
          }),
          (t.prototype.toString = function () {
            return `[Event (type=${this.type})]`;
          }),
          (t.prototype.save = function () {}),
          (t.prototype.restore = function () {}),
          t
        );
      })();
      const Z = (function () {
        function t() {
          this._events = {};
        }
        return (
          (t.prototype.on = function (t, e, n) {
            return (
              this._events[t] || (this._events[t] = []),
              this._events[t].push({ callback: e, once: !!n }),
              this
            );
          }),
          (t.prototype.once = function (t, e) {
            return this.on(t, e, !0), this;
          }),
          (t.prototype.emit = function (t) {
            for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
            const i = this._events[t] || [];
            const o = this._events['*'] || [];
            const a = function (r) {
              for (let i = r.length, o = 0; o < i; o++)
                if (r[o]) {
                  const a = r[o];
                  const s = a.callback;
                  a.once && (r.splice(o, 1), r.length === 0 && delete e._events[t], i--, o--),
                    s.apply(e, n);
                }
            };
            a(i), a(o);
          }),
          (t.prototype.off = function (t, e) {
            if (t)
              if (e) {
                for (var n = this._events[t] || [], r = n.length, i = 0; i < r; i++)
                  n[i].callback === e && (n.splice(i, 1), r--, i--);
                n.length === 0 && delete this._events[t];
              } else delete this._events[t];
            else this._events = {};
            return this;
          }),
          (t.prototype.getEvents = function () {
            return this._events;
          }),
          t
        );
      })();
      function K(t, e) {
        const n = t.indexOf(e);
        n !== -1 && t.splice(n, 1);
      }
      const $ = typeof window !== 'undefined' && void 0 !== window.document;
      function Q(t, e) {
        if (t.isCanvas()) return !0;
        for (var n = e.getParent(), r = !1; n; ) {
          if (n === t) {
            r = !0;
            break;
          }
          n = n.getParent();
        }
        return r;
      }
      function J(t) {
        return t.cfg.visible && t.cfg.capture;
      }
      const tt = (function (t) {
        function e(e) {
          const n = t.call(this) || this;
          n.destroyed = !1;
          const r = n.getDefaultCfg();
          return (n.cfg = Object(p.mix)(r, e)), n;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultCfg = function () {
            return {};
          }),
          (e.prototype.get = function (t) {
            return this.cfg[t];
          }),
          (e.prototype.set = function (t, e) {
            this.cfg[t] = e;
          }),
          (e.prototype.destroy = function () {
            (this.cfg = { destroyed: !0 }), this.off(), (this.destroyed = !0);
          }),
          e
        );
      })(Z);
      const et = n(208);
      const nt = typeof Float32Array !== 'undefined' ? Float32Array : Array;
      const rt = Math.random;
      Math.PI;
      function it() {
        const t = new nt(9);
        return (
          nt != Float32Array &&
            ((t[1] = 0), (t[2] = 0), (t[3] = 0), (t[5] = 0), (t[6] = 0), (t[7] = 0)),
          (t[0] = 1),
          (t[4] = 1),
          (t[8] = 1),
          t
        );
      }
      function ot(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[4]),
          (t[4] = e[5]),
          (t[5] = e[6]),
          (t[6] = e[8]),
          (t[7] = e[9]),
          (t[8] = e[10]),
          t
        );
      }
      function at(t) {
        const e = new nt(9);
        return (
          (e[0] = t[0]),
          (e[1] = t[1]),
          (e[2] = t[2]),
          (e[3] = t[3]),
          (e[4] = t[4]),
          (e[5] = t[5]),
          (e[6] = t[6]),
          (e[7] = t[7]),
          (e[8] = t[8]),
          e
        );
      }
      function st(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = e[2]),
          (t[3] = e[3]),
          (t[4] = e[4]),
          (t[5] = e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          t
        );
      }
      function ut(t, e, n, r, i, o, a, s, u) {
        const c = new nt(9);
        return (
          (c[0] = t),
          (c[1] = e),
          (c[2] = n),
          (c[3] = r),
          (c[4] = i),
          (c[5] = o),
          (c[6] = a),
          (c[7] = s),
          (c[8] = u),
          c
        );
      }
      function ct(t, e, n, r, i, o, a, s, u, c) {
        return (
          (t[0] = e),
          (t[1] = n),
          (t[2] = r),
          (t[3] = i),
          (t[4] = o),
          (t[5] = a),
          (t[6] = s),
          (t[7] = u),
          (t[8] = c),
          t
        );
      }
      function ht(t) {
        return (
          (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 1),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function lt(t, e) {
        if (t === e) {
          const n = e[1];
          const r = e[2];
          const i = e[5];
          (t[1] = e[3]), (t[2] = e[6]), (t[3] = n), (t[5] = e[7]), (t[6] = r), (t[7] = i);
        } else
          (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]);
        return t;
      }
      function ft(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        const l = h * a - s * c;
        const f = -h * o + s * u;
        const d = c * o - a * u;
        let p = n * l + r * f + i * d;
        return p
          ? ((p = 1 / p),
            (t[0] = l * p),
            (t[1] = (-h * r + i * c) * p),
            (t[2] = (s * r - i * a) * p),
            (t[3] = f * p),
            (t[4] = (h * n - i * u) * p),
            (t[5] = (-s * n + i * o) * p),
            (t[6] = d * p),
            (t[7] = (-c * n + r * u) * p),
            (t[8] = (a * n - r * o) * p),
            t)
          : null;
      }
      function dt(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        return (
          (t[0] = a * h - s * c),
          (t[1] = i * c - r * h),
          (t[2] = r * s - i * a),
          (t[3] = s * u - o * h),
          (t[4] = n * h - i * u),
          (t[5] = i * o - n * s),
          (t[6] = o * c - a * u),
          (t[7] = r * u - n * c),
          (t[8] = n * a - r * o),
          t
        );
      }
      function pt(t) {
        const e = t[0];
        const n = t[1];
        const r = t[2];
        const i = t[3];
        const o = t[4];
        const a = t[5];
        const s = t[6];
        const u = t[7];
        const c = t[8];
        return e * (c * o - a * u) + n * (-c * i + a * s) + r * (u * i - o * s);
      }
      function gt(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = n[0];
        const d = n[1];
        const p = n[2];
        const g = n[3];
        const v = n[4];
        const y = n[5];
        const m = n[6];
        const b = n[7];
        const x = n[8];
        return (
          (t[0] = f * r + d * a + p * c),
          (t[1] = f * i + d * s + p * h),
          (t[2] = f * o + d * u + p * l),
          (t[3] = g * r + v * a + y * c),
          (t[4] = g * i + v * s + y * h),
          (t[5] = g * o + v * u + y * l),
          (t[6] = m * r + b * a + x * c),
          (t[7] = m * i + b * s + x * h),
          (t[8] = m * o + b * u + x * l),
          t
        );
      }
      function vt(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = n[0];
        const d = n[1];
        return (
          (t[0] = r),
          (t[1] = i),
          (t[2] = o),
          (t[3] = a),
          (t[4] = s),
          (t[5] = u),
          (t[6] = f * r + d * a + c),
          (t[7] = f * i + d * s + h),
          (t[8] = f * o + d * u + l),
          t
        );
      }
      function yt(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        const a = e[3];
        const s = e[4];
        const u = e[5];
        const c = e[6];
        const h = e[7];
        const l = e[8];
        const f = Math.sin(n);
        const d = Math.cos(n);
        return (
          (t[0] = d * r + f * a),
          (t[1] = d * i + f * s),
          (t[2] = d * o + f * u),
          (t[3] = d * a - f * r),
          (t[4] = d * s - f * i),
          (t[5] = d * u - f * o),
          (t[6] = c),
          (t[7] = h),
          (t[8] = l),
          t
        );
      }
      function mt(t, e, n) {
        const r = n[0];
        const i = n[1];
        return (
          (t[0] = r * e[0]),
          (t[1] = r * e[1]),
          (t[2] = r * e[2]),
          (t[3] = i * e[3]),
          (t[4] = i * e[4]),
          (t[5] = i * e[5]),
          (t[6] = e[6]),
          (t[7] = e[7]),
          (t[8] = e[8]),
          t
        );
      }
      function bt(t, e) {
        return (
          (t[0] = 1),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = 1),
          (t[5] = 0),
          (t[6] = e[0]),
          (t[7] = e[1]),
          (t[8] = 1),
          t
        );
      }
      function xt(t, e) {
        const n = Math.sin(e);
        const r = Math.cos(e);
        return (
          (t[0] = r),
          (t[1] = n),
          (t[2] = 0),
          (t[3] = -n),
          (t[4] = r),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function Mt(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = e[1]),
          (t[5] = 0),
          (t[6] = 0),
          (t[7] = 0),
          (t[8] = 1),
          t
        );
      }
      function St(t, e) {
        return (
          (t[0] = e[0]),
          (t[1] = e[1]),
          (t[2] = 0),
          (t[3] = e[2]),
          (t[4] = e[3]),
          (t[5] = 0),
          (t[6] = e[4]),
          (t[7] = e[5]),
          (t[8] = 1),
          t
        );
      }
      function wt(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = n + n;
        const s = r + r;
        const u = i + i;
        const c = n * a;
        const h = r * a;
        const l = r * s;
        const f = i * a;
        const d = i * s;
        const p = i * u;
        const g = o * a;
        const v = o * s;
        const y = o * u;
        return (
          (t[0] = 1 - l - p),
          (t[3] = h - y),
          (t[6] = f + v),
          (t[1] = h + y),
          (t[4] = 1 - c - p),
          (t[7] = d - g),
          (t[2] = f - v),
          (t[5] = d + g),
          (t[8] = 1 - c - l),
          t
        );
      }
      function Ot(t, e) {
        const n = e[0];
        const r = e[1];
        const i = e[2];
        const o = e[3];
        const a = e[4];
        const s = e[5];
        const u = e[6];
        const c = e[7];
        const h = e[8];
        const l = e[9];
        const f = e[10];
        const d = e[11];
        const p = e[12];
        const g = e[13];
        const v = e[14];
        const y = e[15];
        const m = n * s - r * a;
        const b = n * u - i * a;
        const x = n * c - o * a;
        const M = r * u - i * s;
        const S = r * c - o * s;
        const w = i * c - o * u;
        const O = h * g - l * p;
        const C = h * v - f * p;
        const E = h * y - d * p;
        const k = l * v - f * g;
        const T = l * y - d * g;
        const P = f * y - d * v;
        let I = m * P - b * T + x * k + M * E - S * C + w * O;
        return I
          ? ((I = 1 / I),
            (t[0] = (s * P - u * T + c * k) * I),
            (t[1] = (u * E - a * P - c * C) * I),
            (t[2] = (a * T - s * E + c * O) * I),
            (t[3] = (i * T - r * P - o * k) * I),
            (t[4] = (n * P - i * E + o * C) * I),
            (t[5] = (r * E - n * T - o * O) * I),
            (t[6] = (g * w - v * S + y * M) * I),
            (t[7] = (v * x - p * w - y * b) * I),
            (t[8] = (p * S - g * x + y * m) * I),
            t)
          : null;
      }
      function Ct(t, e, n) {
        return (
          (t[0] = 2 / e),
          (t[1] = 0),
          (t[2] = 0),
          (t[3] = 0),
          (t[4] = -2 / n),
          (t[5] = 0),
          (t[6] = -1),
          (t[7] = 1),
          (t[8] = 1),
          t
        );
      }
      function Et(t) {
        return `mat3(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}, ${t[4]}, ${t[5]}, ${t[6]}, ${t[7]}, ${t[8]})`;
      }
      function kt(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
      }
      function Tt(t, e, n) {
        return (
          (t[0] = e[0] + n[0]),
          (t[1] = e[1] + n[1]),
          (t[2] = e[2] + n[2]),
          (t[3] = e[3] + n[3]),
          (t[4] = e[4] + n[4]),
          (t[5] = e[5] + n[5]),
          (t[6] = e[6] + n[6]),
          (t[7] = e[7] + n[7]),
          (t[8] = e[8] + n[8]),
          t
        );
      }
      function Pt(t, e, n) {
        return (
          (t[0] = e[0] - n[0]),
          (t[1] = e[1] - n[1]),
          (t[2] = e[2] - n[2]),
          (t[3] = e[3] - n[3]),
          (t[4] = e[4] - n[4]),
          (t[5] = e[5] - n[5]),
          (t[6] = e[6] - n[6]),
          (t[7] = e[7] - n[7]),
          (t[8] = e[8] - n[8]),
          t
        );
      }
      function It(t, e, n) {
        return (
          (t[0] = e[0] * n),
          (t[1] = e[1] * n),
          (t[2] = e[2] * n),
          (t[3] = e[3] * n),
          (t[4] = e[4] * n),
          (t[5] = e[5] * n),
          (t[6] = e[6] * n),
          (t[7] = e[7] * n),
          (t[8] = e[8] * n),
          t
        );
      }
      function At(t, e, n, r) {
        return (
          (t[0] = e[0] + n[0] * r),
          (t[1] = e[1] + n[1] * r),
          (t[2] = e[2] + n[2] * r),
          (t[3] = e[3] + n[3] * r),
          (t[4] = e[4] + n[4] * r),
          (t[5] = e[5] + n[5] * r),
          (t[6] = e[6] + n[6] * r),
          (t[7] = e[7] + n[7] * r),
          (t[8] = e[8] + n[8] * r),
          t
        );
      }
      function jt(t, e) {
        return (
          t[0] === e[0] &&
          t[1] === e[1] &&
          t[2] === e[2] &&
          t[3] === e[3] &&
          t[4] === e[4] &&
          t[5] === e[5] &&
          t[6] === e[6] &&
          t[7] === e[7] &&
          t[8] === e[8]
        );
      }
      function Nt(t, e) {
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const o = t[3];
        const a = t[4];
        const s = t[5];
        const u = t[6];
        const c = t[7];
        const h = t[8];
        const l = e[0];
        const f = e[1];
        const d = e[2];
        const p = e[3];
        const g = e[4];
        const v = e[5];
        const y = e[6];
        const m = e[7];
        const b = e[8];
        return (
          Math.abs(n - l) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(l)) &&
          Math.abs(r - f) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(f)) &&
          Math.abs(i - d) <= 1e-6 * Math.max(1, Math.abs(i), Math.abs(d)) &&
          Math.abs(o - p) <= 1e-6 * Math.max(1, Math.abs(o), Math.abs(p)) &&
          Math.abs(a - g) <= 1e-6 * Math.max(1, Math.abs(a), Math.abs(g)) &&
          Math.abs(s - v) <= 1e-6 * Math.max(1, Math.abs(s), Math.abs(v)) &&
          Math.abs(u - y) <= 1e-6 * Math.max(1, Math.abs(u), Math.abs(y)) &&
          Math.abs(c - m) <= 1e-6 * Math.max(1, Math.abs(c), Math.abs(m)) &&
          Math.abs(h - b) <= 1e-6 * Math.max(1, Math.abs(h), Math.abs(b))
        );
      }
      Math.hypot ||
        (Math.hypot = function () {
          for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e];
          return Math.sqrt(t);
        });
      var _t = gt;
      var Bt = Pt;
      function Lt() {
        const t = new nt(2);
        return nt != Float32Array && ((t[0] = 0), (t[1] = 0)), t;
      }
      function Dt(t) {
        const e = new nt(2);
        return (e[0] = t[0]), (e[1] = t[1]), e;
      }
      function Rt(t, e) {
        const n = new nt(2);
        return (n[0] = t), (n[1] = e), n;
      }
      function Yt(t, e) {
        return (t[0] = e[0]), (t[1] = e[1]), t;
      }
      function Ft(t, e, n) {
        return (t[0] = e), (t[1] = n), t;
      }
      function Xt(t, e, n) {
        return (t[0] = e[0] + n[0]), (t[1] = e[1] + n[1]), t;
      }
      function zt(t, e, n) {
        return (t[0] = e[0] - n[0]), (t[1] = e[1] - n[1]), t;
      }
      function Wt(t, e, n) {
        return (t[0] = e[0] * n[0]), (t[1] = e[1] * n[1]), t;
      }
      function Gt(t, e, n) {
        return (t[0] = e[0] / n[0]), (t[1] = e[1] / n[1]), t;
      }
      function Ut(t, e) {
        return (t[0] = Math.ceil(e[0])), (t[1] = Math.ceil(e[1])), t;
      }
      function Ht(t, e) {
        return (t[0] = Math.floor(e[0])), (t[1] = Math.floor(e[1])), t;
      }
      function qt(t, e, n) {
        return (t[0] = Math.min(e[0], n[0])), (t[1] = Math.min(e[1], n[1])), t;
      }
      function Vt(t, e, n) {
        return (t[0] = Math.max(e[0], n[0])), (t[1] = Math.max(e[1], n[1])), t;
      }
      function Zt(t, e) {
        return (t[0] = Math.round(e[0])), (t[1] = Math.round(e[1])), t;
      }
      function Kt(t, e, n) {
        return (t[0] = e[0] * n), (t[1] = e[1] * n), t;
      }
      function $t(t, e, n, r) {
        return (t[0] = e[0] + n[0] * r), (t[1] = e[1] + n[1] * r), t;
      }
      function Qt(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        return Math.hypot(n, r);
      }
      function Jt(t, e) {
        const n = e[0] - t[0];
        const r = e[1] - t[1];
        return n * n + r * r;
      }
      function te(t) {
        const e = t[0];
        const n = t[1];
        return Math.hypot(e, n);
      }
      function ee(t) {
        const e = t[0];
        const n = t[1];
        return e * e + n * n;
      }
      function ne(t, e) {
        return (t[0] = -e[0]), (t[1] = -e[1]), t;
      }
      function re(t, e) {
        return (t[0] = 1 / e[0]), (t[1] = 1 / e[1]), t;
      }
      function ie(t, e) {
        const n = e[0];
        const r = e[1];
        let i = n * n + r * r;
        return i > 0 && (i = 1 / Math.sqrt(i)), (t[0] = e[0] * i), (t[1] = e[1] * i), t;
      }
      function oe(t, e) {
        return t[0] * e[0] + t[1] * e[1];
      }
      function ae(t, e, n) {
        const r = e[0] * n[1] - e[1] * n[0];
        return (t[0] = t[1] = 0), (t[2] = r), t;
      }
      function se(t, e, n, r) {
        const i = e[0];
        const o = e[1];
        return (t[0] = i + r * (n[0] - i)), (t[1] = o + r * (n[1] - o)), t;
      }
      function ue(t, e) {
        e = e || 1;
        const n = 2 * rt() * Math.PI;
        return (t[0] = Math.cos(n) * e), (t[1] = Math.sin(n) * e), t;
      }
      function ce(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[2] * i), (t[1] = n[1] * r + n[3] * i), t;
      }
      function he(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[2] * i + n[4]), (t[1] = n[1] * r + n[3] * i + n[5]), t;
      }
      function le(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[3] * i + n[6]), (t[1] = n[1] * r + n[4] * i + n[7]), t;
      }
      function fe(t, e, n) {
        const r = e[0];
        const i = e[1];
        return (t[0] = n[0] * r + n[4] * i + n[12]), (t[1] = n[1] * r + n[5] * i + n[13]), t;
      }
      function de(t, e, n, r) {
        const i = e[0] - n[0];
        const o = e[1] - n[1];
        const a = Math.sin(r);
        const s = Math.cos(r);
        return (t[0] = i * s - o * a + n[0]), (t[1] = i * a + o * s + n[1]), t;
      }
      function pe(t, e) {
        const n = t[0];
        const r = t[1];
        const i = e[0];
        const o = e[1];
        const a = Math.sqrt(n * n + r * r) * Math.sqrt(i * i + o * o);
        const s = a && (n * i + r * o) / a;
        return Math.acos(Math.min(Math.max(s, -1), 1));
      }
      function ge(t) {
        return (t[0] = 0), (t[1] = 0), t;
      }
      function ve(t) {
        return `vec2(${t[0]}, ${t[1]})`;
      }
      function ye(t, e) {
        return t[0] === e[0] && t[1] === e[1];
      }
      function me(t, e) {
        const n = t[0];
        const r = t[1];
        const i = e[0];
        const o = e[1];
        return (
          Math.abs(n - i) <= 1e-6 * Math.max(1, Math.abs(n), Math.abs(i)) &&
          Math.abs(r - o) <= 1e-6 * Math.max(1, Math.abs(r), Math.abs(o))
        );
      }
      let be;
      var xe = te;
      var Me = zt;
      var Se = Wt;
      var we = Gt;
      var Oe = Qt;
      var Ce = Jt;
      var Ee = ee;
      var ke =
        ((be = Lt()),
        function (t, e, n, r, i, o) {
          let a;
          let s;
          for (
            e || (e = 2), n || (n = 0), s = r ? Math.min(r * e + n, t.length) : t.length, a = n;
            a < s;
            a += e
          )
            (be[0] = t[a]), (be[1] = t[a + 1]), i(be, be, o), (t[a] = be[0]), (t[a + 1] = be[1]);
          return t;
        });
      function Te(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.fromTranslation(r, n), i.multiply(t, r, e);
      }
      function Pe(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.fromRotation(r, n), i.multiply(t, r, e);
      }
      function Ie(t, e, n) {
        const r = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        return i.fromScaling(r, n), i.multiply(t, r, e);
      }
      function Ae(t, e) {
        for (
          var n, r, o, a = t ? [].concat(t) : [1, 0, 0, 0, 1, 0, 0, 0, 1], s = 0, u = e.length;
          s < u;
          s++
        ) {
          const c = e[s];
          switch (c[0]) {
            case 't':
              Te(a, a, [c[1], c[2]]);
              break;
            case 's':
              Ie(a, a, [c[1], c[2]]);
              break;
            case 'r':
              Pe(a, a, c[1]);
              break;
            case 'm':
              (n = a), (r = a), (o = c[1]), i.multiply(n, o, r);
          }
        }
        return a;
      }
      function je(t, e) {
        return t[0] * e[1] - e[0] * t[1];
      }
      function Ne(t, e, n) {
        const r = o.angle(t, e);
        const i = je(t, e) >= 0;
        return n ? (i ? 2 * Math.PI - r : r) : i ? r : 2 * Math.PI - r;
      }
      function _e(t, e, n) {
        return n ? ((t[0] = e[1]), (t[1] = -1 * e[0])) : ((t[0] = -1 * e[1]), (t[1] = e[0])), t;
      }
      function Be(t, e) {
        const n = [];
        const r = t[0];
        const i = t[1];
        const o = t[2];
        const a = t[3];
        const s = t[4];
        const u = t[5];
        const c = t[6];
        const h = t[7];
        const l = t[8];
        const f = e[0];
        const d = e[1];
        const p = e[2];
        const g = e[3];
        const v = e[4];
        const y = e[5];
        const m = e[6];
        const b = e[7];
        const x = e[8];
        return (
          (n[0] = f * r + d * a + p * c),
          (n[1] = f * i + d * s + p * h),
          (n[2] = f * o + d * u + p * l),
          (n[3] = g * r + v * a + y * c),
          (n[4] = g * i + v * s + y * h),
          (n[5] = g * o + v * u + y * l),
          (n[6] = m * r + b * a + x * c),
          (n[7] = m * i + b * s + x * h),
          (n[8] = m * o + b * u + x * l),
          n
        );
      }
      function Le(t, e) {
        const n = [];
        const r = e[0];
        const i = e[1];
        return (n[0] = t[0] * r + t[3] * i + t[6]), (n[1] = t[1] * r + t[4] * i + t[7]), n;
      }
      function De(t) {
        const e = [];
        const n = t[0];
        const r = t[1];
        const i = t[2];
        const o = t[3];
        const a = t[4];
        const s = t[5];
        const u = t[6];
        const c = t[7];
        const h = t[8];
        const l = h * a - s * c;
        const f = -h * o + s * u;
        const d = c * o - a * u;
        let p = n * l + r * f + i * d;
        return p
          ? ((p = 1 / p),
            (e[0] = l * p),
            (e[1] = (-h * r + i * c) * p),
            (e[2] = (s * r - i * a) * p),
            (e[3] = f * p),
            (e[4] = (h * n - i * u) * p),
            (e[5] = (-s * n + i * o) * p),
            (e[6] = d * p),
            (e[7] = (-c * n + r * u) * p),
            (e[8] = (a * n - r * o) * p),
            e)
          : null;
      }
      const Re = a.transform;
      const Ye = ['zIndex', 'capture', 'visible', 'type'];
      const Fe = ['repeat'];
      function Xe(t, e) {
        const n = {};
        const r = e.attrs;
        for (const i in t) n[i] = r[i];
        return n;
      }
      function ze(t, e) {
        const n = {};
        const r = e.attr();
        return (
          Object(p.each)(t, (t, e) => {
            Fe.indexOf(e) !== -1 || Object(p.isEqual)(r[e], t) || (n[e] = t);
          }),
          n
        );
      }
      function We(t, e) {
        if (e.onFrame) return t;
        const n = e.startTime;
        const r = e.delay;
        const i = e.duration;
        const o = Object.prototype.hasOwnProperty;
        return (
          Object(p.each)(t, (t) => {
            n + r < t.startTime + t.delay + t.duration &&
              i > t.delay &&
              Object(p.each)(e.toAttrs, (e, n) => {
                o.call(t.toAttrs, n) && (delete t.toAttrs[n], delete t.fromAttrs[n]);
              });
          }),
          t
        );
      }
      const Ge = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          n.attrs = {};
          const r = n.getDefaultAttrs();
          return Object(p.mix)(r, e.attrs), (n.attrs = r), n.initAttrs(r), n.initAnimate(), n;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultCfg = function () {
            return { visible: !0, capture: !0, zIndex: 0 };
          }),
          (e.prototype.getDefaultAttrs = function () {
            return { matrix: this.getDefaultMatrix(), opacity: 1 };
          }),
          (e.prototype.onCanvasChange = function (t) {}),
          (e.prototype.initAttrs = function (t) {}),
          (e.prototype.initAnimate = function () {
            this.set('animable', !0), this.set('animating', !1);
          }),
          (e.prototype.isGroup = function () {
            return !1;
          }),
          (e.prototype.getParent = function () {
            return this.get('parent');
          }),
          (e.prototype.getCanvas = function () {
            return this.get('canvas');
          }),
          (e.prototype.attr = function () {
            for (var t, e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
            const r = e[0];
            const i = e[1];
            if (!r) return this.attrs;
            if (Object(p.isObject)(r)) {
              for (const o in r) this.setAttr(o, r[o]);
              return this.afterAttrsChange(r), this;
            }
            return e.length === 2
              ? (this.setAttr(r, i), this.afterAttrsChange((((t = {})[r] = i), t)), this)
              : this.attrs[r];
          }),
          (e.prototype.isClipped = function (t, e) {
            const n = this.getClip();
            return n && !n.isHit(t, e);
          }),
          (e.prototype.setAttr = function (t, e) {
            const n = this.attrs[t];
            n !== e && ((this.attrs[t] = e), this.onAttrChange(t, e, n));
          }),
          (e.prototype.onAttrChange = function (t, e, n) {
            t === 'matrix' && this.set('totalMatrix', null);
          }),
          (e.prototype.afterAttrsChange = function (t) {
            if (this.cfg.isClipShape) {
              const e = this.cfg.applyTo;
              e && e.onCanvasChange('clip');
            } else this.onCanvasChange('attr');
          }),
          (e.prototype.show = function () {
            return this.set('visible', !0), this.onCanvasChange('show'), this;
          }),
          (e.prototype.hide = function () {
            return this.set('visible', !1), this.onCanvasChange('hide'), this;
          }),
          (e.prototype.setZIndex = function (t) {
            this.set('zIndex', t);
            const e = this.getParent();
            return e && e.sort(), this;
          }),
          (e.prototype.toFront = function () {
            const t = this.getParent();
            if (t) {
              const e = t.getChildren();
              const n = (this.get('el'), e.indexOf(this));
              e.splice(n, 1), e.push(this), this.onCanvasChange('zIndex');
            }
          }),
          (e.prototype.toBack = function () {
            const t = this.getParent();
            if (t) {
              const e = t.getChildren();
              const n = (this.get('el'), e.indexOf(this));
              e.splice(n, 1), e.unshift(this), this.onCanvasChange('zIndex');
            }
          }),
          (e.prototype.remove = function (t) {
            void 0 === t && (t = !0);
            const e = this.getParent();
            e
              ? (K(e.getChildren(), this), e.get('clearing') || this.onCanvasChange('remove'))
              : this.onCanvasChange('remove'),
              t && this.destroy();
          }),
          (e.prototype.resetMatrix = function () {
            this.attr('matrix', this.getDefaultMatrix()), this.onCanvasChange('matrix');
          }),
          (e.prototype.getMatrix = function () {
            return this.attr('matrix');
          }),
          (e.prototype.setMatrix = function (t) {
            this.attr('matrix', t), this.onCanvasChange('matrix');
          }),
          (e.prototype.getTotalMatrix = function () {
            let t = this.cfg.totalMatrix;
            if (!t) {
              const e = this.attr('matrix');
              const n = this.cfg.parentMatrix;
              (t = n && e ? Be(n, e) : e || n), this.set('totalMatrix', t);
            }
            return t;
          }),
          (e.prototype.applyMatrix = function (t) {
            const e = this.attr('matrix');
            let n = null;
            (n = t && e ? Be(t, e) : e || t),
              this.set('totalMatrix', n),
              this.set('parentMatrix', t);
          }),
          (e.prototype.getDefaultMatrix = function () {
            return null;
          }),
          (e.prototype.applyToMatrix = function (t) {
            const e = this.attr('matrix');
            return e ? Le(e, t) : t;
          }),
          (e.prototype.invertFromMatrix = function (t) {
            const e = this.attr('matrix');
            if (e) {
              const n = De(e);
              if (n) return Le(n, t);
            }
            return t;
          }),
          (e.prototype.setClip = function (t) {
            const e = this.getCanvas();
            let n = null;
            if (t) {
              const r = this.getShapeBase()[Object(p.upperFirst)(t.type)];
              r &&
                (n = new r({
                  type: t.type,
                  isClipShape: !0,
                  applyTo: this,
                  attrs: t.attrs,
                  canvas: e,
                }));
            }
            return this.set('clipShape', n), this.onCanvasChange('clip'), n;
          }),
          (e.prototype.getClip = function () {
            const t = this.cfg.clipShape;
            return t || null;
          }),
          (e.prototype.clone = function () {
            const t = this;
            const e = this.attrs;
            const n = {};
            Object(p.each)(e, (t, r) => {
              Object(p.isArray)(e[r])
                ? (n[r] = (function (t) {
                    for (var e = [], n = 0; n < t.length; n++)
                      Object(p.isArray)(t[n]) ? e.push([].concat(t[n])) : e.push(t[n]);
                    return e;
                  })(e[r]))
                : (n[r] = e[r]);
            });
            const r = new (0, this.constructor)({ attrs: n });
            return (
              Object(p.each)(Ye, (e) => {
                r.set(e, t.get(e));
              }),
              r
            );
          }),
          (e.prototype.destroy = function () {
            this.destroyed || ((this.attrs = {}), t.prototype.destroy.call(this));
          }),
          (e.prototype.isAnimatePaused = function () {
            return this.get('_pause').isPaused;
          }),
          (e.prototype.animate = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            if (this.get('timeline') || this.get('canvas')) {
              this.set('animating', !0);
              let n = this.get('timeline');
              n || ((n = this.get('canvas').get('timeline')), this.set('timeline', n));
              let r = this.get('animations') || [];
              n.timer || n.initTimer();
              let i;
              let o;
              let a;
              let s;
              let u;
              let c = t[0];
              let h = t[1];
              const l = t[2];
              let f = void 0 === l ? 'easeLinear' : l;
              const d = t[3];
              let g = void 0 === d ? p.noop : d;
              const v = t[4];
              let y = void 0 === v ? 0 : v;
              Object(p.isFunction)(c)
                ? ((i = c), (c = {}))
                : Object(p.isObject)(c) && c.onFrame && ((i = c.onFrame), (o = c.repeat)),
                Object(p.isObject)(h)
                  ? ((h = (u = h).duration),
                    (f = u.easing || 'easeLinear'),
                    (y = u.delay || 0),
                    (o = u.repeat || o || !1),
                    (g = u.callback || p.noop),
                    (a = u.pauseCallback || p.noop),
                    (s = u.resumeCallback || p.noop))
                  : (Object(p.isNumber)(g) && ((y = g), (g = null)),
                    Object(p.isFunction)(f)
                      ? ((g = f), (f = 'easeLinear'))
                      : (f = f || 'easeLinear'));
              const m = ze(c, this);
              const b = {
                fromAttrs: Xe(m, this),
                toAttrs: m,
                duration: h,
                easing: f,
                repeat: o,
                callback: g,
                pauseCallback: a,
                resumeCallback: s,
                delay: y,
                startTime: n.getTime(),
                id: Object(p.uniqueId)(),
                onFrame: i,
                pathFormatted: !1,
              };
              r.length > 0 ? (r = We(r, b)) : n.addAnimator(this),
                r.push(b),
                this.set('animations', r),
                this.set('_pause', { isPaused: !1 });
            }
          }),
          (e.prototype.stopAnimate = function (t) {
            const e = this;
            void 0 === t && (t = !0);
            const n = this.get('animations');
            Object(p.each)(n, (n) => {
              t && (n.onFrame ? e.attr(n.onFrame(1)) : e.attr(n.toAttrs)),
                n.callback && n.callback();
            }),
              this.set('animating', !1),
              this.set('animations', []);
          }),
          (e.prototype.pauseAnimate = function () {
            const t = this.get('timeline');
            const e = this.get('animations');
            const n = t.getTime();
            return (
              Object(p.each)(e, (t) => {
                (t._paused = !0), (t._pauseTime = n), t.pauseCallback && t.pauseCallback();
              }),
              this.set('_pause', { isPaused: !0, pauseTime: n }),
              this
            );
          }),
          (e.prototype.resumeAnimate = function () {
            const t = this.get('timeline').getTime();
            const e = this.get('animations');
            const n = this.get('_pause').pauseTime;
            return (
              Object(p.each)(e, (e) => {
                (e.startTime += t - n),
                  (e._paused = !1),
                  (e._pauseTime = null),
                  e.resumeCallback && e.resumeCallback();
              }),
              this.set('_pause', { isPaused: !1 }),
              this.set('animations', e),
              this
            );
          }),
          (e.prototype.emitDelegation = function (t, e) {
            let n;
            const r = this;
            const i = e.propagationPath;
            this.getEvents();
            t === 'mouseenter' ? (n = e.fromShape) : t === 'mouseleave' && (n = e.toShape);
            for (
              var o = function (t) {
                  const o = i[t];
                  const s = o.get('name');
                  if (s) {
                    if ((o.isGroup() || (o.isCanvas && o.isCanvas())) && n && Q(o, n))
                      return 'break';
                    Object(p.isArray)(s)
                      ? Object(p.each)(s, (t) => {
                          r.emitDelegateEvent(o, t, e);
                        })
                      : a.emitDelegateEvent(o, s, e);
                  }
                },
                a = this,
                s = 0;
              s < i.length;
              s++
            ) {
              if (o(s) === 'break') break;
            }
          }),
          (e.prototype.emitDelegateEvent = function (t, e, n) {
            const r = this.getEvents();
            const i = `${e}:${n.type}`;
            (r[i] || r['*']) &&
              ((n.name = i),
              (n.currentTarget = t),
              (n.delegateTarget = this),
              (n.delegateObject = t.get('delegateObject')),
              this.emit(i, n));
          }),
          (e.prototype.translate = function (t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            const n = this.getMatrix();
            const r = Re(n, [['t', t, e]]);
            return this.setMatrix(r), this;
          }),
          (e.prototype.move = function (t, e) {
            const n = this.attr('x') || 0;
            const r = this.attr('y') || 0;
            return this.translate(t - n, e - r), this;
          }),
          (e.prototype.moveTo = function (t, e) {
            return this.move(t, e);
          }),
          (e.prototype.scale = function (t, e) {
            const n = this.getMatrix();
            const r = Re(n, [['s', t, e || t]]);
            return this.setMatrix(r), this;
          }),
          (e.prototype.rotate = function (t) {
            const e = this.getMatrix();
            const n = Re(e, [['r', t]]);
            return this.setMatrix(n), this;
          }),
          (e.prototype.rotateAtStart = function (t) {
            const e = this.attr();
            const n = e.x;
            const r = e.y;
            const i = this.getMatrix();
            const o = Re(i, [
              ['t', -n, -r],
              ['r', t],
              ['t', n, r],
            ]);
            return this.setMatrix(o), this;
          }),
          (e.prototype.rotateAtPoint = function (t, e, n) {
            const r = this.getMatrix();
            const i = Re(r, [
              ['t', -t, -e],
              ['r', n],
              ['t', t, e],
            ]);
            return this.setMatrix(i), this;
          }),
          e
        );
      })(tt);
      const Ue = {};
      const He = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.isCanvas = function () {
            return !1;
          }),
          (e.prototype.getBBox = function () {
            let t = 1 / 0;
            let e = -1 / 0;
            let n = 1 / 0;
            let r = -1 / 0;
            const i = [];
            const o = [];
            const a = this.getChildren().filter((t) => {
              return (
                t.get('visible') && (!t.isGroup() || (t.isGroup() && t.getChildren().length > 0))
              );
            });
            return (
              a.length > 0
                ? (Object(p.each)(a, (t) => {
                    const e = t.getBBox();
                    i.push(e.minX, e.maxX), o.push(e.minY, e.maxY);
                  }),
                  (t = Object(p.min)(i)),
                  (e = Object(p.max)(i)),
                  (n = Object(p.min)(o)),
                  (r = Object(p.max)(o)))
                : ((t = 0), (e = 0), (n = 0), (r = 0)),
              { x: t, y: n, minX: t, minY: n, maxX: e, maxY: r, width: e - t, height: r - n }
            );
          }),
          (e.prototype.getCanvasBBox = function () {
            let t = 1 / 0;
            let e = -1 / 0;
            let n = 1 / 0;
            let r = -1 / 0;
            const i = [];
            const o = [];
            const a = this.getChildren().filter((t) => {
              return (
                t.get('visible') && (!t.isGroup() || (t.isGroup() && t.getChildren().length > 0))
              );
            });
            return (
              a.length > 0
                ? (Object(p.each)(a, (t) => {
                    const e = t.getCanvasBBox();
                    i.push(e.minX, e.maxX), o.push(e.minY, e.maxY);
                  }),
                  (t = Object(p.min)(i)),
                  (e = Object(p.max)(i)),
                  (n = Object(p.min)(o)),
                  (r = Object(p.max)(o)))
                : ((t = 0), (e = 0), (n = 0), (r = 0)),
              { x: t, y: n, minX: t, minY: n, maxX: e, maxY: r, width: e - t, height: r - n }
            );
          }),
          (e.prototype.getDefaultCfg = function () {
            const e = t.prototype.getDefaultCfg.call(this);
            return (e.children = []), e;
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            if ((t.prototype.onAttrChange.call(this, e, n, r), e === 'matrix')) {
              const i = this.getTotalMatrix();
              this._applyChildrenMarix(i);
            }
          }),
          (e.prototype.applyMatrix = function (e) {
            const n = this.getTotalMatrix();
            t.prototype.applyMatrix.call(this, e);
            const r = this.getTotalMatrix();
            r !== n && this._applyChildrenMarix(r);
          }),
          (e.prototype._applyChildrenMarix = function (t) {
            const e = this.getChildren();
            Object(p.each)(e, (e) => {
              e.applyMatrix(t);
            });
          }),
          (e.prototype.addShape = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            const n = t[0];
            let r = t[1];
            Object(p.isObject)(n) ? (r = n) : (r.type = n);
            let i = Ue[r.type];
            i || ((i = Object(p.upperFirst)(r.type)), (Ue[r.type] = i));
            const o = this.getShapeBase();
            const a = new o[i](r);
            return this.add(a), a;
          }),
          (e.prototype.addGroup = function () {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            let n;
            const r = t[0];
            const i = t[1];
            if (Object(p.isFunction)(r)) n = new r(i || { parent: this });
            else {
              const o = r || {};
              const a = this.getGroupBase();
              n = new a(o);
            }
            return this.add(n), n;
          }),
          (e.prototype.getCanvas = function () {
            return this.isCanvas() ? this : this.get('canvas');
          }),
          (e.prototype.getShape = function (t, e, n) {
            if (!J(this)) return null;
            let r;
            const i = this.getChildren();
            if (this.isCanvas()) r = this._findShape(i, t, e, n);
            else {
              let o = [t, e, 1];
              (o = this.invertFromMatrix(o)),
                this.isClipped(o[0], o[1]) || (r = this._findShape(i, o[0], o[1], n));
            }
            return r;
          }),
          (e.prototype._findShape = function (t, e, n, r) {
            for (var i = null, o = t.length - 1; o >= 0; o--) {
              const a = t[o];
              if ((J(a) && (a.isGroup() ? (i = a.getShape(e, n, r)) : a.isHit(e, n) && (i = a)), i))
                break;
            }
            return i;
          }),
          (e.prototype.add = function (t) {
            const e = this.getCanvas();
            const n = this.getChildren();
            const r = this.get('timeline');
            const i = t.getParent();
            i &&
              (function (t, e, n) {
                void 0 === n && (n = !0),
                  n ? e.destroy() : (e.set('parent', null), e.set('canvas', null)),
                  K(t.getChildren(), e);
              })(i, t, !1),
              t.set('parent', this),
              e &&
                (function t(e, n) {
                  if ((e.set('canvas', n), e.isGroup())) {
                    const r = e.get('children');
                    r.length &&
                      r.forEach((e) => {
                        t(e, n);
                      });
                  }
                })(t, e),
              r &&
                (function t(e, n) {
                  if ((e.set('timeline', n), e.isGroup())) {
                    const r = e.get('children');
                    r.length &&
                      r.forEach((e) => {
                        t(e, n);
                      });
                  }
                })(t, r),
              n.push(t),
              t.onCanvasChange('add'),
              this._applyElementMatrix(t);
          }),
          (e.prototype._applyElementMatrix = function (t) {
            const e = this.getTotalMatrix();
            e && t.applyMatrix(e);
          }),
          (e.prototype.getChildren = function () {
            return this.get('children');
          }),
          (e.prototype.sort = function () {
            let t;
            const e = this.getChildren();
            Object(p.each)(e, (t, e) => {
              return (t._INDEX = e), t;
            }),
              e.sort(
                ((t = function (t, e) {
                  return t.get('zIndex') - e.get('zIndex');
                }),
                function (e, n) {
                  const r = t(e, n);
                  return r === 0 ? e._INDEX - n._INDEX : r;
                }),
              ),
              this.onCanvasChange('sort');
          }),
          (e.prototype.clear = function () {
            if ((this.set('clearing', !0), !this.destroyed)) {
              for (let t = this.getChildren(), e = t.length - 1; e >= 0; e--) t[e].destroy();
              this.set('children', []), this.onCanvasChange('clear'), this.set('clearing', !1);
            }
          }),
          (e.prototype.destroy = function () {
            this.get('destroyed') || (this.clear(), t.prototype.destroy.call(this));
          }),
          (e.prototype.getFirst = function () {
            return this.getChildByIndex(0);
          }),
          (e.prototype.getLast = function () {
            const t = this.getChildren();
            return this.getChildByIndex(t.length - 1);
          }),
          (e.prototype.getChildByIndex = function (t) {
            return this.getChildren()[t];
          }),
          (e.prototype.getCount = function () {
            return this.getChildren().length;
          }),
          (e.prototype.contain = function (t) {
            return this.getChildren().indexOf(t) > -1;
          }),
          (e.prototype.removeChild = function (t, e) {
            void 0 === e && (e = !0), this.contain(t) && t.remove(e);
          }),
          (e.prototype.findAll = function (t) {
            let e = [];
            const n = this.getChildren();
            return (
              Object(p.each)(n, (n) => {
                t(n) && e.push(n), n.isGroup() && (e = e.concat(n.findAll(t)));
              }),
              e
            );
          }),
          (e.prototype.find = function (t) {
            let e = null;
            const n = this.getChildren();
            return (
              Object(p.each)(n, (n) => {
                if ((t(n) ? (e = n) : n.isGroup() && (e = n.find(t)), e)) return !1;
              }),
              e
            );
          }),
          (e.prototype.findById = function (t) {
            return this.find((e) => {
              return e.get('id') === t;
            });
          }),
          (e.prototype.findByClassName = function (t) {
            return this.find((e) => {
              return e.get('className') === t;
            });
          }),
          (e.prototype.findAllByName = function (t) {
            return this.findAll((e) => {
              return e.get('name') === t;
            });
          }),
          e
        );
      })(Ge);
      function qe(t) {
        return (qe =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      let Ve;
      let Ze;
      let Ke = 0;
      let $e = 0;
      let Qe = 0;
      let Je = 0;
      let tn = 0;
      let en = 0;
      const nn =
        (typeof performance === 'undefined' ? 'undefined' : qe(performance)) === 'object' &&
        performance.now
          ? performance
          : Date;
      const rn =
        (typeof window === 'undefined' ? 'undefined' : qe(window)) === 'object' &&
        window.requestAnimationFrame
          ? window.requestAnimationFrame.bind(window)
          : function (t) {
              setTimeout(t, 17);
            };
      function on() {
        return tn || (rn(an), (tn = nn.now() + en));
      }
      function an() {
        tn = 0;
      }
      function sn() {
        this._call = this._time = this._next = null;
      }
      function un(t, e, n) {
        const r = new sn();
        return r.restart(t, e, n), r;
      }
      function cn() {
        (tn = (Je = nn.now()) + en), (Ke = $e = 0);
        try {
          !(function () {
            on(), ++Ke;
            for (var t, e = Ve; e; )
              (t = tn - e._time) >= 0 && e._call.call(null, t), (e = e._next);
            --Ke;
          })();
        } finally {
          (Ke = 0),
            (function () {
              let t;
              let e;
              let n = Ve;
              let r = 1 / 0;
              for (; n; )
                n._call
                  ? (r > n._time && (r = n._time), (t = n), (n = n._next))
                  : ((e = n._next), (n._next = null), (n = t ? (t._next = e) : (Ve = e)));
              (Ze = t), ln(r);
            })(),
            (tn = 0);
        }
      }
      function hn() {
        const t = nn.now();
        const e = t - Je;
        e > 1e3 && ((en -= e), (Je = t));
      }
      function ln(t) {
        Ke ||
          ($e && ($e = clearTimeout($e)),
          t - tn > 24
            ? (t < 1 / 0 && ($e = setTimeout(cn, t - nn.now() - en)),
              Qe && (Qe = clearInterval(Qe)))
            : (Qe || ((Je = nn.now()), (Qe = setInterval(hn, 1e3))), (Ke = 1), rn(cn)));
      }
      function fn(t) {
        return +t;
      }
      function dn(t) {
        return t * t;
      }
      function pn(t) {
        return t * (2 - t);
      }
      function gn(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
      }
      function vn(t) {
        return t * t * t;
      }
      function yn(t) {
        return --t * t * t + 1;
      }
      function mn(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
      }
      sn.prototype = un.prototype = {
        constructor: sn,
        restart(t, e, n) {
          if (typeof t !== 'function') throw new TypeError('callback is not a function');
          (n = (n == null ? on() : +n) + (e == null ? 0 : +e)),
            this._next || Ze === this || (Ze ? (Ze._next = this) : (Ve = this), (Ze = this)),
            (this._call = t),
            (this._time = n),
            ln();
        },
        stop() {
          this._call && ((this._call = null), (this._time = 1 / 0), ln());
        },
      };
      var bn = (function t(e) {
        function n(t) {
          return Math.pow(t, e);
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      var xn = (function t(e) {
        function n(t) {
          return 1 - Math.pow(1 - t, e);
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      var Mn = (function t(e) {
        function n(t) {
          return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      const Sn = Math.PI;
      const wn = Sn / 2;
      function On(t) {
        return +t == 1 ? 1 : 1 - Math.cos(t * wn);
      }
      function Cn(t) {
        return Math.sin(t * wn);
      }
      function En(t) {
        return (1 - Math.cos(Sn * t)) / 2;
      }
      function kn(t) {
        return 1.0009775171065494 * (Math.pow(2, -10 * t) - 0.0009765625);
      }
      function Tn(t) {
        return kn(1 - +t);
      }
      function Pn(t) {
        return 1 - kn(t);
      }
      function In(t) {
        return ((t *= 2) <= 1 ? kn(1 - t) : 2 - kn(t - 1)) / 2;
      }
      function An(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function jn(t) {
        return Math.sqrt(1 - --t * t);
      }
      function Nn(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
      }
      function _n(t) {
        return 1 - Bn(1 - t);
      }
      function Bn(t) {
        return (t = +t) < 4 / 11
          ? 7.5625 * t * t
          : t < 8 / 11
          ? 7.5625 * (t -= 6 / 11) * t + 3 / 4
          : t < 10 / 11
          ? 7.5625 * (t -= 9 / 11) * t + 15 / 16
          : 7.5625 * (t -= 21 / 22) * t + 63 / 64;
      }
      function Ln(t) {
        return ((t *= 2) <= 1 ? 1 - Bn(1 - t) : Bn(t - 1) + 1) / 2;
      }
      var Dn = (function t(e) {
        function n(t) {
          return (t = +t) * t * (e * (t - 1) + t);
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      var Rn = (function t(e) {
        function n(t) {
          return --t * t * ((t + 1) * e + t) + 1;
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      var Yn = (function t(e) {
        function n(t) {
          return (
            ((t *= 2) < 1 ? t * t * ((e + 1) * t - e) : (t -= 2) * t * ((e + 1) * t + e) + 2) / 2
          );
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      const Fn = 2 * Math.PI;
      var Xn = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Fn);
        function i(t) {
          return e * kn(-(--t)) * Math.sin((r - t) / n);
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * Fn);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      var zn = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Fn);
        function i(t) {
          return 1 - e * kn((t = +t)) * Math.sin((t + r) / n);
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * Fn);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      var Wn = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= Fn);
        function i(t) {
          return (
            ((t = 2 * t - 1) < 0
              ? e * kn(-t) * Math.sin((r - t) / n)
              : 2 - e * kn(t) * Math.sin((r + t) / n)) / 2
          );
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * Fn);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      const Gn = function (t, e, n) {
        (t.prototype = e.prototype = n), (n.constructor = t);
      };
      function Un(t, e) {
        const n = Object.create(t.prototype);
        for (const r in e) n[r] = e[r];
        return n;
      }
      function Hn() {}
      const qn = '\\s*([+-]?\\d+)\\s*';
      const Vn = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*';
      const Zn = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
      const Kn = /^#([0-9a-f]{3,8})$/;
      const $n = new RegExp(`^rgb\\(${[qn, qn, qn]}\\)$`);
      const Qn = new RegExp(`^rgb\\(${[Zn, Zn, Zn]}\\)$`);
      const Jn = new RegExp(`^rgba\\(${[qn, qn, qn, Vn]}\\)$`);
      const tr = new RegExp(`^rgba\\(${[Zn, Zn, Zn, Vn]}\\)$`);
      const er = new RegExp(`^hsl\\(${[Vn, Zn, Zn]}\\)$`);
      const nr = new RegExp(`^hsla\\(${[Vn, Zn, Zn, Vn]}\\)$`);
      const rr = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      };
      function ir() {
        return this.rgb().formatHex();
      }
      function or() {
        return this.rgb().formatRgb();
      }
      function ar(t) {
        let e;
        let n;
        return (
          (t = `${t}`.trim().toLowerCase()),
          (e = Kn.exec(t))
            ? ((n = e[1].length),
              (e = parseInt(e[1], 16)),
              n === 6
                ? sr(e)
                : n === 3
                ? new lr(
                    ((e >> 8) & 15) | ((e >> 4) & 240),
                    ((e >> 4) & 15) | (240 & e),
                    ((15 & e) << 4) | (15 & e),
                    1,
                  )
                : n === 8
                ? ur((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, (255 & e) / 255)
                : n === 4
                ? ur(
                    ((e >> 12) & 15) | ((e >> 8) & 240),
                    ((e >> 8) & 15) | ((e >> 4) & 240),
                    ((e >> 4) & 15) | (240 & e),
                    (((15 & e) << 4) | (15 & e)) / 255,
                  )
                : null)
            : (e = $n.exec(t))
            ? new lr(e[1], e[2], e[3], 1)
            : (e = Qn.exec(t))
            ? new lr((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, 1)
            : (e = Jn.exec(t))
            ? ur(e[1], e[2], e[3], e[4])
            : (e = tr.exec(t))
            ? ur((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, e[4])
            : (e = er.exec(t))
            ? gr(e[1], e[2] / 100, e[3] / 100, 1)
            : (e = nr.exec(t))
            ? gr(e[1], e[2] / 100, e[3] / 100, e[4])
            : rr.hasOwnProperty(t)
            ? sr(rr[t])
            : t === 'transparent'
            ? new lr(NaN, NaN, NaN, 0)
            : null
        );
      }
      function sr(t) {
        return new lr((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
      }
      function ur(t, e, n, r) {
        return r <= 0 && (t = e = n = NaN), new lr(t, e, n, r);
      }
      function cr(t) {
        return (
          t instanceof Hn || (t = ar(t)),
          t ? new lr((t = t.rgb()).r, t.g, t.b, t.opacity) : new lr()
        );
      }
      function hr(t, e, n, r) {
        return arguments.length === 1 ? cr(t) : new lr(t, e, n, r == null ? 1 : r);
      }
      function lr(t, e, n, r) {
        (this.r = +t), (this.g = +e), (this.b = +n), (this.opacity = +r);
      }
      function fr() {
        return `#${pr(this.r)}${pr(this.g)}${pr(this.b)}`;
      }
      function dr() {
        let t = this.opacity;
        return `${
          ((t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) === 1 ? 'rgb(' : 'rgba(') +
          Math.max(0, Math.min(255, Math.round(this.r) || 0))
        }, ${Math.max(0, Math.min(255, Math.round(this.g) || 0))}, ${Math.max(
          0,
          Math.min(255, Math.round(this.b) || 0),
        )}${t === 1 ? ')' : `, ${t})`}`;
      }
      function pr(t) {
        return (
          ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? '0' : '') + t.toString(16)
        );
      }
      function gr(t, e, n, r) {
        return (
          r <= 0 ? (t = e = n = NaN) : n <= 0 || n >= 1 ? (t = e = NaN) : e <= 0 && (t = NaN),
          new yr(t, e, n, r)
        );
      }
      function vr(t) {
        if (t instanceof yr) return new yr(t.h, t.s, t.l, t.opacity);
        if ((t instanceof Hn || (t = ar(t)), !t)) return new yr();
        if (t instanceof yr) return t;
        const e = (t = t.rgb()).r / 255;
        const n = t.g / 255;
        const r = t.b / 255;
        const i = Math.min(e, n, r);
        const o = Math.max(e, n, r);
        let a = NaN;
        let s = o - i;
        const u = (o + i) / 2;
        return (
          s
            ? ((a =
                e === o ? (n - r) / s + 6 * (n < r) : n === o ? (r - e) / s + 2 : (e - n) / s + 4),
              (s /= u < 0.5 ? o + i : 2 - o - i),
              (a *= 60))
            : (s = u > 0 && u < 1 ? 0 : a),
          new yr(a, s, u, t.opacity)
        );
      }
      function yr(t, e, n, r) {
        (this.h = +t), (this.s = +e), (this.l = +n), (this.opacity = +r);
      }
      function mr(t, e, n) {
        return (
          255 *
          (t < 60
            ? e + ((n - e) * t) / 60
            : t < 180
            ? n
            : t < 240
            ? e + ((n - e) * (240 - t)) / 60
            : e)
        );
      }
      function br(t, e, n, r, i) {
        const o = t * t;
        const a = o * t;
        return (
          ((1 - 3 * t + 3 * o - a) * e +
            (4 - 6 * o + 3 * a) * n +
            (1 + 3 * t + 3 * o - 3 * a) * r +
            a * i) /
          6
        );
      }
      Gn(Hn, ar, {
        copy(t) {
          return Object.assign(new this.constructor(), this, t);
        },
        displayable() {
          return this.rgb().displayable();
        },
        hex: ir,
        formatHex: ir,
        formatHsl() {
          return vr(this).formatHsl();
        },
        formatRgb: or,
        toString: or,
      }),
        Gn(
          lr,
          hr,
          Un(Hn, {
            brighter(t) {
              return (
                (t = t == null ? 1 / 0.7 : Math.pow(1 / 0.7, t)),
                new lr(this.r * t, this.g * t, this.b * t, this.opacity)
              );
            },
            darker(t) {
              return (
                (t = t == null ? 0.7 : Math.pow(0.7, t)),
                new lr(this.r * t, this.g * t, this.b * t, this.opacity)
              );
            },
            rgb() {
              return this;
            },
            displayable() {
              return (
                this.r >= -0.5 &&
                this.r < 255.5 &&
                this.g >= -0.5 &&
                this.g < 255.5 &&
                this.b >= -0.5 &&
                this.b < 255.5 &&
                this.opacity >= 0 &&
                this.opacity <= 1
              );
            },
            hex: fr,
            formatHex: fr,
            formatRgb: dr,
            toString: dr,
          }),
        ),
        Gn(
          yr,
          function (t, e, n, r) {
            return arguments.length === 1 ? vr(t) : new yr(t, e, n, r == null ? 1 : r);
          },
          Un(Hn, {
            brighter(t) {
              return (
                (t = t == null ? 1 / 0.7 : Math.pow(1 / 0.7, t)),
                new yr(this.h, this.s, this.l * t, this.opacity)
              );
            },
            darker(t) {
              return (
                (t = t == null ? 0.7 : Math.pow(0.7, t)),
                new yr(this.h, this.s, this.l * t, this.opacity)
              );
            },
            rgb() {
              const t = (this.h % 360) + 360 * (this.h < 0);
              const e = isNaN(t) || isNaN(this.s) ? 0 : this.s;
              const n = this.l;
              const r = n + (n < 0.5 ? n : 1 - n) * e;
              const i = 2 * n - r;
              return new lr(
                mr(t >= 240 ? t - 240 : t + 120, i, r),
                mr(t, i, r),
                mr(t < 120 ? t + 240 : t - 120, i, r),
                this.opacity,
              );
            },
            displayable() {
              return (
                ((this.s >= 0 && this.s <= 1) || isNaN(this.s)) &&
                this.l >= 0 &&
                this.l <= 1 &&
                this.opacity >= 0 &&
                this.opacity <= 1
              );
            },
            formatHsl() {
              let t = this.opacity;
              return `${
                ((t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) === 1 ? 'hsl(' : 'hsla(') +
                (this.h || 0)
              }, ${100 * (this.s || 0)}%, ${100 * (this.l || 0)}%${t === 1 ? ')' : `, ${t})`}`;
            },
          }),
        );
      const xr = function (t) {
        return function () {
          return t;
        };
      };
      function Mr(t, e) {
        return function (n) {
          return t + n * e;
        };
      }
      function Sr(t) {
        return (t = +t) == 1
          ? wr
          : function (e, n) {
              return n - e
                ? (function (t, e, n) {
                    return (
                      (t = Math.pow(t, n)),
                      (e = Math.pow(e, n) - t),
                      (n = 1 / n),
                      function (r) {
                        return Math.pow(t + r * e, n);
                      }
                    );
                  })(e, n, t)
                : xr(isNaN(e) ? n : e);
            };
      }
      function wr(t, e) {
        const n = e - t;
        return n ? Mr(t, n) : xr(isNaN(t) ? e : t);
      }
      const Or = (function t(e) {
        const n = Sr(e);
        function r(t, e) {
          const r = n((t = hr(t)).r, (e = hr(e)).r);
          const i = n(t.g, e.g);
          const o = n(t.b, e.b);
          const a = wr(t.opacity, e.opacity);
          return function (e) {
            return (t.r = r(e)), (t.g = i(e)), (t.b = o(e)), (t.opacity = a(e)), `${t}`;
          };
        }
        return (r.gamma = t), r;
      })(1);
      function Cr(t) {
        return function (e) {
          let n;
          let r;
          const i = e.length;
          let o = new Array(i);
          let a = new Array(i);
          let s = new Array(i);
          for (n = 0; n < i; ++n)
            (r = hr(e[n])), (o[n] = r.r || 0), (a[n] = r.g || 0), (s[n] = r.b || 0);
          return (
            (o = t(o)),
            (a = t(a)),
            (s = t(s)),
            (r.opacity = 1),
            function (t) {
              return (r.r = o(t)), (r.g = a(t)), (r.b = s(t)), `${r}`;
            }
          );
        };
      }
      Cr((t) => {
        const e = t.length - 1;
        return function (n) {
          const r = n <= 0 ? (n = 0) : n >= 1 ? ((n = 1), e - 1) : Math.floor(n * e);
          const i = t[r];
          const o = t[r + 1];
          const a = r > 0 ? t[r - 1] : 2 * i - o;
          const s = r < e - 1 ? t[r + 2] : 2 * o - i;
          return br((n - r / e) * e, a, i, o, s);
        };
      }),
        Cr((t) => {
          const e = t.length;
          return function (n) {
            const r = Math.floor(((n %= 1) < 0 ? ++n : n) * e);
            const i = t[(r + e - 1) % e];
            const o = t[r % e];
            const a = t[(r + 1) % e];
            const s = t[(r + 2) % e];
            return br((n - r / e) * e, i, o, a, s);
          };
        });
      const Er = function (t, e) {
        e || (e = []);
        let n;
        const r = t ? Math.min(e.length, t.length) : 0;
        const i = e.slice();
        return function (o) {
          for (n = 0; n < r; ++n) i[n] = t[n] * (1 - o) + e[n] * o;
          return i;
        };
      };
      function kr(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      }
      function Tr(t, e) {
        let n;
        const r = e ? e.length : 0;
        const i = t ? Math.min(r, t.length) : 0;
        const o = new Array(i);
        const a = new Array(r);
        for (n = 0; n < i; ++n) o[n] = Dr(t[n], e[n]);
        for (; n < r; ++n) a[n] = e[n];
        return function (t) {
          for (n = 0; n < i; ++n) a[n] = o[n](t);
          return a;
        };
      }
      const Pr = function (t, e) {
        const n = new Date();
        return (
          (t = +t),
          (e = +e),
          function (r) {
            return n.setTime(t * (1 - r) + e * r), n;
          }
        );
      };
      const Ir = function (t, e) {
        return (
          (t = +t),
          (e = +e),
          function (n) {
            return t * (1 - n) + e * n;
          }
        );
      };
      function Ar(t) {
        return (Ar =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const jr = function (t, e) {
        let n;
        const r = {};
        const i = {};
        for (n in ((t !== null && Ar(t) === 'object') || (t = {}),
        (e !== null && Ar(e) === 'object') || (e = {}),
        e))
          n in t ? (r[n] = Dr(t[n], e[n])) : (i[n] = e[n]);
        return function (t) {
          for (n in r) i[n] = r[n](t);
          return i;
        };
      };
      const Nr = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
      const _r = new RegExp(Nr.source, 'g');
      const Br = function (t, e) {
        let n;
        let r;
        let i;
        let o = (Nr.lastIndex = _r.lastIndex = 0);
        let a = -1;
        const s = [];
        const u = [];
        for (t += '', e += ''; (n = Nr.exec(t)) && (r = _r.exec(e)); )
          (i = r.index) > o && ((i = e.slice(o, i)), s[a] ? (s[a] += i) : (s[++a] = i)),
            (n = n[0]) === (r = r[0])
              ? s[a]
                ? (s[a] += r)
                : (s[++a] = r)
              : ((s[++a] = null), u.push({ i: a, x: Ir(n, r) })),
            (o = _r.lastIndex);
        return (
          o < e.length && ((i = e.slice(o)), s[a] ? (s[a] += i) : (s[++a] = i)),
          s.length < 2
            ? u[0]
              ? (function (t) {
                  return function (e) {
                    return `${t(e)}`;
                  };
                })(u[0].x)
              : (function (t) {
                  return function () {
                    return t;
                  };
                })(e)
            : ((e = u.length),
              function (t) {
                for (var n, r = 0; r < e; ++r) s[(n = u[r]).i] = n.x(t);
                return s.join('');
              })
        );
      };
      function Lr(t) {
        return (Lr =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var Dr = function (t, e) {
        let n;
        const r = Lr(e);
        return e == null || r === 'boolean'
          ? xr(e)
          : (r === 'number'
              ? Ir
              : r === 'string'
              ? (n = ar(e))
                ? ((e = n), Or)
                : Br
              : e instanceof ar
              ? Or
              : e instanceof Date
              ? Pr
              : kr(e)
              ? Er
              : Array.isArray(e)
              ? Tr
              : (typeof e.valueOf !== 'function' && typeof e.toString !== 'function') || isNaN(e)
              ? jr
              : Ir)(t, e);
      };
      const Rr = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      function Yr(t, e, n) {
        let r;
        const i = e.startTime;
        if (n < i + e.delay || e._paused) return !1;
        const o = e.duration;
        const a = e.easing;
        if (((n = n - i - e.delay), e.repeat)) (r = (n % o) / o), (r = s[a](r));
        else {
          if (!((r = n / o) < 1)) return e.onFrame ? t.attr(e.onFrame(1)) : t.attr(e.toAttrs), !0;
          r = s[a](r);
        }
        if (e.onFrame) {
          const u = e.onFrame(r);
          t.attr(u);
        } else
          !(function (t, e, n) {
            const r = {};
            const i = e.fromAttrs;
            const o = e.toAttrs;
            if (!t.destroyed) {
              let a;
              let s;
              let u;
              let c;
              for (const h in o)
                if (!Object(p.isEqual)(i[h], o[h]))
                  if (h === 'path') {
                    let l = o[h];
                    let f = i[h];
                    l.length > f.length
                      ? ((l = m(o[h])),
                        (f = m(i[h])),
                        (f = G(f, l)),
                        (f = q(f, l)),
                        (e.fromAttrs.path = f),
                        (e.toAttrs.path = l))
                      : e.pathFormatted ||
                        ((l = m(o[h])),
                        (f = m(i[h])),
                        (f = q(f, l)),
                        (e.fromAttrs.path = f),
                        (e.toAttrs.path = l),
                        (e.pathFormatted = !0)),
                      (r[h] = []);
                    for (let d = 0; d < l.length; d++) {
                      for (var g = l[d], v = f[d], y = [], b = 0; b < g.length; b++)
                        Object(p.isNumber)(g[b]) && v && Object(p.isNumber)(v[b])
                          ? ((a = Dr(v[b], g[b])), y.push(a(n)))
                          : y.push(g[b]);
                      r[h].push(y);
                    }
                  } else if (h === 'matrix') {
                    const x = ((u = i[h] || Rr), (kr((c = o[h] || Rr)) ? Er : Tr)(u, c))(n);
                    r[h] = x;
                  } else
                    ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(h) &&
                    ((s = o[h]), /^[r,R,L,l]{1}[\s]*\(/.test(s))
                      ? (r[h] = o[h])
                      : Object(p.isFunction)(o[h]) || ((a = Dr(i[h], o[h])), (r[h] = a(n)));
              t.attr(r);
            }
          })(t, e, r);
        return !1;
      }
      const Fr = (function () {
        function t(t) {
          (this.animators = []), (this.current = 0), (this.timer = null), (this.canvas = t);
        }
        return (
          (t.prototype.initTimer = function () {
            let t;
            let e;
            let n;
            const r = this;
            this.timer = un((i) => {
              if (((r.current = i), r.animators.length > 0)) {
                for (let o = r.animators.length - 1; o >= 0; o--)
                  if ((t = r.animators[o]).destroyed) r.removeAnimator(o);
                  else {
                    if (!t.isAnimatePaused())
                      for (let a = (e = t.get('animations')).length - 1; a >= 0; a--)
                        (n = e[a]), Yr(t, n, i) && (e.splice(a, 1), !1, n.callback && n.callback());
                    e.length === 0 && r.removeAnimator(o);
                  }
                r.canvas.get('autoDraw') || r.canvas.draw();
              }
            });
          }),
          (t.prototype.addAnimator = function (t) {
            this.animators.push(t);
          }),
          (t.prototype.removeAnimator = function (t) {
            this.animators.splice(t, 1);
          }),
          (t.prototype.isAnimating = function () {
            return !!this.animators.length;
          }),
          (t.prototype.stop = function () {
            this.timer && this.timer.stop();
          }),
          (t.prototype.stopAllAnimations = function (t) {
            void 0 === t && (t = !0),
              this.animators.forEach((e) => {
                e.stopAnimate(t);
              }),
              (this.animators = []),
              this.canvas.draw();
          }),
          (t.prototype.getTime = function () {
            return this.current;
          }),
          t
        );
      })();
      const Xr = [
        'mousedown',
        'mouseup',
        'dblclick',
        'mouseout',
        'mouseover',
        'mousemove',
        'mouseleave',
        'mouseenter',
        'touchstart',
        'touchmove',
        'touchend',
        'dragenter',
        'dragover',
        'dragleave',
        'drop',
        'contextmenu',
        'mousewheel',
      ];
      function zr(t, e, n) {
        (n.name = e), (n.target = t), (n.currentTarget = t), (n.delegateTarget = t), t.emit(e, n);
      }
      function Wr(t, e, n) {
        if (n.bubbles) {
          let r = void 0;
          let i = !1;
          if (
            (e === 'mouseenter'
              ? ((r = n.fromShape), (i = !0))
              : e === 'mouseleave' && ((i = !0), (r = n.toShape)),
            t.isCanvas() && i)
          )
            return;
          if (r && Q(t, r)) return void (n.bubbles = !1);
          (n.name = e), (n.currentTarget = t), (n.delegateTarget = t), t.emit(e, n);
        }
      }
      const Gr = (function () {
        function t(t) {
          const e = this;
          (this.draggingShape = null),
            (this.dragging = !1),
            (this.currentShape = null),
            (this.mousedownShape = null),
            (this.mousedownPoint = null),
            (this._eventCallback = function (t) {
              const n = t.type;
              e._triggerEvent(n, t);
            }),
            (this._onDocumentMove = function (t) {
              if (e.canvas.get('el') !== t.target && (e.dragging || e.currentShape)) {
                const n = e._getPointInfo(t);
                e.dragging && e._emitEvent('drag', t, n, e.draggingShape);
              }
            }),
            (this._onDocumentMouseUp = function (t) {
              if (e.canvas.get('el') !== t.target && e.dragging) {
                const n = e._getPointInfo(t);
                e.draggingShape && e._emitEvent('drop', t, n, null),
                  e._emitEvent('dragend', t, n, e.draggingShape),
                  e._afterDrag(e.draggingShape, n, t);
              }
            }),
            (this.canvas = t.canvas);
        }
        return (
          (t.prototype.init = function () {
            this._bindEvents();
          }),
          (t.prototype._bindEvents = function () {
            const t = this;
            const e = this.canvas.get('el');
            Object(p.each)(Xr, (n) => {
              e.addEventListener(n, t._eventCallback);
            }),
              document &&
                (document.addEventListener('mousemove', this._onDocumentMove),
                document.addEventListener('mouseup', this._onDocumentMouseUp));
          }),
          (t.prototype._clearEvents = function () {
            const t = this;
            const e = this.canvas.get('el');
            Object(p.each)(Xr, (n) => {
              e.removeEventListener(n, t._eventCallback);
            }),
              document &&
                (document.removeEventListener('mousemove', this._onDocumentMove),
                document.removeEventListener('mouseup', this._onDocumentMouseUp));
          }),
          (t.prototype._getEventObj = function (t, e, n, r, i, o) {
            const a = new V(t, e);
            return (
              (a.fromShape = i),
              (a.toShape = o),
              (a.x = n.x),
              (a.y = n.y),
              (a.clientX = n.clientX),
              (a.clientY = n.clientY),
              a.propagationPath.push(r),
              a
            );
          }),
          (t.prototype._getShape = function (t, e) {
            return this.canvas.getShape(t.x, t.y, e);
          }),
          (t.prototype._getPointInfo = function (t) {
            const e = this.canvas;
            const n = e.getClientByEvent(t);
            const r = e.getPointByEvent(t);
            return { x: r.x, y: r.y, clientX: n.x, clientY: n.y };
          }),
          (t.prototype._triggerEvent = function (t, e) {
            const n = this._getPointInfo(e);
            const r = this._getShape(n, e);
            const i = this[`_on${t}`];
            let o = !1;
            if (i) i.call(this, n, r, e);
            else {
              const a = this.currentShape;
              t === 'mouseenter' || t === 'dragenter' || t === 'mouseover'
                ? (this._emitEvent(t, e, n, null, null, r),
                  r && this._emitEvent(t, e, n, r, null, r),
                  t === 'mouseenter' &&
                    this.draggingShape &&
                    this._emitEvent('dragenter', e, n, null))
                : t === 'mouseleave' || t === 'dragleave' || t === 'mouseout'
                ? ((o = !0),
                  a && this._emitEvent(t, e, n, a, a, null),
                  this._emitEvent(t, e, n, null, a, null),
                  t === 'mouseleave' &&
                    this.draggingShape &&
                    this._emitEvent('dragleave', e, n, null))
                : this._emitEvent(t, e, n, r, null, null);
            }
            if ((o || (this.currentShape = r), r && !r.get('destroyed'))) {
              const s = this.canvas;
              s.get('el').style.cursor = r.attr('cursor') || s.get('cursor');
            }
          }),
          (t.prototype._onmousedown = function (t, e, n) {
            n.button === 0 &&
              ((this.mousedownShape = e),
              (this.mousedownPoint = t),
              (this.mousedownTimeStamp = n.timeStamp)),
              this._emitEvent('mousedown', n, t, e, null, null);
          }),
          (t.prototype._emitMouseoverEvents = function (t, e, n, r) {
            const i = this.canvas.get('el');
            n !== r &&
              (n &&
                (this._emitEvent('mouseout', t, e, n, n, r),
                this._emitEvent('mouseleave', t, e, n, n, r),
                (r && !r.get('destroyed')) || (i.style.cursor = this.canvas.get('cursor'))),
              r &&
                (this._emitEvent('mouseover', t, e, r, n, r),
                this._emitEvent('mouseenter', t, e, r, n, r)));
          }),
          (t.prototype._emitDragoverEvents = function (t, e, n, r, i) {
            r
              ? (r !== n &&
                  (n && this._emitEvent('dragleave', t, e, n, n, r),
                  this._emitEvent('dragenter', t, e, r, n, r)),
                i || this._emitEvent('dragover', t, e, r))
              : n && this._emitEvent('dragleave', t, e, n, n, r),
              i && this._emitEvent('dragover', t, e, r);
          }),
          (t.prototype._afterDrag = function (t, e, n) {
            t && (t.set('capture', !0), (this.draggingShape = null)), (this.dragging = !1);
            const r = this._getShape(e, n);
            r !== t && this._emitMouseoverEvents(n, e, t, r), (this.currentShape = r);
          }),
          (t.prototype._onmouseup = function (t, e, n) {
            if (n.button === 0) {
              const r = this.draggingShape;
              this.dragging
                ? (r && this._emitEvent('drop', n, t, e),
                  this._emitEvent('dragend', n, t, r),
                  this._afterDrag(r, t, n))
                : (this._emitEvent('mouseup', n, t, e),
                  e === this.mousedownShape && this._emitEvent('click', n, t, e),
                  (this.mousedownShape = null),
                  (this.mousedownPoint = null));
            }
          }),
          (t.prototype._ondragover = function (t, e, n) {
            n.preventDefault();
            const r = this.currentShape;
            this._emitDragoverEvents(n, t, r, e, !0);
          }),
          (t.prototype._onmousemove = function (t, e, n) {
            const r = this.canvas;
            const i = this.currentShape;
            let o = this.draggingShape;
            if (this.dragging)
              o && this._emitDragoverEvents(n, t, i, e, !1), this._emitEvent('drag', n, t, o);
            else {
              const a = this.mousedownPoint;
              if (a) {
                const s = this.mousedownShape;
                const u = n.timeStamp - this.mousedownTimeStamp;
                const c = a.clientX - t.clientX;
                const h = a.clientY - t.clientY;
                u > 120 || c * c + h * h > 40
                  ? s && s.get('draggable')
                    ? ((o = this.mousedownShape).set('capture', !1),
                      (this.draggingShape = o),
                      (this.dragging = !0),
                      this._emitEvent('dragstart', n, t, o),
                      (this.mousedownShape = null),
                      (this.mousedownPoint = null))
                    : !s && r.get('draggable')
                    ? ((this.dragging = !0),
                      this._emitEvent('dragstart', n, t, null),
                      (this.mousedownShape = null),
                      (this.mousedownPoint = null))
                    : (this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e))
                  : (this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e));
              } else this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e);
            }
          }),
          (t.prototype._emitEvent = function (t, e, n, r, i, o) {
            const a = this._getEventObj(t, e, n, r, i, o);
            if (r) {
              (a.shape = r), zr(r, t, a);
              for (let s = r.getParent(); s; )
                s.emitDelegation(t, a),
                  a.propagationStopped || Wr(s, t, a),
                  a.propagationPath.push(s),
                  (s = s.getParent());
            } else {
              zr(this.canvas, t, a);
            }
          }),
          (t.prototype.destroy = function () {
            this._clearEvents(),
              (this.canvas = null),
              (this.currentShape = null),
              (this.draggingShape = null),
              (this.mousedownPoint = null),
              (this.mousedownShape = null),
              (this.mousedownTimeStamp = null);
          }),
          t
        );
      })();
      const Ur = Object(et.a)();
      const Hr = Ur && Ur.name === 'firefox';
      const qr = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          return n.initContainer(), n.initDom(), n.initEvents(), n.initTimeline(), n;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultCfg = function () {
            const e = t.prototype.getDefaultCfg.call(this);
            return (e.cursor = 'default'), (e.supportCSSTransform = !1), e;
          }),
          (e.prototype.initContainer = function () {
            let t = this.get('container');
            Object(p.isString)(t) && ((t = document.getElementById(t)), this.set('container', t));
          }),
          (e.prototype.initDom = function () {
            const t = this.createDom();
            this.set('el', t),
              this.get('container').appendChild(t),
              this.setDOMSize(this.get('width'), this.get('height'));
          }),
          (e.prototype.initEvents = function () {
            const t = new Gr({ canvas: this });
            t.init(), this.set('eventController', t);
          }),
          (e.prototype.initTimeline = function () {
            const t = new Fr(this);
            this.set('timeline', t);
          }),
          (e.prototype.setDOMSize = function (t, e) {
            const n = this.get('el');
            $ && ((n.style.width = `${t}px`), (n.style.height = `${e}px`));
          }),
          (e.prototype.changeSize = function (t, e) {
            this.setDOMSize(t, e),
              this.set('width', t),
              this.set('height', e),
              this.onCanvasChange('changeSize');
          }),
          (e.prototype.getRenderer = function () {
            return this.get('renderer');
          }),
          (e.prototype.getCursor = function () {
            return this.get('cursor');
          }),
          (e.prototype.setCursor = function (t) {
            this.set('cursor', t);
            const e = this.get('el');
            $ && e && (e.style.cursor = t);
          }),
          (e.prototype.getPointByEvent = function (t) {
            if (this.get('supportCSSTransform')) {
              if (Hr && !Object(p.isNil)(t.layerX) && t.layerX !== t.offsetX)
                return { x: t.layerX, y: t.layerY };
              if (!Object(p.isNil)(t.offsetX)) return { x: t.offsetX, y: t.offsetY };
            }
            const e = this.getClientByEvent(t);
            const n = e.x;
            const r = e.y;
            return this.getPointByClient(n, r);
          }),
          (e.prototype.getClientByEvent = function (t) {
            let e = t;
            return (
              t.touches && (e = t.type === 'touchend' ? t.changedTouches[0] : t.touches[0]),
              { x: e.clientX, y: e.clientY }
            );
          }),
          (e.prototype.getPointByClient = function (t, e) {
            const n = this.get('el').getBoundingClientRect();
            return { x: t - n.left, y: e - n.top };
          }),
          (e.prototype.getClientByPoint = function (t, e) {
            const n = this.get('el').getBoundingClientRect();
            return { x: t + n.left, y: e + n.top };
          }),
          (e.prototype.draw = function () {}),
          (e.prototype.removeDom = function () {
            const t = this.get('el');
            t.parentNode.removeChild(t);
          }),
          (e.prototype.clearEvents = function () {
            this.get('eventController').destroy();
          }),
          (e.prototype.isCanvas = function () {
            return !0;
          }),
          (e.prototype.getParent = function () {
            return null;
          }),
          (e.prototype.destroy = function () {
            const e = this.get('timeline');
            this.get('destroyed') ||
              (this.clear(),
              e && e.stop(),
              this.clearEvents(),
              this.removeDom(),
              t.prototype.destroy.call(this));
          }),
          e
        );
      })(He);
      const Vr = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.isGroup = function () {
            return !0;
          }),
          (e.prototype.isEntityGroup = function () {
            return !1;
          }),
          (e.prototype.clone = function () {
            for (
              var e = t.prototype.clone.call(this), n = this.getChildren(), r = 0;
              r < n.length;
              r++
            ) {
              const i = n[r];
              e.add(i.clone());
            }
            return e;
          }),
          e
        );
      })(He);
      const Zr = (function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        return (
          f(e, t),
          (e.prototype._isInBBox = function (t, e) {
            const n = this.getBBox();
            return n.minX <= t && n.maxX >= t && n.minY <= e && n.maxY >= e;
          }),
          (e.prototype.afterAttrsChange = function (e) {
            t.prototype.afterAttrsChange.call(this, e), this.clearCacheBBox();
          }),
          (e.prototype.getBBox = function () {
            let t = this.cfg.bbox;
            return t || ((t = this.calculateBBox()), this.set('bbox', t)), t;
          }),
          (e.prototype.getCanvasBBox = function () {
            let t = this.cfg.canvasBBox;
            return t || ((t = this.calculateCanvasBBox()), this.set('canvasBBox', t)), t;
          }),
          (e.prototype.applyMatrix = function (e) {
            t.prototype.applyMatrix.call(this, e), this.set('canvasBBox', null);
          }),
          (e.prototype.calculateCanvasBBox = function () {
            const t = this.getBBox();
            const e = this.getTotalMatrix();
            let n = t.minX;
            let r = t.minY;
            let i = t.maxX;
            let o = t.maxY;
            if (e) {
              const a = Le(e, [t.minX, t.minY]);
              const s = Le(e, [t.maxX, t.minY]);
              const u = Le(e, [t.minX, t.maxY]);
              const c = Le(e, [t.maxX, t.maxY]);
              (n = Math.min(a[0], s[0], u[0], c[0])),
                (i = Math.max(a[0], s[0], u[0], c[0])),
                (r = Math.min(a[1], s[1], u[1], c[1])),
                (o = Math.max(a[1], s[1], u[1], c[1]));
            }
            const h = this.attrs;
            if (h.shadowColor) {
              const l = h.shadowBlur;
              const f = void 0 === l ? 0 : l;
              const d = h.shadowOffsetX;
              const p = void 0 === d ? 0 : d;
              const g = h.shadowOffsetY;
              const v = void 0 === g ? 0 : g;
              const y = n - f + p;
              const m = i + f + p;
              const b = r - f + v;
              const x = o + f + v;
              (n = Math.min(n, y)),
                (i = Math.max(i, m)),
                (r = Math.min(r, b)),
                (o = Math.max(o, x));
            }
            return { x: n, y: r, minX: n, minY: r, maxX: i, maxY: o, width: i - n, height: o - r };
          }),
          (e.prototype.clearCacheBBox = function () {
            this.set('bbox', null), this.set('canvasBBox', null);
          }),
          (e.prototype.isClipShape = function () {
            return this.get('isClipShape');
          }),
          (e.prototype.isInShape = function (t, e) {
            return !1;
          }),
          (e.prototype.isOnlyHitBox = function () {
            return !1;
          }),
          (e.prototype.isHit = function (t, e) {
            const n = this.get('startArrowShape');
            const r = this.get('endArrowShape');
            let i = [t, e, 1];
            const o = (i = this.invertFromMatrix(i))[0];
            const a = i[1];
            const s = this._isInBBox(o, a);
            if (this.isOnlyHitBox()) return s;
            if (s && !this.isClipped(o, a)) {
              if (this.isInShape(o, a)) return !0;
              if (n && n.isHit(o, a)) return !0;
              if (r && r.isHit(o, a)) return !0;
            }
            return !1;
          }),
          e
        );
      })(Ge);
      const Kr = new Map();
      function $r(t, e) {
        Kr.set(t, e);
      }
      const Qr = function (t) {
        const e = t.attr();
        return { x: e.x, y: e.y, width: e.width, height: e.height };
      };
      const Jr = function (t) {
        const e = t.attr();
        const n = e.x;
        const r = e.y;
        const i = e.r;
        return { x: n - i, y: r - i, width: 2 * i, height: 2 * i };
      };
      const ti = {}.toString;
      const ei = function (t, e) {
        return ti.call(t) === `[object ${e}]`;
      };
      const ni = function (t) {
        return ei(t, 'Function');
      };
      const ri = function (t) {
        return Array.isArray ? Array.isArray(t) : ei(t, 'Array');
      };
      function ii(t) {
        return (ii =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const oi = function (t) {
        const e = ii(t);
        return (t !== null && e === 'object') || e === 'function';
      };
      const ai = function (t, e) {
        if (t)
          if (ri(t)) for (let n = 0, r = t.length; n < r && !1 !== e(t[n], n); n++);
          else if (oi(t)) for (const i in t) if (t.hasOwnProperty(i) && !1 === e(t[i], i)) break;
      };
      Object.keys;
      const si = function (t) {
        if (ri(t))
          return t.reduce((t, e) => {
            return Math.max(t, e);
          }, t[0]);
      };
      const ui = function (t) {
        if (ri(t))
          return t.reduce((t, e) => {
            return Math.min(t, e);
          }, t[0]);
      };
      const ci = Array.prototype;
      const hi =
        (ci.splice,
        ci.indexOf,
        Array.prototype.splice,
        function (t) {
          return ei(t, 'String');
        });
      Object.prototype.hasOwnProperty;
      const li = function (t) {
        return ei(t, 'Number');
      };
      Number.isInteger && Number.isInteger;
      const fi = function (t, e) {
        return ((t % e) + e) % e;
      };
      const di = (Math.PI, parseInt, Math.PI / 180);
      const pi = function (t) {
        return di * t;
      };
      Object.values;
      Object.prototype;
      Object.prototype.hasOwnProperty;
      Object.prototype.hasOwnProperty;
      !(function () {
        function t() {
          this.map = {};
        }
        (t.prototype.has = function (t) {
          return void 0 !== this.map[t];
        }),
          (t.prototype.get = function (t, e) {
            const n = this.map[t];
            return void 0 === n ? e : n;
          }),
          (t.prototype.set = function (t, e) {
            this.map[t] = e;
          }),
          (t.prototype.clear = function () {
            this.map = {};
          }),
          (t.prototype.delete = function (t) {
            delete this.map[t];
          }),
          (t.prototype.size = function () {
            return Object.keys(this.map).length;
          });
      })();
      function gi(t, e, n, r) {
        const i = t - n;
        const o = e - r;
        return Math.sqrt(i * i + o * o);
      }
      function vi(t, e) {
        return Math.abs(t - e) < 0.001;
      }
      function yi(t, e) {
        const n = ui(t);
        const r = ui(e);
        return { x: n, y: r, width: si(t) - n, height: si(e) - r };
      }
      function mi(t, e, n, r) {
        return { minX: ui([t, n]), maxX: si([t, n]), minY: ui([e, r]), maxY: si([e, r]) };
      }
      function bi(t) {
        return (t + 2 * Math.PI) % (2 * Math.PI);
      }
      const xi = {
        box(t, e, n, r) {
          return yi([t, n], [e, r]);
        },
        length(t, e, n, r) {
          return gi(t, e, n, r);
        },
        pointAt(t, e, n, r, i) {
          return { x: (1 - i) * t + i * n, y: (1 - i) * e + i * r };
        },
        pointDistance(t, e, n, r, i, o) {
          const a = (n - t) * (i - t) + (r - e) * (o - e);
          return a < 0
            ? gi(t, e, i, o)
            : a > (n - t) * (n - t) + (r - e) * (r - e)
            ? gi(n, r, i, o)
            : this.pointToLine(t, e, n, r, i, o);
        },
        pointToLine(t, e, n, r, i, o) {
          const a = [n - t, r - e];
          if (ye(a, [0, 0])) return Math.sqrt((i - t) * (i - t) + (o - e) * (o - e));
          const s = [-a[1], a[0]];
          ie(s, s);
          const u = [i - t, o - e];
          return Math.abs(oe(u, s));
        },
        tangentAngle(t, e, n, r) {
          return Math.atan2(r - e, n - t);
        },
      };
      function Mi(t, e, n, r, i, o) {
        let a;
        let s = 1 / 0;
        const u = [n, r];
        let c = 20;
        o && o > 200 && (c = o / 10);
        for (var h = 1 / c, l = h / 10, f = 0; f <= c; f++) {
          const d = f * h;
          var p = [i.apply(null, t.concat([d])), i.apply(null, e.concat([d]))];
          (m = gi(u[0], u[1], p[0], p[1])) < s && ((a = d), (s = m));
        }
        if (a === 0) return { x: t[0], y: e[0] };
        if (a === 1) {
          const g = t.length;
          return { x: t[g - 1], y: e[g - 1] };
        }
        s = 1 / 0;
        for (f = 0; f < 32 && !(l < 1e-4); f++) {
          const v = a - l;
          const y = a + l;
          var m =
            ((p = [i.apply(null, t.concat([v])), i.apply(null, e.concat([v]))]),
            gi(u[0], u[1], p[0], p[1]));
          if (v >= 0 && m < s) (a = v), (s = m);
          else {
            const b = [i.apply(null, t.concat([y])), i.apply(null, e.concat([y]))];
            const x = gi(u[0], u[1], b[0], b[1]);
            y <= 1 && x < s ? ((a = y), (s = x)) : (l *= 0.5);
          }
        }
        return { x: i.apply(null, t.concat([a])), y: i.apply(null, e.concat([a])) };
      }
      function Si(t, e, n, r) {
        const i = 1 - r;
        return i * i * t + 2 * r * i * e + r * r * n;
      }
      function wi(t, e, n) {
        const r = t + n - 2 * e;
        if (vi(r, 0)) return [0.5];
        const i = (t - e) / r;
        return i <= 1 && i >= 0 ? [i] : [];
      }
      function Oi(t, e, n, r) {
        return 2 * (1 - r) * (e - t) + 2 * r * (n - e);
      }
      function Ci(t, e, n, r, i, o, a) {
        const s = Si(t, n, i, a);
        const u = Si(e, r, o, a);
        const c = xi.pointAt(t, e, n, r, a);
        const h = xi.pointAt(n, r, i, o, a);
        return [
          [t, e, c.x, c.y, s, u],
          [s, u, h.x, h.y, i, o],
        ];
      }
      const Ei = {
        box(t, e, n, r, i, o) {
          const a = wi(t, n, i)[0];
          const s = wi(e, r, o)[0];
          const u = [t, i];
          const c = [e, o];
          return (
            void 0 !== a && u.push(Si(t, n, i, a)), void 0 !== s && c.push(Si(e, r, o, s)), yi(u, c)
          );
        },
        length(t, e, n, r, i, o) {
          return (function t(e, n, r, i, o, a, s) {
            if (s === 0) return (gi(e, n, r, i) + gi(r, i, o, a) + gi(e, n, o, a)) / 2;
            const u = Ci(e, n, r, i, o, a, 0.5);
            const c = u[0];
            const h = u[1];
            return c.push(s - 1), h.push(s - 1), t.apply(null, c) + t.apply(null, h);
          })(t, e, n, r, i, o, 3);
        },
        nearestPoint(t, e, n, r, i, o, a, s) {
          return Mi([t, n, i], [e, r, o], a, s, Si);
        },
        pointDistance(t, e, n, r, i, o, a, s) {
          const u = this.nearestPoint(t, e, n, r, i, o, a, s);
          return gi(u.x, u.y, a, s);
        },
        interpolationAt: Si,
        pointAt(t, e, n, r, i, o, a) {
          return { x: Si(t, n, i, a), y: Si(e, r, o, a) };
        },
        divide(t, e, n, r, i, o, a) {
          return Ci(t, e, n, r, i, o, a);
        },
        tangentAngle(t, e, n, r, i, o, a) {
          const s = Oi(t, n, i, a);
          const u = Oi(e, r, o, a);
          return bi(Math.atan2(u, s));
        },
      };
      function ki(t, e, n, r, i) {
        const o = 1 - i;
        return o * o * o * t + 3 * e * i * o * o + 3 * n * i * i * o + r * i * i * i;
      }
      function Ti(t, e, n, r, i) {
        const o = 1 - i;
        return 3 * (o * o * (e - t) + 2 * o * i * (n - e) + i * i * (r - n));
      }
      function Pi(t, e, n, r) {
        let i;
        let o;
        let a;
        const s = -3 * t + 9 * e - 9 * n + 3 * r;
        const u = 6 * t - 12 * e + 6 * n;
        const c = 3 * e - 3 * t;
        const h = [];
        if (vi(s, 0)) vi(u, 0) || ((i = -c / u) >= 0 && i <= 1 && h.push(i));
        else {
          const l = u * u - 4 * s * c;
          vi(l, 0)
            ? h.push(-u / (2 * s))
            : l > 0 &&
              ((o = (-u - (a = Math.sqrt(l))) / (2 * s)),
              (i = (-u + a) / (2 * s)) >= 0 && i <= 1 && h.push(i),
              o >= 0 && o <= 1 && h.push(o));
        }
        return h;
      }
      function Ii(t, e, n, r, i, o, a, s, u) {
        const c = ki(t, n, i, a, u);
        const h = ki(e, r, o, s, u);
        const l = xi.pointAt(t, e, n, r, u);
        const f = xi.pointAt(n, r, i, o, u);
        const d = xi.pointAt(i, o, a, s, u);
        const p = xi.pointAt(l.x, l.y, f.x, f.y, u);
        const g = xi.pointAt(f.x, f.y, d.x, d.y, u);
        return [
          [t, e, l.x, l.y, p.x, p.y, c, h],
          [c, h, g.x, g.y, d.x, d.y, a, s],
        ];
      }
      function Ai(t, e, n, r, i, o, a, s, u) {
        if (u === 0)
          return (function (t, e) {
            for (var n = 0, r = t.length, i = 0; i < r; i++) {
              n += gi(t[i], e[i], t[(i + 1) % r], e[(i + 1) % r]);
            }
            return n / 2;
          })([t, n, i, a], [e, r, o, s]);
        const c = Ii(t, e, n, r, i, o, a, s, 0.5);
        const h = c[0];
        const l = c[1];
        return h.push(u - 1), l.push(u - 1), Ai.apply(null, h) + Ai.apply(null, l);
      }
      const ji = {
        extrema: Pi,
        box(t, e, n, r, i, o, a, s) {
          for (
            var u = [t, a], c = [e, s], h = Pi(t, n, i, a), l = Pi(e, r, o, s), f = 0;
            f < h.length;
            f++
          )
            u.push(ki(t, n, i, a, h[f]));
          for (f = 0; f < l.length; f++) c.push(ki(e, r, o, s, l[f]));
          return yi(u, c);
        },
        length(t, e, n, r, i, o, a, s) {
          return Ai(t, e, n, r, i, o, a, s, 3);
        },
        nearestPoint(t, e, n, r, i, o, a, s, u, c, h) {
          return Mi([t, n, i, a], [e, r, o, s], u, c, ki, h);
        },
        pointDistance(t, e, n, r, i, o, a, s, u, c, h) {
          const l = this.nearestPoint(t, e, n, r, i, o, a, s, u, c, h);
          return gi(l.x, l.y, u, c);
        },
        interpolationAt: ki,
        pointAt(t, e, n, r, i, o, a, s, u) {
          return { x: ki(t, n, i, a, u), y: ki(e, r, o, s, u) };
        },
        divide(t, e, n, r, i, o, a, s, u) {
          return Ii(t, e, n, r, i, o, a, s, u);
        },
        tangentAngle(t, e, n, r, i, o, a, s, u) {
          const c = Ti(t, n, i, a, u);
          const h = Ti(e, r, o, s, u);
          return bi(Math.atan2(h, c));
        },
      };
      function Ni(t, e, n, r, i, o) {
        return n * Math.cos(i) * Math.cos(o) - r * Math.sin(i) * Math.sin(o) + t;
      }
      function _i(t, e, n, r, i, o) {
        return n * Math.sin(i) * Math.cos(o) + r * Math.cos(i) * Math.sin(o) + e;
      }
      const Bi = function (t, e, n, r, i, o, a) {
        for (
          var s = (function (t, e, n) {
              return Math.atan((-e / t) * Math.tan(n));
            })(n, r, i),
            u = 1 / 0,
            c = -1 / 0,
            h = [o, a],
            l = 2 * -Math.PI;
          l <= 2 * Math.PI;
          l += Math.PI
        ) {
          const f = s + l;
          o < a ? o < f && f < a && h.push(f) : a < f && f < o && h.push(f);
        }
        for (l = 0; l < h.length; l++) {
          const d = Ni(t, 0, n, r, i, h[l]);
          d < u && (u = d), d > c && (c = d);
        }
        const p = (function (t, e, n) {
          return Math.atan(e / (t * Math.tan(n)));
        })(n, r, i);
        let g = 1 / 0;
        let v = -1 / 0;
        const y = [o, a];
        for (l = 2 * -Math.PI; l <= 2 * Math.PI; l += Math.PI) {
          const m = p + l;
          o < a ? o < m && m < a && y.push(m) : a < m && m < o && y.push(m);
        }
        for (l = 0; l < y.length; l++) {
          const b = _i(0, e, n, r, i, y[l]);
          b < g && (g = b), b > v && (v = b);
        }
        return { x: u, y: g, width: c - u, height: v - g };
      };
      function Li(t) {
        if (t.length < 2) return 0;
        for (var e = 0, n = 0; n < t.length - 1; n++) {
          const r = t[n];
          const i = t[n + 1];
          e += gi(r[0], r[1], i[0], i[1]);
        }
        return e;
      }
      const Di = function (t) {
        return Li(t);
      };
      function Ri(t, e) {
        return t && e
          ? {
              minX: Math.min(t.minX, e.minX),
              minY: Math.min(t.minY, e.minY),
              maxX: Math.max(t.maxX, e.maxX),
              maxY: Math.max(t.maxY, e.maxY),
            }
          : t || e;
      }
      function Yi(t, e) {
        const n = t.get('startArrowShape');
        const r = t.get('endArrowShape');
        return n && (e = Ri(e, n.getCanvasBBox())), r && (e = Ri(e, r.getCanvasBBox())), e;
      }
      let Fi = null;
      function Xi(t, e, n) {
        let r = 1;
        return (
          Object(p.isString)(t) && (r = t.split('\n').length),
          r > 1
            ? e * r +
              (function (t, e) {
                return e ? e - t : 0.14 * t;
              })(e, n) *
                (r - 1)
            : e
        );
      }
      function zi(t, e) {
        const n = (function () {
          if (!Fi) {
            const t = document.createElement('canvas');
            (t.width = 1), (t.height = 1), (Fi = t.getContext('2d'));
          }
          return Fi;
        })();
        let r = 0;
        if (Object(p.isNil)(t) || t === '') return r;
        if ((n.save(), (n.font = e), Object(p.isString)(t) && t.includes('\n'))) {
          const i = t.split('\n');
          Object(p.each)(i, (t) => {
            const e = n.measureText(t).width;
            r < e && (r = e);
          });
        } else r = n.measureText(t).width;
        return n.restore(), r;
      }
      function Wi(t) {
        const e = t.fontSize;
        const n = t.fontFamily;
        const r = t.fontWeight;
        return [t.fontStyle, t.fontVariant, r, `${e}px`, n].join(' ').trim();
      }
      const Gi = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
      const Ui = /[^\s\,]+/gi;
      const Hi = function (t) {
        let e = t || [];
        return ri(e)
          ? e
          : hi(e)
          ? ((e = e.match(Gi)),
            ai(e, (t, n) => {
              if ((t = t.match(Ui))[0].length > 1) {
                const r = t[0].charAt(0);
                t.splice(1, 0, t[0].substr(1)), (t[0] = r);
              }
              ai(t, (e, n) => {
                isNaN(e) || (t[n] = +e);
              }),
                (e[n] = t);
            }),
            e)
          : void 0;
      };
      const qi = new RegExp(
        '([a-z])[\t\n\v\f\r   ᠎             　\u2028\u2029,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\t\n\v\f\r   ᠎             　\u2028\u2029]*,?[\t\n\v\f\r   ᠎             　\u2028\u2029]*)+)',
        'ig',
      );
      const Vi = new RegExp(
        '(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\t\n\v\f\r   ᠎             　\u2028\u2029]*,?[\t\n\v\f\r   ᠎             　\u2028\u2029]*',
        'ig',
      );
      const Zi = /[a-z]/;
      function Ki(t, e) {
        return [e[0] + (e[0] - t[0]), e[1] + (e[1] - t[1])];
      }
      function $i(t) {
        const e = (function (t) {
          if (!t) return null;
          if (ri(t)) return t;
          const e = {
            a: 7,
            c: 6,
            o: 2,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            u: 3,
            z: 0,
          };
          const n = [];
          return (
            String(t).replace(qi, (t, r, i) => {
              const o = [];
              let a = r.toLowerCase();
              if (
                (i.replace(Vi, (t, e) => {
                  e && o.push(+e);
                }),
                a === 'm' &&
                  o.length > 2 &&
                  (n.push([r].concat(o.splice(0, 2))), (a = 'l'), (r = r === 'm' ? 'l' : 'L')),
                a === 'o' && o.length === 1 && n.push([r, o[0]]),
                a === 'r')
              )
                n.push([r].concat(o));
              else for (; o.length >= e[a] && (n.push([r].concat(o.splice(0, e[a]))), e[a]); );
              return '';
            }),
            n
          );
        })(t);
        if (!e || !e.length) return [['M', 0, 0]];
        for (var n = !1, r = 0; r < e.length; r++) {
          var i = e[r][0];
          if (Zi.test(i) || ['V', 'H', 'T', 'S'].indexOf(i) >= 0) {
            n = !0;
            break;
          }
        }
        if (!n) return e;
        const o = [];
        let a = 0;
        let s = 0;
        let u = 0;
        let c = 0;
        let h = 0;
        const l = e[0];
        (l[0] !== 'M' && l[0] !== 'm') ||
          ((u = a = +l[1]), (c = s = +l[2]), h++, (o[0] = ['M', a, s]));
        r = h;
        for (let f = e.length; r < f; r++) {
          const d = e[r];
          const p = o[r - 1];
          let g = [];
          const v = (i = d[0]).toUpperCase();
          if (i !== v)
            switch (((g[0] = v), v)) {
              case 'A':
                (g[1] = d[1]),
                  (g[2] = d[2]),
                  (g[3] = d[3]),
                  (g[4] = d[4]),
                  (g[5] = d[5]),
                  (g[6] = +d[6] + a),
                  (g[7] = +d[7] + s);
                break;
              case 'V':
                g[1] = +d[1] + s;
                break;
              case 'H':
                g[1] = +d[1] + a;
                break;
              case 'M':
                (u = +d[1] + a), (c = +d[2] + s);
                break;
              default:
                for (let y = 1, m = d.length; y < m; y++) g[y] = +d[y] + (y % 2 ? a : s);
            }
          else g = e[r];
          switch (v) {
            case 'Z':
              (a = +u), (s = +c);
              break;
            case 'H':
              g = ['L', (a = g[1]), s];
              break;
            case 'V':
              g = ['L', a, (s = g[1])];
              break;
            case 'T':
              (a = g[1]), (s = g[2]);
              var b = Ki([p[1], p[2]], [p[3], p[4]]);
              g = ['Q', b[0], b[1], a, s];
              break;
            case 'S':
              (a = g[g.length - 2]), (s = g[g.length - 1]);
              var x = p.length;
              var M = Ki([p[x - 4], p[x - 3]], [p[x - 2], p[x - 1]]);
              g = ['C', M[0], M[1], g[1], g[2], a, s];
              break;
            case 'M':
              (u = g[g.length - 2]), (c = g[g.length - 1]);
              break;
            default:
              (a = g[g.length - 2]), (s = g[g.length - 1]);
          }
          o.push(g);
        }
        return o;
      }
      function Qi(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      }
      function Ji(t, e) {
        return Qi(t) * Qi(e) ? (t[0] * e[0] + t[1] * e[1]) / (Qi(t) * Qi(e)) : 1;
      }
      function to(t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(Ji(t, e));
      }
      function eo(t, e) {
        return t[0] === e[0] && t[1] === e[1];
      }
      function no(t, e) {
        let n = e[1];
        let r = e[2];
        const i = fi(pi(e[3]), 2 * Math.PI);
        const o = e[4];
        const a = e[5];
        const s = t[0];
        const u = t[1];
        const c = e[6];
        const h = e[7];
        const l = (Math.cos(i) * (s - c)) / 2 + (Math.sin(i) * (u - h)) / 2;
        const f = (-1 * Math.sin(i) * (s - c)) / 2 + (Math.cos(i) * (u - h)) / 2;
        const d = (l * l) / (n * n) + (f * f) / (r * r);
        d > 1 && ((n *= Math.sqrt(d)), (r *= Math.sqrt(d)));
        const p = n * n * (f * f) + r * r * (l * l);
        let g = p ? Math.sqrt((n * n * (r * r) - p) / p) : 1;
        o === a && (g *= -1), isNaN(g) && (g = 0);
        const v = r ? (g * n * f) / r : 0;
        const y = n ? (g * -r * l) / n : 0;
        const m = (s + c) / 2 + Math.cos(i) * v - Math.sin(i) * y;
        const b = (u + h) / 2 + Math.sin(i) * v + Math.cos(i) * y;
        const x = [(l - v) / n, (f - y) / r];
        const M = [(-1 * l - v) / n, (-1 * f - y) / r];
        const S = to([1, 0], x);
        let w = to(x, M);
        return (
          Ji(x, M) <= -1 && (w = Math.PI),
          Ji(x, M) >= 1 && (w = 0),
          a === 0 && w > 0 && (w -= 2 * Math.PI),
          a === 1 && w < 0 && (w += 2 * Math.PI),
          {
            cx: m,
            cy: b,
            rx: eo(t, [c, h]) ? 0 : n,
            ry: eo(t, [c, h]) ? 0 : r,
            startAngle: S,
            endAngle: S + w,
            xRotation: i,
            arcFlag: o,
            sweepFlag: a,
          }
        );
      }
      function ro(t, e) {
        return [e[0] + (e[0] - t[0]), e[1] + (e[1] - t[1])];
      }
      function io(t) {
        for (
          var e = [], n = null, r = null, i = null, o = 0, a = (t = Hi(t)).length, s = 0;
          s < a;
          s++
        ) {
          const u = t[s];
          r = t[s + 1];
          const c = u[0];
          const h = { command: c, prePoint: n, params: u, startTangent: null, endTangent: null };
          switch (c) {
            case 'M':
              (i = [u[1], u[2]]), (o = s);
              break;
            case 'A':
              var l = no(n, u);
              h.arcParams = l;
          }
          if (c === 'Z') (n = i), (r = t[o + 1]);
          else {
            const f = u.length;
            n = [u[f - 2], u[f - 1]];
          }
          r && r[0] === 'Z' && ((r = t[o]), e[o] && (e[o].prePoint = n)),
            (h.currentPoint = n),
            e[o] && eo(n, e[o].currentPoint) && (e[o].prePoint = h.prePoint);
          const d = r ? [r[r.length - 2], r[r.length - 1]] : null;
          h.nextPoint = d;
          const p = h.prePoint;
          if (['L', 'H', 'V'].includes(c))
            (h.startTangent = [p[0] - n[0], p[1] - n[1]]),
              (h.endTangent = [n[0] - p[0], n[1] - p[1]]);
          else if (c === 'Q') {
            var g = [u[1], u[2]];
            (h.startTangent = [p[0] - g[0], p[1] - g[1]]),
              (h.endTangent = [n[0] - g[0], n[1] - g[1]]);
          } else if (c === 'T') {
            g = ro((m = e[s - 1]).currentPoint, p);
            m.command === 'Q'
              ? ((h.command = 'Q'),
                (h.startTangent = [p[0] - g[0], p[1] - g[1]]),
                (h.endTangent = [n[0] - g[0], n[1] - g[1]]))
              : ((h.command = 'TL'),
                (h.startTangent = [p[0] - n[0], p[1] - n[1]]),
                (h.endTangent = [n[0] - p[0], n[1] - p[1]]));
          } else if (c === 'C') {
            var v = [u[1], u[2]];
            var y = [u[3], u[4]];
            (h.startTangent = [p[0] - v[0], p[1] - v[1]]),
              (h.endTangent = [n[0] - y[0], n[1] - y[1]]);
          } else if (c === 'S') {
            var m;
            (v = ro((m = e[s - 1]).currentPoint, p)), (y = [u[1], u[2]]);
            m.command === 'C'
              ? ((h.command = 'C'),
                (h.startTangent = [p[0] - v[0], p[1] - v[1]]),
                (h.endTangent = [n[0] - y[0], n[1] - y[1]]))
              : ((h.command = 'SQ'),
                (h.startTangent = [p[0] - y[0], p[1] - y[1]]),
                (h.endTangent = [n[0] - y[0], n[1] - y[1]]));
          } else if (c === 'A') {
            let b = 0.001;
            const x = h.arcParams || {};
            const M = x.cx;
            const S = void 0 === M ? 0 : M;
            const w = x.cy;
            const O = void 0 === w ? 0 : w;
            const C = x.rx;
            const E = void 0 === C ? 0 : C;
            const k = x.ry;
            const T = void 0 === k ? 0 : k;
            const P = x.sweepFlag;
            const I = void 0 === P ? 0 : P;
            const A = x.startAngle;
            const j = void 0 === A ? 0 : A;
            const N = x.endAngle;
            const _ = void 0 === N ? 0 : N;
            I === 0 && (b *= -1);
            const B = E * Math.cos(j - b) + S;
            const L = T * Math.sin(j - b) + O;
            h.startTangent = [B - i[0], L - i[1]];
            const D = E * Math.cos(j + _ + b) + S;
            const R = T * Math.sin(j + _ - b) + O;
            h.endTangent = [p[0] - D, p[1] - R];
          }
          e.push(h);
        }
        return e;
      }
      function oo(t, e) {
        const n = t.prePoint;
        const r = t.currentPoint;
        const i = t.nextPoint;
        const o = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2);
        const a = Math.pow(r[0] - i[0], 2) + Math.pow(r[1] - i[1], 2);
        const s = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2);
        const u = Math.acos((o + a - s) / (2 * Math.sqrt(o) * Math.sqrt(a)));
        if (!u || Math.sin(u) === 0 || Object(p.isNumberEqual)(u, 0))
          return { xExtra: 0, yExtra: 0 };
        let c = Math.abs(Math.atan2(i[1] - r[1], i[0] - r[0]));
        let h = Math.abs(Math.atan2(i[0] - r[0], i[1] - r[1]));
        return (
          (c = c > Math.PI / 2 ? Math.PI - c : c),
          (h = h > Math.PI / 2 ? Math.PI - h : h),
          {
            xExtra: Math.cos(u / 2 - c) * ((e / 2) * (1 / Math.sin(u / 2))) - e / 2 || 0,
            yExtra: Math.cos(h - u / 2) * ((e / 2) * (1 / Math.sin(u / 2))) - e / 2 || 0,
          }
        );
      }
      $r('rect', Qr),
        $r('image', Qr),
        $r('circle', Jr),
        $r('marker', Jr),
        $r('polyline', (t) => {
          for (var e = t.attr().points, n = [], r = [], i = 0; i < e.length; i++) {
            const o = e[i];
            n.push(o[0]), r.push(o[1]);
          }
          const a = u.getBBoxByArray(n, r);
          const s = a.x;
          const c = a.y;
          let h = { minX: s, minY: c, maxX: s + a.width, maxY: c + a.height };
          return {
            x: (h = Yi(t, h)).minX,
            y: h.minY,
            width: h.maxX - h.minX,
            height: h.maxY - h.minY,
          };
        }),
        $r('polygon', (t) => {
          for (var e = t.attr().points, n = [], r = [], i = 0; i < e.length; i++) {
            const o = e[i];
            n.push(o[0]), r.push(o[1]);
          }
          return u.getBBoxByArray(n, r);
        }),
        $r('text', (t) => {
          const e = t.attr();
          const n = e.x;
          const r = e.y;
          const i = e.text;
          const o = e.fontSize;
          const a = e.lineHeight;
          let s = e.font;
          s || (s = Wi(e));
          let u;
          const c = zi(i, s);
          if (c) {
            const h = e.textAlign;
            const l = e.textBaseline;
            const f = Xi(i, o, a);
            const d = { x: n, y: r - f };
            h && (h === 'end' || h === 'right' ? (d.x -= c) : h === 'center' && (d.x -= c / 2)),
              l && (l === 'top' ? (d.y += f) : l === 'middle' && (d.y += f / 2)),
              (u = { x: d.x, y: d.y, width: c, height: f });
          } else u = { x: n, y: r, width: 0, height: 0 };
          return u;
        }),
        $r('path', (t) => {
          const e = t.attr();
          const n = e.path;
          const r = e.stroke ? e.lineWidth : 0;
          const i = (function (t, e) {
            for (var n = [], r = [], i = [], o = 0; o < t.length; o++) {
              var a = (v = t[o]).currentPoint;
              const s = v.params;
              const u = v.prePoint;
              let c = void 0;
              switch (v.command) {
                case 'Q':
                  c = Ei.box(u[0], u[1], s[1], s[2], s[3], s[4]);
                  break;
                case 'C':
                  c = ji.box(u[0], u[1], s[1], s[2], s[3], s[4], s[5], s[6]);
                  break;
                case 'A':
                  var h = v.arcParams;
                  c = Bi(h.cx, h.cy, h.rx, h.ry, h.xRotation, h.startAngle, h.endAngle);
                  break;
                default:
                  n.push(a[0]), r.push(a[1]);
              }
              c && ((v.box = c), n.push(c.x, c.x + c.width), r.push(c.y, c.y + c.height)),
                e &&
                  (v.command === 'L' || v.command === 'M') &&
                  v.prePoint &&
                  v.nextPoint &&
                  i.push(v);
            }
            (n = n.filter((t) => {
              return !Number.isNaN(t);
            })),
              (r = r.filter((t) => {
                return !Number.isNaN(t);
              }));
            let l = Object(p.min)(n);
            let f = Object(p.min)(r);
            let d = Object(p.max)(n);
            let g = Object(p.max)(r);
            if (i.length === 0) return { x: l, y: f, width: d - l, height: g - f };
            for (o = 0; o < i.length; o++) {
              var v;
              (a = (v = i[o]).currentPoint)[0] === l
                ? (l -= oo(v, e).xExtra)
                : a[0] === d && (d += oo(v, e).xExtra),
                a[1] === f ? (f -= oo(v, e).yExtra) : a[1] === g && (g += oo(v, e).yExtra);
            }
            return { x: l, y: f, width: d - l, height: g - f };
          })(t.get('segments') || io(n), r);
          const o = i.x;
          const a = i.y;
          let s = { minX: o, minY: a, maxX: o + i.width, maxY: a + i.height };
          return {
            x: (s = Yi(t, s)).minX,
            y: s.minY,
            width: s.maxX - s.minX,
            height: s.maxY - s.minY,
          };
        }),
        $r('line', (t) => {
          const e = t.attr();
          const n = e.x1;
          const r = e.y1;
          const i = e.x2;
          const o = e.y2;
          let a = {
            minX: Math.min(n, i),
            maxX: Math.max(n, i),
            minY: Math.min(r, o),
            maxY: Math.max(r, o),
          };
          return {
            x: (a = Yi(t, a)).minX,
            y: a.minY,
            width: a.maxX - a.minX,
            height: a.maxY - a.minY,
          };
        }),
        $r('ellipse', (t) => {
          const e = t.attr();
          const n = e.x;
          const r = e.y;
          const i = e.rx;
          const o = e.ry;
          return { x: n - i, y: r - o, width: 2 * i, height: 2 * o };
        });
      const ao = {}.toString;
      const so = function (t, e) {
        return ao.call(t) === `[object ${e}]`;
      };
      const uo = function (t) {
        return so(t, 'Function');
      };
      const co = function (t) {
        return t == null;
      };
      const ho = function (t) {
        return Array.isArray ? Array.isArray(t) : so(t, 'Array');
      };
      function lo(t) {
        return (lo =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const fo = function (t) {
        const e = lo(t);
        return (t !== null && e === 'object') || e === 'function';
      };
      const po = function (t, e) {
        if (t)
          if (ho(t)) for (let n = 0, r = t.length; n < r && !1 !== e(t[n], n); n++);
          else if (fo(t)) for (const i in t) if (t.hasOwnProperty(i) && !1 === e(t[i], i)) break;
      };
      Object.keys;
      const go = Array.prototype;
      const vo =
        (go.splice,
        go.indexOf,
        Array.prototype.splice,
        function (t) {
          return so(t, 'String');
        });
      Object.prototype.hasOwnProperty;
      const yo = function (t) {
        return so(t, 'Number');
      };
      Number.isInteger && Number.isInteger;
      const mo = function (t, e) {
        return ((t % e) + e) % e;
      };
      const bo = (Math.PI, parseInt, Math.PI / 180);
      const xo = function (t) {
        return bo * t;
      };
      Object.values;
      Object.prototype;
      Object.prototype.hasOwnProperty;
      Object.prototype.hasOwnProperty;
      !(function () {
        function t() {
          this.map = {};
        }
        (t.prototype.has = function (t) {
          return void 0 !== this.map[t];
        }),
          (t.prototype.get = function (t, e) {
            const n = this.map[t];
            return void 0 === n ? e : n;
          }),
          (t.prototype.set = function (t, e) {
            this.map[t] = e;
          }),
          (t.prototype.clear = function () {
            this.map = {};
          }),
          (t.prototype.delete = function (t) {
            delete this.map[t];
          }),
          (t.prototype.size = function () {
            return Object.keys(this.map).length;
          });
      })();
      const Mo = {};
      function So(t) {
        return (Mo == null ? void 0 : Mo.clearAnimationFrame)
          ? Mo.clearAnimationFrame(t)
          : (typeof window === 'object' && window.cancelAnimationFrame
              ? window.cancelAnimationFrame
              : clearTimeout)(t);
      }
      function wo(t, e, n, r) {
        const i = t - n;
        const o = e - r;
        return Math.sqrt(i * i + o * o);
      }
      function Oo(t, e, n, r, i, o) {
        return i >= t && i <= t + n && o >= e && o <= e + r;
      }
      function Co(t, e) {
        return !(e.minX > t.maxX || e.maxX < t.minX || e.minY > t.maxY || e.maxY < t.minY);
      }
      function Eo(t, e) {
        return t[0] === e[0] && t[1] === e[1];
      }
      const ko = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
      const To = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
      const Po = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
      const Io = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
      function Ao(t, e) {
        const n = t.match(Io);
        po(n, (t) => {
          const n = t.split(':');
          e.addColorStop(n[0], n[1]);
        });
      }
      function jo(t, e, n) {
        if (vo(n)) {
          if (n[1] === '(' || n[2] === '(') {
            if (n[0] === 'l')
              return (function (t, e, n) {
                let r;
                let i;
                const o = ko.exec(n);
                const a = (parseFloat(o[1]) % 360) * (Math.PI / 180);
                const s = o[2];
                const u = e.getBBox();
                a >= 0 && a < 0.5 * Math.PI
                  ? ((r = { x: u.minX, y: u.minY }), (i = { x: u.maxX, y: u.maxY }))
                  : 0.5 * Math.PI <= a && a < Math.PI
                  ? ((r = { x: u.maxX, y: u.minY }), (i = { x: u.minX, y: u.maxY }))
                  : Math.PI <= a && a < 1.5 * Math.PI
                  ? ((r = { x: u.maxX, y: u.maxY }), (i = { x: u.minX, y: u.minY }))
                  : ((r = { x: u.minX, y: u.maxY }), (i = { x: u.maxX, y: u.minY }));
                const c = Math.tan(a);
                const h = c * c;
                const l = (i.x - r.x + c * (i.y - r.y)) / (h + 1) + r.x;
                const f = (c * (i.x - r.x + c * (i.y - r.y))) / (h + 1) + r.y;
                const d = t.createLinearGradient(r.x, r.y, l, f);
                return Ao(s, d), d;
              })(t, e, n);
            if (n[0] === 'r')
              return (function (t, e, n) {
                const r = To.exec(n);
                const i = parseFloat(r[1]);
                const o = parseFloat(r[2]);
                const a = parseFloat(r[3]);
                const s = r[4];
                if (a === 0) {
                  const u = s.match(Io);
                  return u[u.length - 1].split(':')[1];
                }
                const c = e.getBBox();
                const h = c.maxX - c.minX;
                const l = c.maxY - c.minY;
                const f = Math.sqrt(h * h + l * l) / 2;
                const d = t.createRadialGradient(
                  c.minX + h * i,
                  c.minY + l * o,
                  0,
                  c.minX + h / 2,
                  c.minY + l / 2,
                  a * f,
                );
                return Ao(s, d), d;
              })(t, e, n);
            if (n[0] === 'p')
              return (function (t, e, n) {
                if (e.get('patternSource') && e.get('patternSource') === n) return e.get('pattern');
                let r;
                let i;
                const o = Po.exec(n);
                let a = o[1];
                const s = o[2];
                function u() {
                  (r = t.createPattern(i, a)), e.set('pattern', r), e.set('patternSource', n);
                }
                switch (a) {
                  case 'a':
                    a = 'repeat';
                    break;
                  case 'x':
                    a = 'repeat-x';
                    break;
                  case 'y':
                    a = 'repeat-y';
                    break;
                  case 'n':
                    a = 'no-repeat';
                    break;
                  default:
                    a = 'no-repeat';
                }
                return (
                  (i = new Image()),
                  s.match(/^data:/i) || (i.crossOrigin = 'Anonymous'),
                  (i.src = s),
                  i.complete ? u() : ((i.onload = u), (i.src = i.src)),
                  r
                );
              })(t, e, n);
          }
          return n;
        }
      }
      function No(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      }
      function _o(t, e) {
        return No(t) * No(e) ? (t[0] * e[0] + t[1] * e[1]) / (No(t) * No(e)) : 1;
      }
      function Bo(t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(_o(t, e));
      }
      function Lo(t, e) {
        let n = e[1];
        let r = e[2];
        const i = mo(xo(e[3]), 2 * Math.PI);
        const o = e[4];
        const a = e[5];
        const s = t[0];
        const u = t[1];
        const c = e[6];
        const h = e[7];
        const l = (Math.cos(i) * (s - c)) / 2 + (Math.sin(i) * (u - h)) / 2;
        const f = (-1 * Math.sin(i) * (s - c)) / 2 + (Math.cos(i) * (u - h)) / 2;
        const d = (l * l) / (n * n) + (f * f) / (r * r);
        d > 1 && ((n *= Math.sqrt(d)), (r *= Math.sqrt(d)));
        const p = n * n * (f * f) + r * r * (l * l);
        let g = p ? Math.sqrt((n * n * (r * r) - p) / p) : 1;
        o === a && (g *= -1), isNaN(g) && (g = 0);
        const v = r ? (g * n * f) / r : 0;
        const y = n ? (g * -r * l) / n : 0;
        const m = (s + c) / 2 + Math.cos(i) * v - Math.sin(i) * y;
        const b = (u + h) / 2 + Math.sin(i) * v + Math.cos(i) * y;
        const x = [(l - v) / n, (f - y) / r];
        const M = [(-1 * l - v) / n, (-1 * f - y) / r];
        const S = Bo([1, 0], x);
        let w = Bo(x, M);
        return (
          _o(x, M) <= -1 && (w = Math.PI),
          _o(x, M) >= 1 && (w = 0),
          a === 0 && w > 0 && (w -= 2 * Math.PI),
          a === 1 && w < 0 && (w += 2 * Math.PI),
          {
            cx: m,
            cy: b,
            rx: Eo(t, [c, h]) ? 0 : n,
            ry: Eo(t, [c, h]) ? 0 : r,
            startAngle: S,
            endAngle: S + w,
            xRotation: i,
            arcFlag: o,
            sweepFlag: a,
          }
        );
      }
      const Do = Math.sin;
      const Ro = Math.cos;
      const Yo = Math.atan2;
      const Fo = Math.PI;
      function Xo(t, e, n, r, i, o, a) {
        const s = e.stroke;
        const u = e.lineWidth;
        const c = Yo(r - o, n - i);
        const h = new Ma({
          type: 'path',
          canvas: t.get('canvas'),
          isArrowShape: !0,
          attrs: {
            path: `M${10 * Ro(Fo / 6)},${10 * Do(Fo / 6)} L0,0 L${10 * Ro(Fo / 6)},-${
              10 * Do(Fo / 6)
            }`,
            stroke: s,
            lineWidth: u,
          },
        });
        h.translate(i, o),
          h.rotateAtPoint(i, o, c),
          t.set(a ? 'startArrowShape' : 'endArrowShape', h);
      }
      function zo(t, e, n, r, i, o, a) {
        const s = e.startArrow;
        const u = e.endArrow;
        const c = e.stroke;
        const h = e.lineWidth;
        const l = a ? s : u;
        const f = l.d;
        const p = l.fill;
        const g = l.stroke;
        const v = l.lineWidth;
        const y = (function (t, e) {
          const n = {};
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
          if (t != null && typeof Object.getOwnPropertySymbols === 'function') {
            let i = 0;
            for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
              e.indexOf(r[i]) < 0 &&
                Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
                (n[r[i]] = t[r[i]]);
          }
          return n;
        })(l, ['d', 'fill', 'stroke', 'lineWidth']);
        const m = Yo(r - o, n - i);
        f && ((i -= Ro(m) * f), (o -= Do(m) * f));
        const b = new Ma({
          type: 'path',
          canvas: t.get('canvas'),
          isArrowShape: !0,
          attrs: d(d({}, y), { stroke: g || c, lineWidth: v || h, fill: p }),
        });
        b.translate(i, o),
          b.rotateAtPoint(i, o, m),
          t.set(a ? 'startArrowShape' : 'endArrowShape', b);
      }
      function Wo(t, e, n, r, i) {
        const o = Yo(r - e, n - t);
        return { dx: Ro(o) * i, dy: Do(o) * i };
      }
      function Go(t, e, n, r, i, o) {
        typeof e.startArrow === 'object'
          ? zo(t, e, n, r, i, o, !0)
          : e.startArrow
          ? Xo(t, e, n, r, i, o, !0)
          : t.set('startArrowShape', null);
      }
      function Uo(t, e, n, r, i, o) {
        typeof e.endArrow === 'object'
          ? zo(t, e, n, r, i, o, !1)
          : e.endArrow
          ? Xo(t, e, n, r, i, o, !1)
          : t.set('startArrowShape', null);
      }
      const Ho = { fill: 'fillStyle', stroke: 'strokeStyle', opacity: 'globalAlpha' };
      function qo(t, e) {
        const n = e.attr();
        for (const r in n) {
          let i = n[r];
          const o = Ho[r] ? Ho[r] : r;
          o === 'matrix' && i
            ? t.transform(i[0], i[1], i[3], i[4], i[6], i[7])
            : o === 'lineDash' && t.setLineDash
            ? ho(i) && t.setLineDash(i)
            : (o === 'strokeStyle' || o === 'fillStyle'
                ? (i = jo(t, e, i))
                : o === 'globalAlpha' && (i *= t.globalAlpha),
              (t[o] = i));
        }
      }
      function Vo(t, e, n) {
        for (let r = 0; r < e.length; r++) {
          const i = e[r];
          i.cfg.visible ? i.draw(t, n) : i.skipDraw();
        }
      }
      function Zo(t, e, n) {
        const r = t.get('refreshElements');
        po(r, (e) => {
          if (e !== t)
            for (let n = e.cfg.parent; n && n !== t && !n.cfg.refresh; )
              (n.cfg.refresh = !0), (n = n.cfg.parent);
        }),
          r[0] === t
            ? Ko(e, n)
            : (function t(e, n) {
                for (let r = 0; r < e.length; r++) {
                  const i = e[r];
                  if (i.cfg.visible)
                    if (i.cfg.hasChanged)
                      (i.cfg.refresh = !0), i.isGroup() && Ko(i.cfg.children, n);
                    else if (i.cfg.refresh) i.isGroup() && t(i.cfg.children, n);
                    else {
                      const o = $o(i, n);
                      (i.cfg.refresh = o), o && i.isGroup() && t(i.cfg.children, n);
                    }
                }
              })(e, n);
      }
      function Ko(t, e) {
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          (r.cfg.refresh = !0), r.isGroup() && Ko(r.get('children'), e);
        }
      }
      function $o(t, e) {
        const n = t.cfg.cacheCanvasBBox;
        return t.cfg.isInView && n && Co(n, e);
      }
      function Qo(t, e, n, r) {
        const i = n.path;
        const o = n.startArrow;
        const a = n.endArrow;
        if (i) {
          let s = [0, 0];
          let u = [0, 0];
          let c = { dx: 0, dy: 0 };
          e.beginPath();
          for (let h = 0; h < i.length; h++) {
            const l = i[h];
            const f = l[0];
            if (h === 0 && o && o.d)
              c = Wo((d = t.getStartTangent())[0][0], d[0][1], d[1][0], d[1][1], o.d);
            else if (h === i.length - 2 && i[h + 1][0] === 'Z' && a && a.d) {
              if (i[h + 1][0] === 'Z')
                c = Wo((d = t.getEndTangent())[0][0], d[0][1], d[1][0], d[1][1], a.d);
            } else if (h === i.length - 1 && a && a.d) {
              var d;
              if (i[0] !== 'Z')
                c = Wo((d = t.getEndTangent())[0][0], d[0][1], d[1][0], d[1][1], a.d);
            }
            const p = c.dx;
            const g = c.dy;
            switch (f) {
              case 'M':
                e.moveTo(l[1] - p, l[2] - g), (u = [l[1], l[2]]);
                break;
              case 'L':
                e.lineTo(l[1] - p, l[2] - g);
                break;
              case 'Q':
                e.quadraticCurveTo(l[1], l[2], l[3] - p, l[4] - g);
                break;
              case 'C':
                e.bezierCurveTo(l[1], l[2], l[3], l[4], l[5] - p, l[6] - g);
                break;
              case 'A':
                var v = void 0;
                r ? (v = r[h]) || ((v = Lo(s, l)), (r[h] = v)) : (v = Lo(s, l));
                var y = v.cx;
                var m = v.cy;
                var b = v.rx;
                var x = v.ry;
                var M = v.startAngle;
                var S = v.endAngle;
                var w = v.xRotation;
                var O = v.sweepFlag;
                if (e.ellipse) e.ellipse(y, m, b, x, w, M, S, 1 - O);
                else {
                  const C = b > x ? b : x;
                  const E = b > x ? 1 : b / x;
                  const k = b > x ? x / b : 1;
                  e.translate(y, m),
                    e.rotate(w),
                    e.scale(E, k),
                    e.arc(0, 0, C, M, S, 1 - O),
                    e.scale(1 / E, 1 / k),
                    e.rotate(-w),
                    e.translate(-y, -m);
                }
                break;
              case 'Z':
                e.closePath();
            }
            if (f === 'Z') s = u;
            else {
              const T = l.length;
              s = [l[T - 2], l[T - 1]];
            }
          }
        }
      }
      function Jo(t, e) {
        const n = t.get('canvas');
        n &&
          (e === 'remove' && (t._cacheCanvasBBox = t.get('cacheCanvasBBox')),
          t.get('hasChanged') ||
            (t.set('hasChanged', !0),
            (t.cfg.parent && t.cfg.parent.get('hasChanged')) ||
              (n.refreshElement(t, e, n), n.get('autoDraw') && n.draw())));
      }
      function ta(t) {
        let e;
        let n;
        let r;
        if (t.destroyed) e = t._cacheCanvasBBox;
        else {
          const i = t.get('cacheCanvasBBox');
          const o = i && !(!i.width || !i.height);
          const a = t.getCanvasBBox();
          const s = a && !(!a.width || !a.height);
          o && s
            ? ((r = a),
              (e =
                (n = i) && r
                  ? {
                      minX: Math.min(n.minX, r.minX),
                      minY: Math.min(n.minY, r.minY),
                      maxX: Math.max(n.maxX, r.maxX),
                      maxY: Math.max(n.maxY, r.maxY),
                    }
                  : n || r))
            : o
            ? (e = i)
            : s && (e = a);
        }
        return e;
      }
      const ea = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.onCanvasChange = function (t) {
            Jo(this, t);
          }),
          (e.prototype.getShapeBase = function () {
            return c;
          }),
          (e.prototype.getGroupBase = function () {
            return e;
          }),
          (e.prototype._applyClip = function (t, e) {
            e && (t.save(), qo(t, e), e.createPath(t), t.restore(), t.clip(), e._afterDraw());
          }),
          (e.prototype.cacheCanvasBBox = function () {
            const t = this.cfg.children;
            const e = [];
            const n = [];
            po(t, (t) => {
              const r = t.cfg.cacheCanvasBBox;
              r && t.cfg.isInView && (e.push(r.minX, r.maxX), n.push(r.minY, r.maxY));
            });
            let r = null;
            if (e.length) {
              const i = Math.min.apply(null, e);
              const o = Math.max.apply(null, e);
              const a = Math.min.apply(null, n);
              const s = Math.max.apply(null, n);
              r = { minX: i, minY: a, x: i, y: a, maxX: o, maxY: s, width: o - i, height: s - a };
              const u = this.cfg.canvas;
              if (u) {
                const c = u.getViewRange();
                this.set('isInView', Co(r, c));
              }
            } else this.set('isInView', !1);
            this.set('cacheCanvasBBox', r);
          }),
          (e.prototype.draw = function (t, e) {
            const n = this.cfg.children;
            const r = !e || this.cfg.refresh;
            n.length &&
              r &&
              (t.save(),
              qo(t, this),
              this._applyClip(t, this.getClip()),
              Vo(t, n, e),
              t.restore(),
              this.cacheCanvasBBox()),
              (this.cfg.refresh = null),
              this.set('hasChanged', !1);
          }),
          (e.prototype.skipDraw = function () {
            this.set('cacheCanvasBBox', null), this.set('hasChanged', !1);
          }),
          e
        );
      })(Vr);
      var na = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), {
              lineWidth: 1,
              lineAppendWidth: 0,
              strokeOpacity: 1,
              fillOpacity: 1,
            });
          }),
          (e.prototype.getShapeBase = function () {
            return c;
          }),
          (e.prototype.getGroupBase = function () {
            return ea;
          }),
          (e.prototype.onCanvasChange = function (t) {
            Jo(this, t);
          }),
          (e.prototype.calculateBBox = function () {
            const t = this.get('type');
            const e = this.getHitLineWidth();
            const n = (function (t) {
              return Kr.get(t);
            })(t)(this);
            const r = e / 2;
            const i = n.x - r;
            const o = n.y - r;
            const a = n.x + n.width + r;
            const s = n.y + n.height + r;
            return {
              x: i,
              minX: i,
              y: o,
              minY: o,
              width: n.width + e,
              height: n.height + e,
              maxX: a,
              maxY: s,
            };
          }),
          (e.prototype.isFill = function () {
            return !!this.attrs.fill || this.isClipShape();
          }),
          (e.prototype.isStroke = function () {
            return !!this.attrs.stroke;
          }),
          (e.prototype._applyClip = function (t, e) {
            e && (t.save(), qo(t, e), e.createPath(t), t.restore(), t.clip(), e._afterDraw());
          }),
          (e.prototype.draw = function (t, e) {
            const n = this.cfg.clipShape;
            if (e) {
              if (!1 === this.cfg.refresh) return void this.set('hasChanged', !1);
              if (!Co(e, this.getCanvasBBox()))
                return this.set('hasChanged', !1), void (this.cfg.isInView && this._afterDraw());
            }
            t.save(),
              qo(t, this),
              this._applyClip(t, n),
              this.drawPath(t),
              t.restore(),
              this._afterDraw();
          }),
          (e.prototype.getCanvasViewBox = function () {
            const t = this.cfg.canvas;
            return t ? t.getViewRange() : null;
          }),
          (e.prototype.cacheCanvasBBox = function () {
            const t = this.getCanvasViewBox();
            if (t) {
              const e = this.getCanvasBBox();
              const n = Co(e, t);
              this.set('isInView', n),
                n ? this.set('cacheCanvasBBox', e) : this.set('cacheCanvasBBox', null);
            }
          }),
          (e.prototype._afterDraw = function () {
            this.cacheCanvasBBox(), this.set('hasChanged', !1), this.set('refresh', null);
          }),
          (e.prototype.skipDraw = function () {
            this.set('cacheCanvasBBox', null),
              this.set('isInView', null),
              this.set('hasChanged', !1);
          }),
          (e.prototype.drawPath = function (t) {
            this.createPath(t), this.strokeAndFill(t), this.afterDrawPath(t);
          }),
          (e.prototype.fill = function (t) {
            t.fill();
          }),
          (e.prototype.stroke = function (t) {
            t.stroke();
          }),
          (e.prototype.strokeAndFill = function (t) {
            const e = this.attrs;
            const n = e.lineWidth;
            const r = e.opacity;
            const i = e.strokeOpacity;
            const o = e.fillOpacity;
            this.isFill() &&
              (co(o) || o === 1
                ? this.fill(t)
                : ((t.globalAlpha = o), this.fill(t), (t.globalAlpha = r))),
              this.isStroke() && n > 0 && (co(i) || i === 1 || (t.globalAlpha = i), this.stroke(t)),
              this.afterDrawPath(t);
          }),
          (e.prototype.createPath = function (t) {}),
          (e.prototype.afterDrawPath = function (t) {}),
          (e.prototype.isInShape = function (t, e) {
            const n = this.isStroke();
            const r = this.isFill();
            const i = this.getHitLineWidth();
            return this.isInStrokeOrPath(t, e, n, r, i);
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            return !1;
          }),
          (e.prototype.getHitLineWidth = function () {
            if (!this.isStroke()) return 0;
            const t = this.attrs;
            return t.lineWidth + t.lineAppendWidth;
          }),
          e
        );
      })(Zr);
      var ra = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { x: 0, y: 0, r: 0 });
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            const o = this.attr();
            const a = o.x;
            const s = o.y;
            const u = o.r;
            const c = i / 2;
            const h = wo(a, s, t, e);
            return r && n ? h <= u + c : r ? h <= u : !!n && h >= u - c && h <= u + c;
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.x;
            const r = e.y;
            const i = e.r;
            t.beginPath(), t.arc(n, r, i, 0, 2 * Math.PI, !1), t.closePath();
          }),
          e
        );
      })(na);
      function ia(t, e, n, r) {
        return t / (n * n) + e / (r * r);
      }
      var oa = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { x: 0, y: 0, rx: 0, ry: 0 });
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            const o = this.attr();
            const a = i / 2;
            const s = o.x;
            const u = o.y;
            const c = o.rx;
            const h = o.ry;
            const l = (t - s) * (t - s);
            const f = (e - u) * (e - u);
            return r && n
              ? ia(l, f, c + a, h + a) <= 1
              : r
              ? ia(l, f, c, h) <= 1
              : !!n && ia(l, f, c - a, h - a) >= 1 && ia(l, f, c + a, h + a) <= 1;
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.x;
            const r = e.y;
            const i = e.rx;
            const o = e.ry;
            if ((t.beginPath(), t.ellipse)) t.ellipse(n, r, i, o, 0, 0, 2 * Math.PI, !1);
            else {
              const a = i > o ? i : o;
              const s = i > o ? 1 : i / o;
              const u = i > o ? o / i : 1;
              t.save(),
                t.translate(n, r),
                t.scale(s, u),
                t.arc(0, 0, a, 0, 2 * Math.PI),
                t.restore(),
                t.closePath();
            }
          }),
          e
        );
      })(na);
      function aa(t) {
        return t instanceof HTMLElement && vo(t.nodeName) && t.nodeName.toUpperCase() === 'CANVAS';
      }
      let sa = null;
      var ua = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { x: 0, y: 0, width: 0, height: 0 });
          }),
          (e.prototype.initAttrs = function (t) {
            this._setImage(t.img);
          }),
          (e.prototype.isStroke = function () {
            return !1;
          }),
          (e.prototype.isOnlyHitBox = function () {
            return !0;
          }),
          (e.prototype._afterLoading = function () {
            if (!0 === this.get('toDraw')) {
              const t = this.get('canvas');
              t ? t.draw() : this.createPath(this.get('context'));
            }
          }),
          (e.prototype._setImage = function (t) {
            const e = this;
            const n = this.attrs;
            if (!(sa == null ? void 0 : sa.isMini()) || (sa == null ? void 0 : sa.isMiniNative()))
              if (vo(t)) {
                let r = null;
                ((r = (sa == null ? void 0 : sa.isMiniNative())
                  ? sa == null
                    ? void 0
                    : sa.get('container').createImage()
                  : new Image()).onload = function () {
                  if (e.destroyed) return !1;
                  e.attr('img', r), e.set('loading', !1), e._afterLoading();
                  const t = e.get('callback');
                  t && t.call(e);
                }),
                  (r.crossOrigin = 'Anonymous'),
                  (r.src = t),
                  this.set('loading', !0);
              } else
                (sa == null ? void 0 : sa.isMiniNative()) || t instanceof Image
                  ? (n.width || (n.width = t.width), n.height || (n.height = t.height))
                  : aa(t) &&
                    (n.width || (n.width = Number(t.getAttribute('width'))),
                    n.height || (n.height, Number(t.getAttribute('height'))));
            else this.attr('img', t);
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r), e === 'img' && this._setImage(n);
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.img;
            const r = e.x;
            const i = e.y;
            const o = e.width;
            const a = e.height;
            const s = e.sx;
            const u = e.sy;
            const c = e.swidth;
            const h = e.sheight;
            if (this.get('loading')) return this.set('toDraw', !0), void this.set('context', t);
            (sa == null ? void 0 : sa.isMini())
              ? t.drawImage(n, r, i, o, a)
              : (n instanceof Image || aa(n)) &&
                (co(s) || co(u) || co(c) || co(h)
                  ? t.drawImage(n, r, i, o, a)
                  : t.drawImage(n, s, u, c, h, r, i, o, a));
          }),
          e
        );
      })(na);
      function ca(t, e, n, r, i, o, a) {
        const s = Math.min(t, n);
        const u = Math.max(t, n);
        const c = Math.min(e, r);
        const h = Math.max(e, r);
        const l = i / 2;
        return (
          o >= s - l &&
          o <= u + l &&
          a >= c - l &&
          a <= h + l &&
          xi.pointToLine(t, e, n, r, o, a) <= i / 2
        );
      }
      var ha = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: !1, endArrow: !1 });
          }),
          (e.prototype.initAttrs = function (t) {
            this.setArrow();
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r), this.setArrow();
          }),
          (e.prototype.setArrow = function () {
            const t = this.attr();
            const e = t.x1;
            const n = t.y1;
            const r = t.x2;
            const i = t.y2;
            const o = t.startArrow;
            const a = t.endArrow;
            o && Go(this, t, r, i, e, n), a && Uo(this, t, e, n, r, i);
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            if (!n || !i) return !1;
            const o = this.attr();
            return ca(o.x1, o.y1, o.x2, o.y2, i, t, e);
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.x1;
            const r = e.y1;
            const i = e.x2;
            const o = e.y2;
            const a = e.startArrow;
            const s = e.endArrow;
            let u = { dx: 0, dy: 0 };
            let c = { dx: 0, dy: 0 };
            a && a.d && (u = Wo(n, r, i, o, e.startArrow.d)),
              s && s.d && (c = Wo(n, r, i, o, e.endArrow.d)),
              t.beginPath(),
              t.moveTo(n + u.dx, r + u.dy),
              t.lineTo(i - c.dx, o - c.dy);
          }),
          (e.prototype.afterDrawPath = function (t) {
            const e = this.get('startArrowShape');
            const n = this.get('endArrowShape');
            e && e.draw(t), n && n.draw(t);
          }),
          (e.prototype.getTotalLength = function () {
            const t = this.attr();
            const e = t.x1;
            const n = t.y1;
            const r = t.x2;
            const i = t.y2;
            return xi.length(e, n, r, i);
          }),
          (e.prototype.getPoint = function (t) {
            const e = this.attr();
            const n = e.x1;
            const r = e.y1;
            const i = e.x2;
            const o = e.y2;
            return xi.pointAt(n, r, i, o, t);
          }),
          e
        );
      })(na);
      const la = {
        circle(t, e, n) {
          return [
            ['M', t - n, e],
            ['A', n, n, 0, 1, 0, t + n, e],
            ['A', n, n, 0, 1, 0, t - n, e],
          ];
        },
        square(t, e, n) {
          return [
            ['M', t - n, e - n],
            ['L', t + n, e - n],
            ['L', t + n, e + n],
            ['L', t - n, e + n],
            ['Z'],
          ];
        },
        diamond(t, e, n) {
          return [['M', t - n, e], ['L', t, e - n], ['L', t + n, e], ['L', t, e + n], ['Z']];
        },
        triangle(t, e, n) {
          const r = n * Math.sin((1 / 3) * Math.PI);
          return [['M', t - n, e + r], ['L', t, e - r], ['L', t + n, e + r], ['Z']];
        },
        'triangle-down': function (t, e, n) {
          const r = n * Math.sin((1 / 3) * Math.PI);
          return [['M', t - n, e - r], ['L', t + n, e - r], ['L', t, e + r], ['Z']];
        },
      };
      var fa = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.initAttrs = function (t) {
            this._resetParamsCache();
          }),
          (e.prototype._resetParamsCache = function () {
            this.set('paramsCache', {});
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r),
              ['symbol', 'x', 'y', 'r', 'radius'].indexOf(e) !== -1 && this._resetParamsCache();
          }),
          (e.prototype.isOnlyHitBox = function () {
            return !0;
          }),
          (e.prototype._getR = function (t) {
            return co(t.r) ? t.radius : t.r;
          }),
          (e.prototype._getPath = function () {
            let t;
            let n;
            const r = this.attr();
            const i = r.x;
            const o = r.y;
            const a = r.symbol || 'circle';
            const s = this._getR(r);
            if (uo(a)) n = $i((n = (t = a)(i, o, s)));
            else {
              if (!(t = e.Symbols[a])) return console.warn(`${a} marker is not supported.`), null;
              n = t(i, o, s);
            }
            return n;
          }),
          (e.prototype.createPath = function (t) {
            Qo(this, t, { path: this._getPath() }, this.get('paramsCache'));
          }),
          (e.Symbols = la),
          e
        );
      })(na);
      function da(t) {
        return Math.abs(t) < 1e-6 ? 0 : t < 0 ? -1 : 1;
      }
      function pa(t, e, n) {
        return (
          (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]) &&
          Math.min(t[0], e[0]) <= n[0] &&
          n[0] <= Math.max(t[0], e[0]) &&
          Math.min(t[1], e[1]) <= n[1] &&
          n[1] <= Math.max(t[1], e[1])
        );
      }
      function ga(t, e, n) {
        let r = !1;
        const i = t.length;
        if (i <= 2) return !1;
        for (let o = 0; o < i; o++) {
          const a = t[o];
          const s = t[(o + 1) % i];
          if (pa(a, s, [e, n])) return !0;
          da(a[1] - n) > 0 != da(s[1] - n) > 0 &&
            da(e - ((n - a[1]) * (a[0] - s[0])) / (a[1] - s[1]) - a[0]) < 0 &&
            (r = !r);
        }
        return r;
      }
      function va(t, e, n) {
        const r = e[0];
        const i = e[1];
        const o = e[2];
        return (
          (t[0] = r * n[0] + i * n[3] + o * n[6]),
          (t[1] = r * n[1] + i * n[4] + o * n[7]),
          (t[2] = r * n[2] + i * n[5] + o * n[8]),
          t
        );
      }
      !(function () {
        let t;
        const e = ((t = new nt(3)), nt != Float32Array && ((t[0] = 0), (t[1] = 0), (t[2] = 0)), t);
      })();
      function ya(t, e, n, r, i, o, a, s) {
        const u = (Math.atan2(s - e, a - t) + 2 * Math.PI) % (2 * Math.PI);
        if (u < r || u > i) return !1;
        const c = { x: t + n * Math.cos(u), y: e + n * Math.sin(u) };
        return wo(c.x, c.y, a, s) <= o / 2;
      }
      const ma = a.transform;
      const ba = d(
        {
          hasArc(t) {
            for (var e = !1, n = t.length, r = 0; r < n; r++) {
              const i = t[r][0];
              if (i === 'C' || i === 'A' || i === 'Q') {
                e = !0;
                break;
              }
            }
            return e;
          },
          extractPolygons(t) {
            for (var e = t.length, n = [], r = [], i = [], o = 0; o < e; o++) {
              const a = t[o];
              const s = a[0];
              s === 'M'
                ? (i.length && (r.push(i), (i = [])), i.push([a[1], a[2]]))
                : s === 'Z'
                ? i.length && (n.push(i), (i = []))
                : i.push([a[1], a[2]]);
            }
            return i.length > 0 && r.push(i), { polygons: n, polylines: r };
          },
          isPointInStroke(t, e, n, r, i) {
            for (var o = !1, a = e / 2, s = 0; s < t.length; s++) {
              const u = t[s];
              const c = u.currentPoint;
              const h = u.params;
              const l = u.prePoint;
              const f = u.box;
              if (!f || Oo(f.x - a, f.y - a, f.width + e, f.height + e, n, r)) {
                switch (u.command) {
                  case 'L':
                  case 'Z':
                    o = ca(l[0], l[1], c[0], c[1], e, n, r);
                    break;
                  case 'Q':
                    o = Ei.pointDistance(l[0], l[1], h[1], h[2], h[3], h[4], n, r) <= e / 2;
                    break;
                  case 'C':
                    o =
                      ji.pointDistance(l[0], l[1], h[1], h[2], h[3], h[4], h[5], h[6], n, r, i) <=
                      e / 2;
                    break;
                  case 'A':
                    var d = u.arcParams;
                    var p = d.cx;
                    var g = d.cy;
                    var v = d.rx;
                    var y = d.ry;
                    var m = d.startAngle;
                    var b = d.endAngle;
                    var x = d.xRotation;
                    var M = [n, r, 1];
                    var S = v > y ? v : y;
                    va(
                      M,
                      M,
                      ma(null, [
                        ['t', -p, -g],
                        ['r', -x],
                        ['s', 1 / (v > y ? 1 : v / y), 1 / (v > y ? y / v : 1)],
                      ]),
                    ),
                      (o = ya(0, 0, S, m, b, e, M[0], M[1]));
                }
                if (o) break;
              }
            }
            return o;
          },
        },
        r,
      );
      function xa(t, e, n) {
        for (var r = !1, i = 0; i < t.length; i++) {
          if ((r = ga(t[i], e, n))) break;
        }
        return r;
      }
      var Ma = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { startArrow: !1, endArrow: !1 });
          }),
          (e.prototype.initAttrs = function (t) {
            this._setPathArr(t.path), this.setArrow();
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r),
              e === 'path' && this._setPathArr(n),
              this.setArrow();
          }),
          (e.prototype._setPathArr = function (t) {
            this.attrs.path = $i(t);
            const e = ba.hasArc(t);
            this.set('hasArc', e),
              this.set('paramsCache', {}),
              this.set('segments', null),
              this.set('curve', null),
              this.set('tCache', null),
              this.set('totalLength', null);
          }),
          (e.prototype.getSegments = function () {
            let t = this.get('segements');
            return t || ((t = io(this.attr('path'))), this.set('segments', t)), t;
          }),
          (e.prototype.setArrow = function () {
            let t;
            const e = this.attr();
            const n = e.startArrow;
            const r = e.endArrow;
            n && Go(this, e, (t = this.getStartTangent())[0][0], t[0][1], t[1][0], t[1][1]);
            r && Uo(this, e, (t = this.getEndTangent())[0][0], t[0][1], t[1][0], t[1][1]);
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            const o = this.getSegments();
            let a = (this.get('hasArc'), !1);
            if (n) {
              const s = this.getTotalLength();
              a = ba.isPointInStroke(o, i, t, e, s);
            }
            if (!a && r) {
              const u = this.attr('path');
              const c = ba.extractPolygons(u);
              a = xa(c.polygons, t, e) || xa(c.polylines, t, e);
            }
            return a;
          }),
          (e.prototype.createPath = function (t) {
            Qo(this, t, this.attr(), this.get('paramsCache'));
          }),
          (e.prototype.afterDrawPath = function (t) {
            const e = this.get('startArrowShape');
            const n = this.get('endArrowShape');
            e && e.draw(t), n && n.draw(t);
          }),
          (e.prototype.getTotalLength = function () {
            const t = this.get('totalLength');
            return co(t) ? (this._calculateCurve(), this._setTcache(), this.get('totalLength')) : t;
          }),
          (e.prototype.getPoint = function (t) {
            let e;
            let n;
            let r = this.get('tCache');
            r || (this._calculateCurve(), this._setTcache(), (r = this.get('tCache')));
            const i = this.get('curve');
            if (!r || r.length === 0) return i ? { x: i[0][1], y: i[0][2] } : null;
            po(r, (r, i) => {
              t >= r[0] && t <= r[1] && ((e = (t - r[0]) / (r[1] - r[0])), (n = i));
            });
            const o = i[n];
            if (co(o) || co(n)) return null;
            const a = o.length;
            const s = i[n + 1];
            return ji.pointAt(o[a - 2], o[a - 1], s[1], s[2], s[3], s[4], s[5], s[6], e);
          }),
          (e.prototype._calculateCurve = function () {
            const t = this.attr().path;
            this.set('curve', ba.pathToCurve(t));
          }),
          (e.prototype._setTcache = function () {
            let t;
            let e;
            let n;
            let r;
            let i = 0;
            let o = 0;
            const a = [];
            const s = this.get('curve');
            s &&
              (po(s, (t, e) => {
                (n = s[e + 1]),
                  (r = t.length),
                  n &&
                    (i += ji.length(t[r - 2], t[r - 1], n[1], n[2], n[3], n[4], n[5], n[6]) || 0);
              }),
              this.set('totalLength', i),
              i !== 0
                ? (po(s, (u, c) => {
                    (n = s[c + 1]),
                      (r = u.length),
                      n &&
                        (((t = [])[0] = o / i),
                        (e = ji.length(u[r - 2], u[r - 1], n[1], n[2], n[3], n[4], n[5], n[6])),
                        (o += e || 0),
                        (t[1] = o / i),
                        a.push(t));
                  }),
                  this.set('tCache', a))
                : this.set('tCache', []));
          }),
          (e.prototype.getStartTangent = function () {
            let t;
            const e = this.getSegments();
            if (e.length > 1) {
              const n = e[0].currentPoint;
              const r = e[1].currentPoint;
              const i = e[1].startTangent;
              (t = []),
                i
                  ? (t.push([n[0] - i[0], n[1] - i[1]]), t.push([n[0], n[1]]))
                  : (t.push([r[0], r[1]]), t.push([n[0], n[1]]));
            }
            return t;
          }),
          (e.prototype.getEndTangent = function () {
            let t;
            const e = this.getSegments();
            const n = e.length;
            if (n > 1) {
              const r = e[n - 2].currentPoint;
              const i = e[n - 1].currentPoint;
              const o = e[n - 1].endTangent;
              (t = []),
                o
                  ? (t.push([i[0] - o[0], i[1] - o[1]]), t.push([i[0], i[1]]))
                  : (t.push([r[0], r[1]]), t.push([i[0], i[1]]));
            }
            return t;
          }),
          e
        );
      })(na);
      function Sa(t, e, n, r, i) {
        const o = t.length;
        if (o < 2) return !1;
        for (let a = 0; a < o - 1; a++) {
          if (ca(t[a][0], t[a][1], t[a + 1][0], t[a + 1][1], e, n, r)) return !0;
        }
        if (i) {
          const s = t[0];
          const u = t[o - 1];
          if (ca(s[0], s[1], u[0], u[1], e, n, r)) return !0;
        }
        return !1;
      }
      var wa = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            const o = this.attr().points;
            let a = !1;
            return n && (a = Sa(o, i, t, e, !0)), !a && r && (a = ga(o, t, e)), a;
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr().points;
            if (!(e.length < 2)) {
              t.beginPath();
              for (let n = 0; n < e.length; n++) {
                const r = e[n];
                n === 0 ? t.moveTo(r[0], r[1]) : t.lineTo(r[0], r[1]);
              }
              t.closePath();
            }
          }),
          e
        );
      })(na);
      var Oa = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { startArrow: !1, endArrow: !1 });
          }),
          (e.prototype.initAttrs = function (t) {
            this.setArrow();
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r),
              this.setArrow(),
              ['points'].indexOf(e) !== -1 && this._resetCache();
          }),
          (e.prototype._resetCache = function () {
            this.set('totalLength', null), this.set('tCache', null);
          }),
          (e.prototype.setArrow = function () {
            const t = this.attr();
            const e = this.attrs;
            const n = e.points;
            const r = e.startArrow;
            const i = e.endArrow;
            const o = n.length;
            const a = n[0][0];
            const s = n[0][1];
            const u = n[o - 1][0];
            const c = n[o - 1][1];
            r && Go(this, t, n[1][0], n[1][1], a, s),
              i && Uo(this, t, n[o - 2][0], n[o - 2][1], u, c);
          }),
          (e.prototype.isFill = function () {
            return !1;
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            return !(!n || !i) && Sa(this.attr().points, i, t, e, !1);
          }),
          (e.prototype.isStroke = function () {
            return !0;
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.points;
            const r = e.startArrow;
            const i = e.endArrow;
            const o = n.length;
            if (!(n.length < 2)) {
              let a;
              let s = n[0][0];
              let u = n[0][1];
              let c = n[o - 1][0];
              let h = n[o - 1][1];
              if (r && r.d) (s += (a = Wo(s, u, n[1][0], n[1][1], r.d)).dx), (u += a.dy);
              if (i && i.d) (c -= (a = Wo(n[o - 2][0], n[o - 2][1], c, h, i.d)).dx), (h -= a.dy);
              t.beginPath(), t.moveTo(s, u);
              for (let l = 0; l < o - 1; l++) {
                const f = n[l];
                t.lineTo(f[0], f[1]);
              }
              t.lineTo(c, h);
            }
          }),
          (e.prototype.afterDrawPath = function (t) {
            const e = this.get('startArrowShape');
            const n = this.get('endArrowShape');
            e && e.draw(t), n && n.draw(t);
          }),
          (e.prototype.getTotalLength = function () {
            const t = this.attr().points;
            const e = this.get('totalLength');
            return co(e) ? (this.set('totalLength', Di(t)), this.get('totalLength')) : e;
          }),
          (e.prototype.getPoint = function (t) {
            let e;
            let n;
            const r = this.attr().points;
            let i = this.get('tCache');
            return (
              i || (this._setTcache(), (i = this.get('tCache'))),
              po(i, (r, i) => {
                t >= r[0] && t <= r[1] && ((e = (t - r[0]) / (r[1] - r[0])), (n = i));
              }),
              xi.pointAt(r[n][0], r[n][1], r[n + 1][0], r[n + 1][1], e)
            );
          }),
          (e.prototype._setTcache = function () {
            const t = this.attr().points;
            if (t && t.length !== 0) {
              const e = this.getTotalLength();
              if (!(e <= 0)) {
                let n;
                let r;
                let i = 0;
                const o = [];
                po(t, (a, s) => {
                  t[s + 1] &&
                    (((n = [])[0] = i / e),
                    (r = xi.length(a[0], a[1], t[s + 1][0], t[s + 1][1])),
                    (i += r),
                    (n[1] = i / e),
                    o.push(n));
                }),
                  this.set('tCache', o);
              }
            }
          }),
          (e.prototype.getStartTangent = function () {
            const t = this.attr().points;
            const e = [];
            return e.push([t[1][0], t[1][1]]), e.push([t[0][0], t[0][1]]), e;
          }),
          (e.prototype.getEndTangent = function () {
            const t = this.attr().points;
            const e = t.length - 1;
            const n = [];
            return n.push([t[e - 1][0], t[e - 1][1]]), n.push([t[e][0], t[e][1]]), n;
          }),
          e
        );
      })(na);
      var Ca = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
          }),
          (e.prototype.isInStrokeOrPath = function (t, e, n, r, i) {
            const o = this.attr();
            const a = o.x;
            const s = o.y;
            const u = o.width;
            const c = o.height;
            const h = o.radius;
            if (h) {
              let l = !1;
              return (
                n &&
                  (l = (function (t, e, n, r, i, o, a, s) {
                    return (
                      ca(t + i, e, t + n - i, e, o, a, s) ||
                      ca(t + n, e + i, t + n, e + r - i, o, a, s) ||
                      ca(t + n - i, e + r, t + i, e + r, o, a, s) ||
                      ca(t, e + r - i, t, e + i, o, a, s) ||
                      ya(t + n - i, e + i, i, 1.5 * Math.PI, 2 * Math.PI, o, a, s) ||
                      ya(t + n - i, e + r - i, i, 0, 0.5 * Math.PI, o, a, s) ||
                      ya(t + i, e + r - i, i, 0.5 * Math.PI, Math.PI, o, a, s) ||
                      ya(t + i, e + i, i, Math.PI, 1.5 * Math.PI, o, a, s)
                    );
                  })(a, s, u, c, h, i, t, e)),
                !l && r && (l = Oo(a, s, u, c, t, e)),
                l
              );
            }
            const f = i / 2;
            return r && n
              ? Oo(a - f, s - f, u + f, c + f, t, e)
              : r
              ? Oo(a, s, u, c, t, e)
              : n
              ? (function (t, e, n, r, i, o, a) {
                  const s = i / 2;
                  return (
                    Oo(t - s, e - s, n, i, o, a) ||
                    Oo(t + n - s, e - s, i, r, o, a) ||
                    Oo(t + s, e + r - s, n, i, o, a) ||
                    Oo(t - s, e + s, i, r, o, a)
                  );
                })(a, s, u, c, i, t, e)
              : void 0;
          }),
          (e.prototype.createPath = function (t) {
            const e = this.attr();
            const n = e.x;
            const r = e.y;
            const i = e.width;
            const o = e.height;
            const a = e.radius;
            if ((t.beginPath(), a === 0)) t.rect(n, r, i, o);
            else {
              const s = (function (t) {
                let e = 0;
                let n = 0;
                let r = 0;
                let i = 0;
                return (
                  ho(t)
                    ? t.length === 1
                      ? (e = n = r = i = t[0])
                      : t.length === 2
                      ? ((e = r = t[0]), (n = i = t[1]))
                      : t.length === 3
                      ? ((e = t[0]), (n = i = t[1]), (r = t[2]))
                      : ((e = t[0]), (n = t[1]), (r = t[2]), (i = t[3]))
                    : (e = n = r = i = t),
                  [e, n, r, i]
                );
              })(a);
              const u = s[0];
              const c = s[1];
              const h = s[2];
              const l = s[3];
              t.moveTo(n + u, r),
                t.lineTo(n + i - c, r),
                c !== 0 && t.arc(n + i - c, r + c, c, -Math.PI / 2, 0),
                t.lineTo(n + i, r + o - h),
                h !== 0 && t.arc(n + i - h, r + o - h, h, 0, Math.PI / 2),
                t.lineTo(n + l, r + o),
                l !== 0 && t.arc(n + l, r + o - l, l, Math.PI / 2, Math.PI),
                t.lineTo(n, r + u),
                u !== 0 && t.arc(n + u, r + u, u, Math.PI, 1.5 * Math.PI),
                t.closePath();
            }
          }),
          e
        );
      })(na);
      var Ea = (function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        return (
          f(e, t),
          (e.prototype.getDefaultAttrs = function () {
            const e = t.prototype.getDefaultAttrs.call(this);
            return d(d({}, e), {
              x: 0,
              y: 0,
              text: null,
              fontSize: 12,
              fontFamily: 'sans-serif',
              fontStyle: 'normal',
              fontWeight: 'normal',
              fontVariant: 'normal',
              textAlign: 'start',
              textBaseline: 'bottom',
            });
          }),
          (e.prototype.isOnlyHitBox = function () {
            return !0;
          }),
          (e.prototype.initAttrs = function (t) {
            this._assembleFont(), t.text && this._setText(t.text);
          }),
          (e.prototype._assembleFont = function () {
            const t = this.attrs;
            t.font = Wi(t);
          }),
          (e.prototype._setText = function (t) {
            let e = null;
            vo(t) && t.indexOf('\n') !== -1 && (e = t.split('\n')), this.set('textArr', e);
          }),
          (e.prototype.onAttrChange = function (e, n, r) {
            t.prototype.onAttrChange.call(this, e, n, r),
              e.startsWith('font') && this._assembleFont(),
              e === 'text' && this._setText(n);
          }),
          (e.prototype._getSpaceingY = function () {
            const t = this.attrs;
            const e = t.lineHeight;
            const n = 1 * t.fontSize;
            return e ? e - n : 0.14 * n;
          }),
          (e.prototype._drawTextArr = function (t, e, n) {
            let r;
            const i = this.attrs;
            const o = i.textBaseline;
            const a = i.x;
            const s = i.y;
            const u = 1 * i.fontSize;
            const c = this._getSpaceingY();
            const h = Xi(i.text, i.fontSize, i.lineHeight);
            po(e, (e, i) => {
              (r = s + i * (c + u) - h + u),
                o === 'middle' && (r += h - u - (h - u) / 2),
                o === 'top' && (r += h - u),
                n ? t.fillText(e, a, r) : t.strokeText(e, a, r);
            });
          }),
          (e.prototype._drawText = function (t, e) {
            const n = this.attr();
            const r = n.x;
            const i = n.y;
            const o = this.get('textArr');
            if (o) this._drawTextArr(t, o, e);
            else {
              const a = n.text;
              e ? t.fillText(a, r, i) : t.strokeText(a, r, i);
            }
          }),
          (e.prototype.strokeAndFill = function (t) {
            const e = this.attrs;
            const n = e.lineWidth;
            const r = e.opacity;
            const i = e.strokeOpacity;
            const o = e.fillOpacity;
            this.isStroke() && n > 0 && (co(i) || i === 1 || (t.globalAlpha = r), this.stroke(t)),
              this.isFill() &&
                (co(o) || o === 1
                  ? this.fill(t)
                  : ((t.globalAlpha = o), this.fill(t), (t.globalAlpha = r))),
              this.afterDrawPath(t);
          }),
          (e.prototype.fill = function (t) {
            this._drawText(t, !0);
          }),
          (e.prototype.stroke = function (t) {
            this._drawText(t, !1);
          }),
          e
        );
      })(na);
      function ka(t, e, n) {
        let r;
        let i;
        const o = t.getTotalMatrix();
        if (o) {
          const a = ((r = [e, n, 1]), (i = o) ? Le(De(i), r) : r);
          return [a[0], a[1]];
        }
        return [e, n];
      }
      function Ta(t, e, n) {
        if (t.isCanvas && t.isCanvas()) return !0;
        if (!J(t) || !1 === t.cfg.isInView) return !1;
        if (t.cfg.clipShape) {
          const r = ka(t, e, n);
          const i = r[0];
          const o = r[1];
          if (t.isClipped(i, o)) return !1;
        }
        const a = t.cfg.cacheCanvasBBox || t.getCanvasBBox();
        return e >= a.minX && e <= a.maxX && n >= a.minY && n <= a.maxY;
      }
      const Pa = n(34);
      const Ia = n.n(Pa);
      function Aa(t, e, n) {
        (n.name = e), (n.target = t), (n.currentTarget = t), (n.delegateTarget = t), t.emit(e, n);
      }
      function ja(t, e, n) {
        if (n.bubbles) {
          t.isCanvas(),
            0,
            (n.name = e),
            (n.currentTarget = t),
            (n.delegateTarget = t),
            t.emit(e, n);
        }
      }
      const Na = (function () {
        function t(t) {
          const e = this;
          (this.draggingShape = null),
            (this.dragging = !1),
            (this.currentShape = null),
            (this.panstartShape = null),
            (this.panstartPoint = null),
            (this.handleEvent = function (t) {
              e.hammerRuntime.emit(`origin_input:${t.type}`, t);
            }),
            (this.canvas = t.canvas),
            this._initEvent();
        }
        return (
          (t.prototype._initEvent = function () {
            const t = this;
            (this.hammerRuntime = new Ia.a({}, { inputClass: Pa.TouchInput })),
              this.hammerRuntime.add(new Ia.a.Pan({ threshold: 0, pointers: 1 })),
              this.hammerRuntime.add(new Ia.a.Swipe()).recognizeWith(this.hammerRuntime.get('pan')),
              this.hammerRuntime.add(new Ia.a.Pinch({ threshold: 0, pointers: 2 })),
              this.hammerRuntime.add(new Ia.a.Tap({ event: 'dbltap', taps: 2 })),
              this.hammerRuntime.add(new Ia.a.Tap()),
              this.hammerRuntime.add(new Ia.a.Press({ time: 500 })),
              this.hammerRuntime.on('panstart panmove panend pancancel', (e) => {
                e.srcEvent.extra = e;
                const n = t._getPointInfo(e);
                const r = t._getShape(n, e);
                (e.type !== 'panend' && e.type !== 'pancancel') || t._onpanend(n, r, e),
                  e.type === 'panstart' &&
                    (t.dragging &&
                      ((t.draggingShape = null),
                      (t.dragging = !1),
                      (t.panstartShape = null),
                      (t.panstartPoint = null)),
                    t._onpanstart(n, r, e)),
                  e.type === 'panmove' && t._onpanmove(n, r, e),
                  (t.currentShape = r);
              }),
              this.hammerRuntime.on('tap dbltap press swipe rotatestart rotatemove', (e) => {
                t._emitMobileEvent(e.type, e);
              }),
              this.hammerRuntime.on('pinchstart pinchmove pinchend pinchcancel', (e) => {
                e.type !== 'pinchend' && e.type !== 'pinchcancel'
                  ? ((e.srcEvent.extra = { scale: e.scale }), t._emitMobileEvent(e.type, e))
                  : t._emitMobileEvent(e.type, e);
              });
          }),
          (t.prototype._emitMobileEvent = function (t, e) {
            const n = this._getPointInfo(e);
            const r = this._getShape(n, e);
            this._emitEvent(t, e, n, r);
          }),
          (t.prototype._getEventObj = function (t, e, n, r, i, o) {
            const a = new V(t, e);
            return (
              (a.fromShape = i),
              (a.toShape = o),
              (a.x = n.x),
              (a.y = n.y),
              (a.clientX = n.clientX),
              (a.clientY = n.clientY),
              a.propagationPath.push(r),
              a
            );
          }),
          (t.prototype._getShape = function (t, e) {
            const n = e.srcEvent;
            return this.canvas.getShape(t.x, t.y, n);
          }),
          (t.prototype._getPointInfo = function (t) {
            const e = this.canvas;
            const n = e.getClientByEvent(t);
            const r = e.getPointByEvent(t);
            return { x: r.x, y: r.y, clientX: n.x, clientY: n.y };
          }),
          (t.prototype._triggerEvent = function (t, e) {
            const n = this._getPointInfo(e);
            const r = this._getShape(n, e);
            const i = this[`_on${t}`];
            if (i) i.call(this, n, r, e);
            else {
              const o = this.currentShape;
              t === 'panstart' || t === 'dragenter'
                ? (this._emitEvent(t, e, n, null, null, r),
                  r && this._emitEvent(t, e, n, r, null, r),
                  t === 'panstart' &&
                    this.draggingShape &&
                    this._emitEvent('dragenter', e, n, null))
                : t === 'panend' || t === 'dragleave'
                ? (o && this._emitEvent(t, e, n, o, o, null),
                  this._emitEvent(t, e, n, null, o, null),
                  t === 'panend' && this.draggingShape && this._emitEvent('dragleave', e, n, null))
                : this._emitEvent(t, e, n, r, null, null);
            }
          }),
          (t.prototype._onpanstart = function (t, e, n) {
            (this.panstartShape = e),
              (this.panstartPoint = t),
              (this.panstartTimeStamp = n.timeStamp),
              this._emitEvent('panstart', n, t, e, null, null);
          }),
          (t.prototype._emitDragoverEvents = function (t, e, n, r, i) {
            r
              ? (r !== n &&
                  (n && this._emitEvent('dragleave', t, e, n, n, r),
                  this._emitEvent('dragenter', t, e, r, n, r)),
                i || this._emitEvent('dragover', t, e, r))
              : n && this._emitEvent('dragleave', t, e, n, n, r),
              i && this._emitEvent('dragover', t, e, r);
          }),
          (t.prototype._afterDrag = function (t, e, n) {
            t && (t.set('capture', !0), (this.draggingShape = null)), (this.dragging = !1);
            const r = this._getShape(e, n);
            this.currentShape = r;
          }),
          (t.prototype._onpanend = function (t, e, n) {
            const r = this.draggingShape;
            this.dragging &&
              (r && this._emitEvent('drop', n, t, e),
              this._emitEvent('dragend', n, t, r),
              this._afterDrag(r, t, n)),
              this._emitEvent('panend', n, t, e),
              (this.panstartShape = null),
              (this.panstartPoint = null);
          }),
          (t.prototype._onpanmove = function (t, e, n) {
            const r = this.canvas;
            const i = this.currentShape;
            let o = this.draggingShape;
            if (this.dragging)
              o && this._emitDragoverEvents(n, t, i, e, !1), this._emitEvent('drag', n, t, o);
            else {
              const a = this.panstartPoint;
              if (a) {
                const s = this.panstartShape;
                const u = n.timeStamp - this.panstartTimeStamp;
                const c = a.clientX - t.clientX;
                const h = a.clientY - t.clientY;
                (u > 120 || c * c + h * h > 40) &&
                  (s && s.get('draggable')
                    ? ((o = this.panstartShape).set('capture', !1),
                      (this.draggingShape = o),
                      (this.dragging = !0),
                      this._emitEvent('dragstart', n, t, o),
                      (this.panstartShape = null),
                      (this.panstartPoint = null))
                    : !s && r.get('draggable')
                    ? ((this.dragging = !0),
                      this._emitEvent('dragstart', n, t, null),
                      (this.panstartShape = null),
                      (this.panstartPoint = null))
                    : this._emitEvent('panmove', n, t, e));
              }
            }
            this._emitEvent('panmove', n, t, e);
          }),
          (t.prototype._emitEvent = function (t, e, n, r, i, o) {
            const a = this._getEventObj(t, e, n, r, i, o);
            if (r) {
              (a.shape = r), Aa(r, t, a);
              for (let s = r.getParent(); s; )
                s.emitDelegation(t, a),
                  a.propagationStopped || ja(s, t, a),
                  a.propagationPath.push(s),
                  (s = s.getParent());
            } else {
              Aa(this.canvas, t, a);
            }
          }),
          (t.prototype.destroy = function () {
            (this.canvas = null),
              (this.currentShape = null),
              (this.draggingShape = null),
              (this.panstartPoint = null),
              (this.panstartShape = null),
              (this.panstartTimeStamp = null);
          }),
          t
        );
      })();
      const _a = (function () {
        function t() {}
        return (
          (t.prototype.set = function (t, e, n) {
            switch (e) {
              case 'strokeStyle':
                t.setStrokeStyle(n);
                break;
              case 'fillStyle':
                t.setFillStyle(n);
                break;
              case 'lineWidth':
                t.setLineWidth(n);
                break;
              case 'lineDash':
                t.setLineDash(n);
                break;
              case 'globalAlpha':
                (n || n === 0) && ((t.globalAlpha = n), t.setGlobalAlpha(n));
                break;
              case 'fontSize':
                t.setFontSize(n);
                break;
              case 'textAlign':
                t.setTextAlign(n);
                break;
              case 'fontStyle':
              case 'font':
                t.setFont(n);
                break;
              case 'textBaseline':
                t.setTextBaseline(n);
                break;
              default:
                t[e] = n;
            }
            return !0;
          }),
          (t.prototype.get = function (t, e) {
            return e === 'globalAlpha' && void 0 === t[e]
              ? 1
              : typeof t[e] === 'function'
              ? t[e].bind(t)
              : t[e];
          }),
          t
        );
      })();
      const Ba = n(117);
      let La = null;
      const Da = function (t) {
        const e = t.attr();
        const n = e.x;
        const r = e.y;
        const i = e.text;
        const o = e.fontSize;
        const a = e.lineHeight;
        let s = e.font;
        s || (s = Object(Ba.assembleFont)(e));
        let u;
        const c = (function (t, e) {
          let n = 0;
          if (co(t) || t === '') return n;
          if ((La.save(), (La.font = e), vo(t) && t.includes('\n'))) {
            const r = t.split('\n');
            po(r, (t) => {
              const e = La.measureText(t).width;
              n < e && (n = e);
            });
          } else n = La.measureText(t).width;
          return La.restore(), n;
        })(i, s);
        if (c) {
          const h = e.textAlign;
          const l = e.textBaseline;
          const f = Object(Ba.getTextHeight)(i, o, a);
          const d = { x: n, y: r - f };
          h && (h === 'end' || h === 'right' ? (d.x -= c) : h === 'center' && (d.x -= c / 2)),
            l && (l === 'top' ? (d.y += f) : l === 'middle' && (d.y += f / 2)),
            (u = { x: d.x, y: d.y, width: c, height: f });
        } else u = { x: n, y: r, width: 0, height: 0 };
        return u;
      };
      const Ra = function (t) {
        (La = t), $r('text', Da);
      };
      const Ya = function (t, e) {
        !(function (t) {
          sa = t;
        })(e),
          Ra(t);
      };
      const Fa = (function (t) {
        function e(e) {
          let n;
          const r = t.call(this, e) || this;
          const i = r.get('context');
          return (
            r.isMini() &&
              (r.isMiniNative()
                ? (void 0 === (n = r.get('container')) && (n = {}), (n = n))
                : r.set('context', new Proxy(i, new _a())),
              Ya(i, r)),
            r
          );
        }
        return (
          f(e, t),
          (e.prototype.isMiniNative = function () {
            return this.get('renderer') === 'mini-native';
          }),
          (e.prototype.isMini = function () {
            return this.get('renderer').startsWith('mini');
          }),
          (e.prototype.getDefaultCfg = function () {
            const e = t.prototype.getDefaultCfg.call(this);
            return (
              (e.renderer = 'canvas'),
              (e.autoDraw = !0),
              (e.localRefresh = !0),
              (e.refreshElements = []),
              (e.clipView = !0),
              (e.quickHit = !1),
              (e.boundingClientRect = {
                width: 0,
                height: 0,
                left: 0,
                top: 0,
                bottom: 0,
                right: 0,
              }),
              e
            );
          }),
          (e.prototype.initEvents = function () {
            const t = new Na({ canvas: this });
            this.set('eventController', t);
          }),
          (e.prototype.registerEventCallback = function (t) {
            this.get('eventController').handleEvent(t);
          }),
          (e.prototype.clearEvents = function () {
            this.get('eventController').destroy();
          }),
          (e.prototype.onCanvasChange = function (t) {
            (t !== 'attr' && t !== 'sort' && t !== 'changeSize') ||
              (this.set('refreshElements', [this]), this.draw());
          }),
          (e.prototype.getShapeBase = function () {
            return c;
          }),
          (e.prototype.getGroupBase = function () {
            return ea;
          }),
          (e.prototype.getPixelRatio = function () {
            const t =
              this.get('pixelRatio') ||
              (typeof window === 'object' && window.devicePixelRatio ? window.devicePixelRatio : 1);
            return t >= 1 ? Math.ceil(t) : 1;
          }),
          (e.prototype.getViewRange = function () {
            return { minX: 0, minY: 0, maxX: this.cfg.width, maxY: this.cfg.height };
          }),
          (e.prototype.initDom = function () {
            if (this.isMini()) {
              const e = this.get('context');
              const n = this.getPixelRatio();
              n > 1 && e.scale(n, n);
            } else t.prototype.initDom.call(this);
          }),
          (e.prototype.createDom = function () {
            const t = document.createElement('canvas');
            const e = t.getContext('2d');
            return this.set('context', e), t;
          }),
          (e.prototype.setDOMSize = function (e, n) {
            t.prototype.setDOMSize.call(this, e, n);
            const r = this.get('context');
            const i = this.get('el');
            const o = this.getPixelRatio();
            (i.width = o * e), (i.height = o * n), o > 1 && r.scale(o, o);
          }),
          (e.prototype.clear = function () {
            t.prototype.clear.call(this),
              this._clearFrame(),
              this.get('context').clearRect(0, 0, this.get('width'), this.get('height'));
          }),
          (e.prototype.getShape = function (e, n) {
            return this.get('quickHit')
              ? (function t(e, n, r) {
                  if (!Ta(e, n, r)) return null;
                  for (var i = null, o = e.getChildren(), a = o.length - 1; a >= 0; a--) {
                    const s = o[a];
                    if (s.isGroup()) i = t(s, n, r);
                    else if (Ta(s, n, r)) {
                      const u = s;
                      const c = ka(s, n, r);
                      const h = c[0];
                      const l = c[1];
                      u.isInShape(h, l) && (i = s);
                    }
                    if (i) break;
                  }
                  return i;
                })(this, e, n)
              : t.prototype.getShape.call(this, e, n, null);
          }),
          (e.prototype._getRefreshRegion = function () {
            let t;
            const e = this.get('refreshElements');
            const n = this.getViewRange();
            e.length && e[0] === this
              ? (t = n)
              : (t = (function (t) {
                  if (!t.length) return null;
                  const e = [];
                  const n = [];
                  const r = [];
                  const i = [];
                  return (
                    po(t, (t) => {
                      const o = ta(t);
                      o && (e.push(o.minX), n.push(o.minY), r.push(o.maxX), i.push(o.maxY));
                    }),
                    {
                      minX: Math.min.apply(null, e),
                      minY: Math.min.apply(null, n),
                      maxX: Math.max.apply(null, r),
                      maxY: Math.max.apply(null, i),
                    }
                  );
                })(e)) &&
                ((t.minX = Math.floor(t.minX)),
                (t.minY = Math.floor(t.minY)),
                (t.maxX = Math.ceil(t.maxX)),
                (t.maxY = Math.ceil(t.maxY)),
                (t.maxY += 1),
                this.get('clipView') &&
                  (t = (function (t, e) {
                    return t && e && Co(t, e)
                      ? {
                          minX: Math.max(t.minX, e.minX),
                          minY: Math.max(t.minY, e.minY),
                          maxX: Math.min(t.maxX, e.maxX),
                          maxY: Math.min(t.maxY, e.maxY),
                        }
                      : null;
                  })(t, n)));
            return t;
          }),
          (e.prototype._clearFrame = function () {
            const t = this.get('drawFrame');
            t && (So(t), this.set('drawFrame', null), this.set('refreshElements', []));
          }),
          (e.prototype.draw = function () {
            const t = this.get('drawFrame');
            (this.get('autoDraw') && t) || this._startDraw();
          }),
          (e.prototype._startDraw = function () {
            let t;
            const e = this;
            let n = this.get('drawFrame');
            n ||
              ((t = function () {
                e.get('localRefresh') ? e._drawRegion() : e._drawAll(),
                  So(n),
                  e.set('drawFrame', null);
              }),
              (n = (Mo == null ? void 0 : Mo.requestAnimationFrame)
                ? Mo.requestAnimationFrame(t)
                : (typeof window === 'object' && window.requestAnimationFrame
                    ? window.requestAnimationFrame
                    : function (t) {
                        return setTimeout(t, 16);
                      })(t)),
              this.set('drawFrame', n));
          }),
          (e.prototype._drawRegion = function () {
            const t = this.get('context');
            const e = this.get('refreshElements');
            const n = this.getChildren();
            const r = this._getRefreshRegion();
            r
              ? (t.clearRect(r.minX, r.minY, r.maxX - r.minX, r.maxY - r.minY),
                t.save(),
                t.beginPath(),
                t.rect(r.minX, r.minY, r.maxX - r.minX, r.maxY - r.minY),
                t.clip(),
                qo(t, this),
                Zo(this, n, r),
                Vo(t, n, r),
                t.restore())
              : e.length &&
                (function t(e) {
                  for (let n = 0; n < e.length; n++) {
                    const r = e[n];
                    (r.cfg.hasChanged = !1), r.isGroup() && !r.destroyed && t(r.cfg.children);
                  }
                })(e),
              po(e, (t) => {
                t.get('hasChanged') && t.set('hasChanged', !1);
              }),
              this.isMini() && !this.isMiniNative() && t.draw(!0),
              this.set('refreshElements', []);
          }),
          (e.prototype._drawAll = function () {
            const t = this.get('context');
            const e = this.getChildren();
            t.clearRect(0, 0, this.get('width'), this.get('height')),
              qo(t, this),
              Vo(t, e),
              this.isMini() && !this.isMiniNative() && t.draw(!0),
              this.set('refreshElements', []);
          }),
          (e.prototype.skipDraw = function () {}),
          (e.prototype.refreshElement = function (t) {
            this.get('refreshElements').push(t);
          }),
          (e.prototype.getPointByEvent = function (e) {
            if (this.isMini()) {
              const n = this.getClientByEvent(e);
              const r = n.x;
              const i = n.y;
              return this.getPointByClient(r, i);
            }
            return t.prototype.getPointByEvent.call(this, e);
          }),
          (e.prototype.getClientByEvent = function (t) {
            const e = t.srcEvent;
            let n = null;
            return (
              e.touches && (n = e.type === 'touchend' ? e.changedTouches[0] : e.touches[0]),
              n ? { x: n.clientX, y: n.clientY } : {}
            );
          }),
          (e.prototype.getPointByClient = function (t, e) {
            if (this.isMini()) {
              const n = this.get('boundingClientRect');
              return { x: t + n.left, y: e + n.top };
            }
            const r = this.get('el').getBoundingClientRect();
            return { x: t - r.left, y: e - r.top };
          }),
          (e.prototype.getClientByPoint = function (t, e) {
            if (this.isMini()) {
              const n = this.get('boundingClientRect');
              return { x: t + n.left, y: e + n.top };
            }
            const r = this.get('el').getBoundingClientRect();
            return { x: t + r.left, y: e + r.top };
          }),
          e
        );
      })(qr);
      const Xa = n(8);
      const za = n(0);
      const Wa = n(2);
      const Ga = n(19);
      const Ua = Wa.n.cloneEvent;
      const Ha = Wa.n.isViewportChanged;
      const qa = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          return (
            (n.extendEvents = []),
            (n.dragging = !1),
            (n.preItem = null),
            (n.graph = e),
            (n.destroyed = !1),
            n
          );
        }
        return (
          Object(h.c)(e, t),
          (e.prototype.initEvents = function () {
            const t = this.graph;
            const e = (this.extendEvents, t.get('canvas'));
            (this.canvasHandler = Object(za.x)(this, 'onCanvasEvents')),
              e.off('*').on('*', this.canvasHandler);
          }),
          (e.getItemRoot = function (t) {
            for (; t && !t.get('item'); ) t = t.get('parent');
            return t;
          }),
          (e.prototype.onCanvasEvents = function (t) {
            const n = this.graph;
            const r = n.get('canvas');
            const i = t.target;
            const o = t.type;
            (t.canvasX = t.x), (t.canvasY = t.y);
            let a = { x: t.canvasX, y: t.canvasY };
            let s = n.get('group').getMatrix();
            if (
              (s || (s = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              Ha(s) && (a = n.getPointByClient(t.clientX, t.clientY)),
              (t.x = a.x),
              (t.y = a.y),
              (t.currentTarget = n),
              i === r)
            )
              return (
                o === 'panmove' && this.handleTouchMove(t, 'canvas'),
                (t.target = r),
                (t.item = null),
                n.emit(o, t),
                void n.emit(`canvas:${o}`, t)
              );
            const u = e.getItemRoot(i);
            if (u) {
              const c = u.get('item');
              if (!c.destroyed) {
                const h = c.getType();
                if (((t.target = i), (t.item = c), t.canvasX === t.x && t.canvasY === t.y)) {
                  const l = n.getCanvasByPoint(t.x, t.y);
                  (t.canvasX = l.x), (t.canvasY = l.y);
                }
                n.emit(o, t),
                  t.name && !t.name.includes(':') ? n.emit(`${h}:${o}`, t) : n.emit(t.name, t),
                  o === 'dragstart' && (this.dragging = !0),
                  o === 'dragend' && (this.dragging = !1),
                  o === 'panmove' && this.handleTouchMove(t, h);
              }
            } else n.emit(o, t);
          }),
          (e.prototype.onExtendEvents = function (t) {
            this.graph.emit(t.type, t);
          }),
          (e.prototype.emitCustomEvent = function (t, e, n) {
            (n.type = e), this.graph.emit(`${t}:${e}`, n);
          }),
          (e.prototype.destroy = function () {
            const t = this.graph;
            const e = this.canvasHandler;
            const n = this.extendEvents;
            t.get('canvas').off('*', e),
              Object(za.c)(n, (t) => {
                t.remove();
              }),
              (this.dragging = !1),
              (this.preItem = null),
              (this.extendEvents.length = 0),
              (this.canvasHandler = null),
              (this.destroyed = !0);
          }),
          (e.prototype.handleTouchMove = function (t, e) {
            const n = this.graph;
            const r = this.preItem;
            const i = n.get('canvas');
            const o = t.target === i ? null : t.item;
            (t = Ua(t)),
              r &&
                r !== o &&
                !r.destroyed &&
                ((t.item = r),
                this.emitCustomEvent(r.getType(), 'touchleave', t),
                this.dragging && this.emitCustomEvent(r.getType(), 'dragleave', t)),
              o &&
                r !== o &&
                ((t.item = o),
                this.emitCustomEvent(e, 'touchenter', t),
                this.dragging && this.emitCustomEvent(e, 'dragenter', t)),
              (this.preItem = o);
          }),
          e
        );
      })(Wa.a);
      const Va = n(28);
      const Za = ['force', 'grid', 'circular'];
      const Ka = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          return (
            (n.graph = e),
            (n.layoutCfg = e.get('layout') || {}),
            (n.layoutType = n.getLayoutType()),
            n
          );
        }
        return (
          Object(h.c)(e, t),
          (e.prototype.updateLayoutCfg = function (t) {
            const e = this;
            const n = this.graph;
            const r = this.layoutMethods;
            const i = Object(za.r)({}, this.layoutCfg, t);
            if (((this.layoutCfg = i), r == null ? void 0 : r.length)) {
              (this.data = this.setDataFromGraph()), n.emit('beforelayout');
              let o = Promise.resolve();
              r.length === 1
                ? (o = o.then(() => {
                    return e.updateLayoutMethod(r[0], i);
                  }))
                : r == null ||
                  r.forEach((t, n) => {
                    const r = i.pipes[n];
                    o = o.then(() => {
                      return e.updateLayoutMethod(t, r);
                    });
                  }),
                (this.data = this.setDataFromGraph()),
                o
                  .then(() => {
                    i.onAllLayoutEnd && i.onAllLayoutEnd();
                  })
                  .catch((t) => {
                    console.warn('layout failed', t);
                  });
            } else this.layout();
          }),
          (e.prototype.layout = function (t) {
            const e = this;
            const n = this.graph;
            this.data = this.setDataFromGraph();
            const r = this.data;
            const i = r.nodes;
            const o = r.hiddenNodes;
            if (!i) return !1;
            const a = n.get('width');
            const s = n.get('height');
            const u = {};
            Object.assign(u, { width: a, height: s, center: [a / 2, s / 2] }, this.layoutCfg),
              (this.layoutCfg = u),
              this.destoryLayoutMethods(),
              n.emit('beforelayout'),
              this.initPositions(u.center, i),
              this.initPositions(u.center, o);
            const c = u.onLayoutEnd;
            const l = u.layoutEndFormatted;
            const f = u.adjust;
            l ||
              ((u.layoutEndFormatted = !0),
              (u.onAllLayoutEnd = function () {
                return Object(h.b)(e, void 0, void 0, function () {
                  return Object(h.d)(this, function (t) {
                    switch (t.label) {
                      case 0:
                        return (
                          c && c(),
                          this.refreshLayout(),
                          f && u.pipes ? [4, this.adjustPipesBox(this.data, f)] : [3, 2]
                        );
                      case 1:
                        t.sent(), this.refreshLayout(), (t.label = 2);
                      case 2:
                        return n.emit('afterlayout'), [2];
                    }
                  });
                });
              }));
            let d = Promise.resolve();
            return (
              u.type
                ? (d = d.then(() => {
                    return e.execLayoutMethod(u, 0);
                  }))
                : u.pipes &&
                  u.pipes.forEach((t, n) => {
                    d = d.then(() => {
                      return e.execLayoutMethod(t, n);
                    });
                  }),
              d
                .then(() => {
                  u.onAllLayoutEnd && u.onAllLayoutEnd(), t && t();
                })
                .catch((t) => {
                  console.warn('graph layout failed,', t);
                }),
              !1
            );
          }),
          (e.prototype.execLayoutMethod = function (t, e) {
            const n = this;
            return new Promise((r, i) => {
              const o = n.graph;
              const a = t.type;
              if (
                ((t.onLayoutEnd = function () {
                  o.emit('aftersublayout', { type: a }), r();
                }),
                a === 'force' || a === 'g6force' || a === 'gForce')
              ) {
                const s = t.onTick;
                var u = function () {
                  s && s(), o.refreshPositions();
                };
                t.tick = u;
              } else t.type === 'comboForce' && (t.comboTrees = o.get('comboTrees'));
              let c;
              try {
                c = new Va.a(t);
              } catch (t) {
                console.warn(`The layout method: '${a}' does not exist! Please specify it first.`),
                  i();
              }
              if (c.enableTick) {
                const h = t.onTick;
                u = function () {
                  h && h(), o.refreshPositions();
                };
                c.tick = u;
              }
              const l = n.filterLayoutData(n.data, t);
              !(function (t, e) {
                let n;
                if (
                  !((n = t == null ? void 0 : t.nodes) === null || void 0 === n ? void 0 : n.length)
                )
                  return;
                t.nodes.forEach((t) => {
                  t.layoutOrder = e;
                });
              })(l, e),
                c.init(l),
                o.emit('beforesublayout', { type: a }),
                c.execute(),
                c.isCustomLayout && t.onLayoutEnd && t.onLayoutEnd(),
                n.layoutMethods.push(c);
            });
          }),
          (e.prototype.updateLayoutMethod = function (t, e) {
            const n = this;
            return new Promise((r, i) => {
              const o = n.graph;
              const a = e == null ? void 0 : e.type;
              e.onLayoutEnd = function () {
                o.emit('aftersublayout', { type: a }), r();
              };
              const s = n.filterLayoutData(n.data, e);
              t.init(s),
                t.updateCfg(e),
                o.emit('beforesublayout', { type: a }),
                t.execute(),
                t.isCustomLayout && e.onLayoutEnd && e.onLayoutEnd();
            });
          }),
          (e.prototype.adjustPipesBox = function (t, e) {
            const n = this;
            return new Promise((r) => {
              const i = t.nodes;
              (i == null ? void 0 : i.length) || r(),
                Za.includes(e) ||
                  (console.warn(
                    `The adjust type ${e} is not supported yet, please assign it with 'force', 'grid', or 'circular'.`,
                  ),
                  r());
              const o = {
                center: n.layoutCfg.center,
                nodeSize(t) {
                  return Math.max(t.height, t.width);
                },
                preventOverlap: !0,
                onLayoutEnd() {},
              };
              const a = n.getLayoutBBox(i);
              const s = a.groupNodes;
              const u = a.layoutNodes;
              const c = Object(za.a)(u);
              (o.onLayoutEnd = function () {
                u == null ||
                  u.forEach((t, e) => {
                    let n;
                    let r;
                    let i;
                    const o = t.x - ((n = c[e]) === null || void 0 === n ? void 0 : n.x);
                    const a = t.y - ((r = c[e]) === null || void 0 === r ? void 0 : r.y);
                    (i = s[e]) === null ||
                      void 0 === i ||
                      i.forEach((t) => {
                        (t.x += o), (t.y += a);
                      });
                  }),
                  r();
              }),
                new Va.a(o).layout({ nodes: u });
            });
          }),
          (e.prototype.destroy = function () {
            this.destoryLayoutMethods(),
              (this.destroyed = !0),
              this.graph.set('layout', void 0),
              (this.layoutCfg = void 0),
              (this.layoutType = void 0),
              (this.layoutMethods = void 0),
              (this.graph = null);
          }),
          e
        );
      })(Wa.c);
      const $a = n(52);
      var Qa = function (t, e, n) {
        return (
          n[t] &&
            console.warn(`The graph with the name ${t} exists already, it will be overridden`),
          (n[t] = e(n)),
          n
        );
      };
      const Ja = (function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          n.get('renderer').startsWith('mini') && n.set('context', e.context),
            t.prototype.init.call(n);
          const r = n.get('defaultNode');
          return (
            r || n.set('defaultNode', { type: 'circle' }),
            r.type || ((r.type = 'circle'), n.set('defaultNode', r)),
            (n.destroyed = !1),
            n
          );
        }
        return (
          Object(h.c)(e, t),
          (e.prototype.init = function () {}),
          (e.prototype.emitEvent = function (t) {
            const e = this.get('canvas');
            (t.type = t.type.toLowerCase()), e.registerEventCallback(t);
          }),
          (e.prototype.initLayoutController = function () {
            const t = new Ka(this);
            this.set({ layoutController: t });
          }),
          (e.prototype.initEventController = function () {
            const t = new qa(this);
            if ((this.set({ eventController: t }), !this.get('renderer').startsWith('mini'))) {
              const e = this.get('canvas');
              const n = e.get('el');
              'touchstart touchmove touchend touchcancel'.split(' ').forEach((t) => {
                n.addEventListener(t, e.registerEventCallback.bind(e), !1);
              });
            }
          }),
          (e.prototype.initCanvas = function () {
            let t = this.get('container');
            t !== null &&
              typeof t === 'string' &&
              ((t = document.getElementById(t)), this.set('container', t));
            const e = this.get('renderer');
            if (!t && !e.startsWith('mini')) throw new Error('invalid container');
            const n = this.get('width');
            const r = this.get('height');
            const i = {
              container: t,
              context: this.get('context'),
              width: n,
              height: r,
              renderer: e,
              fitView: this.get('fitView'),
            };
            const o = this.get('pixelRatio');
            o && (i.pixelRatio = o);
            const a = new Fa(i);
            this.set('canvas', a);
          }),
          (e.prototype.initPlugins = function () {
            const t = this;
            Object(za.c)(t.get('plugins'), (e) => {
              !e.destroyed && e.initPlugin && e.initPlugin(t);
            });
          }),
          (e.prototype.toDataURL = function (t, e) {
            const n = this.get('canvas');
            const r = n.getRenderer();
            const i = n.get('el');
            t || (t = 'image/png');
            let o = '';
            if (r === 'svg') {
              const a = i.cloneNode(!0);
              const s = document.implementation.createDocumentType(
                'svg',
                '-//W3C//DTD SVG 1.1//EN',
                'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd',
              );
              const u = document.implementation.createDocument(
                'http://www.w3.org/2000/svg',
                'svg',
                s,
              );
              u.replaceChild(a, u.documentElement);
              const c = new XMLSerializer().serializeToString(u);
              o = `data:image/svg+xml;charset=utf8,${encodeURIComponent(c)}`;
            } else {
              let h = void 0;
              const l = i.getContext('2d');
              const f = this.get('width');
              const d = this.get('height');
              let p = void 0;
              if (e) {
                const g = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
                (h = l.getImageData(0, 0, f * g, d * g)),
                  (p = l.globalCompositeOperation),
                  (l.globalCompositeOperation = 'destination-over'),
                  (l.fillStyle = e),
                  l.fillRect(0, 0, f, d);
              }
              (o = i.toDataURL(t)),
                e &&
                  (l.clearRect(0, 0, f, d),
                  l.putImageData(h, 0, 0),
                  (l.globalCompositeOperation = p));
            }
            return o;
          }),
          (e.prototype.toFullDataURL = function (t, e, n) {
            const r = this.get('group').getCanvasBBox();
            const i = r.height;
            const o = r.width;
            const a = this.get('renderer');
            const s = Object($a.a)('<id="virtual-image"></div>');
            const u = n ? n.backgroundColor : void 0;
            let c = n ? n.padding : void 0;
            c ? Object(za.k)(c) && (c = [c, c, c, c]) : (c = [0, 0, 0, 0]);
            const h = i + c[0] + c[2];
            const l = o + c[1] + c[3];
            const f = new Fa({ container: s, height: h, width: l, quickHit: !0 });
            const d = this.get('group').clone();
            let p = Object(za.a)(d.getMatrix());
            p || (p = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
            const g = (r.maxX + r.minX) / 2;
            const v = (r.maxY + r.minY) / 2;
            Xa.a.translate(p, p, [-g, -v]),
              Xa.a.translate(p, p, [o / 2 + c[3], i / 2 + c[0]]),
              d.resetMatrix(),
              d.setMatrix(p),
              f.add(d);
            const y = f.get('el');
            let m = '';
            e || (e = 'image/png'),
              setTimeout(() => {
                if (a === 'svg') {
                  const n = y.cloneNode(!0);
                  const r = document.implementation.createDocumentType(
                    'svg',
                    '-//W3C//DTD SVG 1.1//EN',
                    'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd',
                  );
                  const i = document.implementation.createDocument(
                    'http://www.w3.org/2000/svg',
                    'svg',
                    r,
                  );
                  i.replaceChild(n, i.documentElement);
                  const o = new XMLSerializer().serializeToString(i);
                  m = `data:image/svg+xml;charset=utf8,${encodeURIComponent(o)}`;
                } else {
                  let s = void 0;
                  const c = y.getContext('2d');
                  let f = void 0;
                  if (u) {
                    const d = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
                    (s = c.getImageData(0, 0, l * d, h * d)),
                      (f = c.globalCompositeOperation),
                      (c.globalCompositeOperation = 'destination-over'),
                      (c.fillStyle = u),
                      c.fillRect(0, 0, l, h);
                  }
                  (m = y.toDataURL(e)),
                    u &&
                      (c.clearRect(0, 0, l, h),
                      c.putImageData(s, 0, 0),
                      (c.globalCompositeOperation = f));
                }
                t && t(m);
              }, 16);
          }),
          (e.prototype.downloadFullImage = function (t, e, n) {
            const r = this;
            const i = this.get('group').getCanvasBBox();
            const o = i.height;
            const a = i.width;
            const s = this.get('renderer');
            const u = Object($a.a)('<id="virtual-image"></div>');
            const c = n ? n.backgroundColor : void 0;
            let h = n ? n.padding : void 0;
            h ? Object(za.k)(h) && (h = [h, h, h, h]) : (h = [0, 0, 0, 0]);
            const l = o + h[0] + h[2];
            const f = a + h[1] + h[3];
            const d = new Fa({ container: u, height: l, width: f });
            const p = this.get('group').clone();
            let g = Object(za.a)(p.getMatrix());
            g || (g = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
            const v = (i.maxX + i.minX) / 2;
            const y = (i.maxY + i.minY) / 2;
            Xa.a.translate(g, g, [-v, -y]),
              Xa.a.translate(g, g, [a / 2 + h[3], o / 2 + h[0]]),
              p.resetMatrix(),
              p.setMatrix(g),
              d.add(p);
            const m = d.get('el');
            e || (e = 'image/png'),
              setTimeout(() => {
                let n = '';
                if (s === 'svg') {
                  const i = m.cloneNode(!0);
                  const o = document.implementation.createDocumentType(
                    'svg',
                    '-//W3C//DTD SVG 1.1//EN',
                    'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd',
                  );
                  const a = document.implementation.createDocument(
                    'http://www.w3.org/2000/svg',
                    'svg',
                    o,
                  );
                  a.replaceChild(i, a.documentElement);
                  const u = new XMLSerializer().serializeToString(a);
                  n = `data:image/svg+xml;charset=utf8,${encodeURIComponent(u)}`;
                } else {
                  let h = void 0;
                  const d = m.getContext('2d');
                  let p = void 0;
                  if (c) {
                    const g = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
                    (h = d.getImageData(0, 0, f * g, l * g)),
                      (p = d.globalCompositeOperation),
                      (d.globalCompositeOperation = 'destination-over'),
                      (d.fillStyle = c),
                      d.fillRect(0, 0, f, l);
                  }
                  (n = m.toDataURL(e)),
                    c &&
                      (d.clearRect(0, 0, f, l),
                      d.putImageData(h, 0, 0),
                      (d.globalCompositeOperation = p));
                }
                const v = document.createElement('a');
                const y = (t || 'graph') + (s === 'svg' ? '.svg' : `.${e.split('/')[1]}`);
                r.dataURLToImage(n, s, v, y);
                const b = document.createEvent('MouseEvents');
                b.initEvent('click', !1, !1), v.dispatchEvent(b);
              }, 16);
          }),
          (e.prototype.downloadImage = function (t, e, n) {
            const r = this;
            const i = this;
            i.isAnimating() && i.stopAnimate();
            const o = i.get('canvas').getRenderer();
            e || (e = 'image/png');
            const a = (t || 'graph') + (o === 'svg' ? '.svg' : e.split('/')[1]);
            const s = document.createElement('a');
            setTimeout(() => {
              const t = i.toDataURL(e, n);
              r.dataURLToImage(t, o, s, a);
              const u = document.createEvent('MouseEvents');
              u.initEvent('click', !1, !1), s.dispatchEvent(u);
            }, 16);
          }),
          (e.prototype.dataURLToImage = function (t, e, n, r) {
            if (typeof window !== 'undefined')
              if (window.Blob && window.URL && e !== 'svg') {
                const i = t.split(',');
                let o = '';
                if (i && i.length > 0) {
                  const a = i[0].match(/:(.*?);/);
                  a && a.length >= 2 && (o = a[1]);
                }
                for (var s = atob(i[1]), u = s.length, c = new Uint8Array(u); u--; )
                  c[u] = s.charCodeAt(u);
                const h = new Blob([c], { type: o });
                window.navigator.msSaveBlob
                  ? window.navigator.msSaveBlob(h, r)
                  : n.addEventListener('click', () => {
                      (n.download = r), (n.href = window.URL.createObjectURL(h));
                    });
              } else
                n.addEventListener('click', () => {
                  (n.download = r), (n.href = t);
                });
          }),
          (e.prototype.addPlugin = function (t) {
            t.destroyed || (this.get('plugins').push(t), t.initPlugin(this));
          }),
          (e.prototype.removePlugin = function (t) {
            const e = this.get('plugins');
            const n = e.indexOf(t);
            n >= 0 && (t.destroyPlugin(), e.splice(n, 1));
          }),
          (e.prototype.isMiniNative = function () {
            return this.get('renderer') === 'mini-native';
          }),
          (e.prototype.isMini = function () {
            return this.get('renderer').startsWith('mini');
          }),
          (e.prototype.isBrowser = function () {
            return this.get('renderer') === 'canvas';
          }),
          (e.prototype.setImageWaterMarker = function (t, e, n) {
            const r = this;
            const i = Object(za.b)({}, Ga.a.imageWaterMarkerConfig, e);
            const o = i.width;
            const a = i.height;
            const s = i.image;
            const u = s.rotate;
            const c = (s.x, s.y, s.width);
            const h = s.height;
            if ((this.isMini() && this.isMiniNative(), this.isMiniNative())) {
              (n.width = o || this.get('width')), (n.height = a || this.get('height'));
              const l = n.getContext('2d');
              const f = (0, this.get('extra').createImage)();
              (f.crossOrigin = 'anonymous'),
                (f.src = t),
                (f.onload = function () {
                  const t = c / f.width;
                  const e = h / f.height;
                  l.rotate((-u * Math.PI) / 180);
                  const i = l.createPattern(f, 'repeat');
                  (l.fillStyle = i),
                    l.scale(t, e),
                    l.fillRect(
                      2 * -r.get('width'),
                      -r.get('height'),
                      10 * r.get('width'),
                      10 * r.get('height'),
                    ),
                    r.get('waterGroup').addShape('image', { attrs: { img: n } });
                });
            }
            if (this.isBrowser()) {
              const d = document.createElement('canvas');
              (d.width = o || this.get('width')), (d.height = a || this.get('height'));
              const p = d.getContext('2d');
              const g = new Image();
              (g.crossOrigin = 'anonymous'),
                (g.src = t),
                (g.onload = function () {
                  const t = c / g.width;
                  const e = h / g.height;
                  p.rotate((-u * Math.PI) / 180);
                  const n = p.createPattern(g, 'repeat');
                  (p.fillStyle = n),
                    p.scale(t, e),
                    p.fillRect(
                      2 * -r.get('width'),
                      -r.get('height'),
                      10 * r.get('width'),
                      10 * r.get('height'),
                    );
                  const i = d.toDataURL();
                  r.get('waterGroup').addShape('image', { attrs: { img: i } });
                });
            }
          }),
          (e.prototype.setTextWaterMarker = function (t, e) {
            let n = this.get('container');
            Object(za.o)(n) && (n = document.getElementById(n)),
              n.style.position || (n.style.position = 'relative');
            let r = this.get('graphWaterMarker');
            const i = Object(za.b)({}, Ga.a.textWaterMarkerConfig, e);
            const o = i.width;
            const a = i.height;
            const s = i.compatible;
            const u = i.text;
            if (!r) {
              const c = { container: n, width: o, height: a, capture: !1 };
              const h = this.get('pixelRatio');
              h && (c.pixelRatio = h), (r = new Fa(c)), this.set('graphWaterMarker', r);
            }
            r.get('el').style.display = 'none';
            const l = r.get('context');
            const f = u.rotate;
            const d = u.fill;
            const p = u.fontFamily;
            const g = u.fontSize;
            const v = u.baseline;
            const y = u.x;
            const m = u.y;
            const b = u.lineHeight;
            l.rotate((-f * Math.PI) / 180),
              (l.font = `${g}px ${p}`),
              (l.fillStyle = d),
              (l.textBaseline = v);
            for (let x = t.length - 1; x >= 0; x--) l.fillText(t[x], y, m + x * b);
            if ((l.rotate((f * Math.PI) / 180), s))
              n.style.cssText = `background-image: url(${r
                .get('el')
                .toDataURL('image/png')});background-repeat:repeat;`;
            else {
              let M = document.querySelector('.g6-graph-watermarker');
              M || ((M = document.createElement('div')).className = 'g6-graph-watermarker'),
                (M.style.cssText = `background-image: url(${r
                  .get('el')
                  .toDataURL(
                    'image/png',
                  )});background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:99;`),
                n.appendChild(M);
            }
          }),
          (e.prototype.destroy = function () {
            Object(za.c)(this.get('plugins'), (t) => {
              t.destroyPlugin();
            });
            const e = this.get('tooltips');
            if (e)
              for (let n = 0; n < e.length; n++) {
                const r = e[n];
                if (r) {
                  const i = r.parentElement;
                  i && i.removeChild(r);
                }
              }
            this.get('eventController').destroy(),
              this.get('layoutController').destroy(),
              this.get('graphWaterMarker') && this.get('graphWaterMarker').destroy(),
              document.querySelector('.g6-graph-watermarker') &&
                document.querySelector('.g6-graph-watermarker').remove(),
              t.prototype.destroy.call(this);
          }),
          (e.prototype.initGroups = function () {
            const t = this.get('canvas');
            const e = t.addGroup({ id: 'root', className: Ga.a.rootContainerClassName });
            const n = t.addGroup({ id: 'water', className: Ga.a.waterContainerClassName });
            if (this.get('groupByTypes')) {
              const r = e.addGroup({ id: 'edge', className: Ga.a.edgeContainerClassName });
              const i = e.addGroup({ id: 'node', className: Ga.a.nodeContainerClassName });
              const o = e.addGroup({ id: 'combo', className: Ga.a.comboContainerClassName });
              o.toBack(), this.set({ nodeGroup: i, edgeGroup: r, comboGroup: o });
            }
            const a = t.addGroup({ id: 'uiGroup', className: Ga.a.uiContainerClassName });
            const s = e.addGroup({ id: 'delegate', className: Ga.a.delegateContainerClassName });
            this.set({ delegateGroup: s }),
              this.set('group', e),
              this.set('uiGroup', a),
              this.set('waterGroup', n);
          }),
          e
        );
      })(Wa.b);
      e.a = Ja;
    },
    function (t, e, n) {
      'use strict';
      n.r(e),
        n.d(e, 'mixColor', () => {
          return _;
        }),
        n.d(e, 'getColorsWithSubjectColor', () => {
          return B;
        }),
        n.d(e, 'getColorSetsBySubjectColors', () => {
          return L;
        });
      const r = n(53);
      const i = n.n(r);
      function o(t, e) {
        (function (t) {
          return typeof t === 'string' && t.indexOf('.') !== -1 && parseFloat(t) === 1;
        })(t) && (t = '100%');
        const n = (function (t) {
          return typeof t === 'string' && t.indexOf('%') !== -1;
        })(t);
        return (
          (t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t)))),
          n && (t = parseInt(String(t * e), 10) / 100),
          Math.abs(t - e) < 1e-6
            ? 1
            : (t =
                e === 360
                  ? (t < 0 ? (t % e) + e : t % e) / parseFloat(String(e))
                  : (t % e) / parseFloat(String(e)))
        );
      }
      function a(t) {
        return Math.min(1, Math.max(0, t));
      }
      function s(t) {
        return (t = parseFloat(t)), (isNaN(t) || t < 0 || t > 1) && (t = 1), t;
      }
      function u(t) {
        return t <= 1 ? `${100 * Number(t)}%` : t;
      }
      function c(t) {
        return t.length === 1 ? `0${t}` : String(t);
      }
      function h(t, e, n) {
        (t = o(t, 255)), (e = o(e, 255)), (n = o(n, 255));
        const r = Math.max(t, e, n);
        const i = Math.min(t, e, n);
        let a = 0;
        let s = 0;
        const u = (r + i) / 2;
        if (r === i) (s = 0), (a = 0);
        else {
          const c = r - i;
          switch (((s = u > 0.5 ? c / (2 - r - i) : c / (r + i)), r)) {
            case t:
              a = (e - n) / c + (e < n ? 6 : 0);
              break;
            case e:
              a = (n - t) / c + 2;
              break;
            case n:
              a = (t - e) / c + 4;
          }
          a /= 6;
        }
        return { h: a, s, l: u };
      }
      function l(t, e, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? t + 6 * n * (e - t)
            : n < 0.5
            ? e
            : n < 2 / 3
            ? t + (e - t) * (2 / 3 - n) * 6
            : t
        );
      }
      function f(t, e, n) {
        (t = o(t, 255)), (e = o(e, 255)), (n = o(n, 255));
        const r = Math.max(t, e, n);
        const i = Math.min(t, e, n);
        let a = 0;
        const s = r;
        const u = r - i;
        const c = r === 0 ? 0 : u / r;
        if (r === i) a = 0;
        else {
          switch (r) {
            case t:
              a = (e - n) / u + (e < n ? 6 : 0);
              break;
            case e:
              a = (n - t) / u + 2;
              break;
            case n:
              a = (t - e) / u + 4;
          }
          a /= 6;
        }
        return { h: a, s: c, v: s };
      }
      function d(t, e, n, r) {
        const i = [
          c(Math.round(t).toString(16)),
          c(Math.round(e).toString(16)),
          c(Math.round(n).toString(16)),
        ];
        return r &&
          i[0].startsWith(i[0].charAt(1)) &&
          i[1].startsWith(i[1].charAt(1)) &&
          i[2].startsWith(i[2].charAt(1))
          ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0)
          : i.join('');
      }
      function p(t) {
        return Math.round(255 * parseFloat(t)).toString(16);
      }
      function g(t) {
        return v(t) / 255;
      }
      function v(t) {
        return parseInt(t, 16);
      }
      const y = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        goldenrod: '#daa520',
        gold: '#ffd700',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavenderblush: '#fff0f5',
        lavender: '#e6e6fa',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32',
      };
      function m(t) {
        return (m =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      function b(t) {
        let e;
        let n;
        let r;
        let i = { r: 0, g: 0, b: 0 };
        let a = 1;
        let c = null;
        let h = null;
        let f = null;
        let d = !1;
        let p = !1;
        return (
          typeof t === 'string' &&
            (t = (function (t) {
              if ((t = t.trim().toLowerCase()).length === 0) return !1;
              let e = !1;
              if (y[t]) (t = y[t]), (e = !0);
              else if (t === 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name' };
              let n = w.rgb.exec(t);
              if (n) return { r: n[1], g: n[2], b: n[3] };
              if ((n = w.rgba.exec(t))) return { r: n[1], g: n[2], b: n[3], a: n[4] };
              if ((n = w.hsl.exec(t))) return { h: n[1], s: n[2], l: n[3] };
              if ((n = w.hsla.exec(t))) return { h: n[1], s: n[2], l: n[3], a: n[4] };
              if ((n = w.hsv.exec(t))) return { h: n[1], s: n[2], v: n[3] };
              if ((n = w.hsva.exec(t))) return { h: n[1], s: n[2], v: n[3], a: n[4] };
              if ((n = w.hex8.exec(t)))
                return {
                  r: v(n[1]),
                  g: v(n[2]),
                  b: v(n[3]),
                  a: g(n[4]),
                  format: e ? 'name' : 'hex8',
                };
              if ((n = w.hex6.exec(t)))
                return { r: v(n[1]), g: v(n[2]), b: v(n[3]), format: e ? 'name' : 'hex' };
              if ((n = w.hex4.exec(t)))
                return {
                  r: v(n[1] + n[1]),
                  g: v(n[2] + n[2]),
                  b: v(n[3] + n[3]),
                  a: g(n[4] + n[4]),
                  format: e ? 'name' : 'hex8',
                };
              if ((n = w.hex3.exec(t)))
                return {
                  r: v(n[1] + n[1]),
                  g: v(n[2] + n[2]),
                  b: v(n[3] + n[3]),
                  format: e ? 'name' : 'hex',
                };
              return !1;
            })(t)),
          m(t) === 'object' &&
            (O(t.r) && O(t.g) && O(t.b)
              ? ((e = t.r),
                (n = t.g),
                (r = t.b),
                (i = { r: 255 * o(e, 255), g: 255 * o(n, 255), b: 255 * o(r, 255) }),
                (d = !0),
                (p = String(t.r).substr(-1) === '%' ? 'prgb' : 'rgb'))
              : O(t.h) && O(t.s) && O(t.v)
              ? ((c = u(t.s)),
                (h = u(t.v)),
                (i = (function (t, e, n) {
                  (t = 6 * o(t, 360)), (e = o(e, 100)), (n = o(n, 100));
                  const r = Math.floor(t);
                  const i = t - r;
                  const a = n * (1 - e);
                  const s = n * (1 - i * e);
                  const u = n * (1 - (1 - i) * e);
                  const c = r % 6;
                  return {
                    r: 255 * [n, s, a, a, u, n][c],
                    g: 255 * [u, n, n, s, a, a][c],
                    b: 255 * [a, a, u, n, n, s][c],
                  };
                })(t.h, c, h)),
                (d = !0),
                (p = 'hsv'))
              : O(t.h) &&
                O(t.s) &&
                O(t.l) &&
                ((c = u(t.s)),
                (f = u(t.l)),
                (i = (function (t, e, n) {
                  let r;
                  let i;
                  let a;
                  if (((t = o(t, 360)), (e = o(e, 100)), (n = o(n, 100)), e === 0))
                    (i = n), (a = n), (r = n);
                  else {
                    const s = n < 0.5 ? n * (1 + e) : n + e - n * e;
                    const u = 2 * n - s;
                    (r = l(u, s, t + 1 / 3)), (i = l(u, s, t)), (a = l(u, s, t - 1 / 3));
                  }
                  return { r: 255 * r, g: 255 * i, b: 255 * a };
                })(t.h, c, f)),
                (d = !0),
                (p = 'hsl')),
            Object.prototype.hasOwnProperty.call(t, 'a') && (a = t.a)),
          (a = s(a)),
          {
            ok: d,
            format: t.format || p,
            r: Math.min(255, Math.max(i.r, 0)),
            g: Math.min(255, Math.max(i.g, 0)),
            b: Math.min(255, Math.max(i.b, 0)),
            a,
          }
        );
      }
      const x = '(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)';
      const M = `[\\s|\\(]+(${x})[,|\\s]+(${x})[,|\\s]+(${x})\\s*\\)?`;
      const S = `[\\s|\\(]+(${x})[,|\\s]+(${x})[,|\\s]+(${x})[,|\\s]+(${x})\\s*\\)?`;
      var w = {
        CSS_UNIT: new RegExp(x),
        rgb: new RegExp(`rgb${M}`),
        rgba: new RegExp(`rgba${S}`),
        hsl: new RegExp(`hsl${M}`),
        hsla: new RegExp(`hsla${S}`),
        hsv: new RegExp(`hsv${M}`),
        hsva: new RegExp(`hsva${S}`),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      };
      function O(t) {
        return Boolean(w.CSS_UNIT.exec(String(t)));
      }
      const C = (function () {
        function t(e, n) {
          let r;
          if ((void 0 === e && (e = ''), void 0 === n && (n = {}), e instanceof t)) return e;
          typeof e === 'number' &&
            (e = (function (t) {
              return { r: t >> 16, g: (65280 & t) >> 8, b: 255 & t };
            })(e)),
            (this.originalInput = e);
          const i = b(e);
          (this.originalInput = e),
            (this.r = i.r),
            (this.g = i.g),
            (this.b = i.b),
            (this.a = i.a),
            (this.roundA = Math.round(100 * this.a) / 100),
            (this.format = (r = n.format) !== null && void 0 !== r ? r : i.format),
            (this.gradientType = n.gradientType),
            this.r < 1 && (this.r = Math.round(this.r)),
            this.g < 1 && (this.g = Math.round(this.g)),
            this.b < 1 && (this.b = Math.round(this.b)),
            (this.isValid = i.ok);
        }
        return (
          (t.prototype.isDark = function () {
            return this.getBrightness() < 128;
          }),
          (t.prototype.isLight = function () {
            return !this.isDark();
          }),
          (t.prototype.getBrightness = function () {
            const t = this.toRgb();
            return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3;
          }),
          (t.prototype.getLuminance = function () {
            const t = this.toRgb();
            const e = t.r / 255;
            const n = t.g / 255;
            const r = t.b / 255;
            return (
              0.2126 * (e <= 0.03928 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4)) +
              0.7152 * (n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4)) +
              0.0722 * (r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4))
            );
          }),
          (t.prototype.getAlpha = function () {
            return this.a;
          }),
          (t.prototype.setAlpha = function (t) {
            return (this.a = s(t)), (this.roundA = Math.round(100 * this.a) / 100), this;
          }),
          (t.prototype.toHsv = function () {
            const t = f(this.r, this.g, this.b);
            return { h: 360 * t.h, s: t.s, v: t.v, a: this.a };
          }),
          (t.prototype.toHsvString = function () {
            const t = f(this.r, this.g, this.b);
            const e = Math.round(360 * t.h);
            const n = Math.round(100 * t.s);
            const r = Math.round(100 * t.v);
            return this.a === 1
              ? `hsv(${e}, ${n}%, ${r}%)`
              : `hsva(${e}, ${n}%, ${r}%, ${this.roundA})`;
          }),
          (t.prototype.toHsl = function () {
            const t = h(this.r, this.g, this.b);
            return { h: 360 * t.h, s: t.s, l: t.l, a: this.a };
          }),
          (t.prototype.toHslString = function () {
            const t = h(this.r, this.g, this.b);
            const e = Math.round(360 * t.h);
            const n = Math.round(100 * t.s);
            const r = Math.round(100 * t.l);
            return this.a === 1
              ? `hsl(${e}, ${n}%, ${r}%)`
              : `hsla(${e}, ${n}%, ${r}%, ${this.roundA})`;
          }),
          (t.prototype.toHex = function (t) {
            return void 0 === t && (t = !1), d(this.r, this.g, this.b, t);
          }),
          (t.prototype.toHexString = function (t) {
            return void 0 === t && (t = !1), `#${this.toHex(t)}`;
          }),
          (t.prototype.toHex8 = function (t) {
            return (
              void 0 === t && (t = !1),
              (function (t, e, n, r, i) {
                const o = [
                  c(Math.round(t).toString(16)),
                  c(Math.round(e).toString(16)),
                  c(Math.round(n).toString(16)),
                  c(p(r)),
                ];
                return i &&
                  o[0].startsWith(o[0].charAt(1)) &&
                  o[1].startsWith(o[1].charAt(1)) &&
                  o[2].startsWith(o[2].charAt(1)) &&
                  o[3].startsWith(o[3].charAt(1))
                  ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0)
                  : o.join('');
              })(this.r, this.g, this.b, this.a, t)
            );
          }),
          (t.prototype.toHex8String = function (t) {
            return void 0 === t && (t = !1), `#${this.toHex8(t)}`;
          }),
          (t.prototype.toRgb = function () {
            return {
              r: Math.round(this.r),
              g: Math.round(this.g),
              b: Math.round(this.b),
              a: this.a,
            };
          }),
          (t.prototype.toRgbString = function () {
            const t = Math.round(this.r);
            const e = Math.round(this.g);
            const n = Math.round(this.b);
            return this.a === 1
              ? `rgb(${t}, ${e}, ${n})`
              : `rgba(${t}, ${e}, ${n}, ${this.roundA})`;
          }),
          (t.prototype.toPercentageRgb = function () {
            const t = function (t) {
              return `${Math.round(100 * o(t, 255))}%`;
            };
            return { r: t(this.r), g: t(this.g), b: t(this.b), a: this.a };
          }),
          (t.prototype.toPercentageRgbString = function () {
            const t = function (t) {
              return Math.round(100 * o(t, 255));
            };
            return this.a === 1
              ? `rgb(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%)`
              : `rgba(${t(this.r)}%, ${t(this.g)}%, ${t(this.b)}%, ${this.roundA})`;
          }),
          (t.prototype.toName = function () {
            if (this.a === 0) return 'transparent';
            if (this.a < 1) return !1;
            for (
              let t = `#${d(this.r, this.g, this.b, !1)}`, e = 0, n = Object.entries(y);
              e < n.length;
              e++
            ) {
              const r = n[e];
              const i = r[0];
              if (t === r[1]) return i;
            }
            return !1;
          }),
          (t.prototype.toString = function (t) {
            const e = Boolean(t);
            t = t != null ? t : this.format;
            let n = !1;
            const r = this.a < 1 && this.a >= 0;
            return e || !r || (!t.startsWith('hex') && t !== 'name')
              ? (t === 'rgb' && (n = this.toRgbString()),
                t === 'prgb' && (n = this.toPercentageRgbString()),
                (t !== 'hex' && t !== 'hex6') || (n = this.toHexString()),
                t === 'hex3' && (n = this.toHexString(!0)),
                t === 'hex4' && (n = this.toHex8String(!0)),
                t === 'hex8' && (n = this.toHex8String()),
                t === 'name' && (n = this.toName()),
                t === 'hsl' && (n = this.toHslString()),
                t === 'hsv' && (n = this.toHsvString()),
                n || this.toHexString())
              : t === 'name' && this.a === 0
              ? this.toName()
              : this.toRgbString();
          }),
          (t.prototype.toNumber = function () {
            return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
          }),
          (t.prototype.clone = function () {
            return new t(this.toString());
          }),
          (t.prototype.lighten = function (e) {
            void 0 === e && (e = 10);
            const n = this.toHsl();
            return (n.l += e / 100), (n.l = a(n.l)), new t(n);
          }),
          (t.prototype.brighten = function (e) {
            void 0 === e && (e = 10);
            const n = this.toRgb();
            return (
              (n.r = Math.max(0, Math.min(255, n.r - Math.round((-e / 100) * 255)))),
              (n.g = Math.max(0, Math.min(255, n.g - Math.round((-e / 100) * 255)))),
              (n.b = Math.max(0, Math.min(255, n.b - Math.round((-e / 100) * 255)))),
              new t(n)
            );
          }),
          (t.prototype.darken = function (e) {
            void 0 === e && (e = 10);
            const n = this.toHsl();
            return (n.l -= e / 100), (n.l = a(n.l)), new t(n);
          }),
          (t.prototype.tint = function (t) {
            return void 0 === t && (t = 10), this.mix('white', t);
          }),
          (t.prototype.shade = function (t) {
            return void 0 === t && (t = 10), this.mix('black', t);
          }),
          (t.prototype.desaturate = function (e) {
            void 0 === e && (e = 10);
            const n = this.toHsl();
            return (n.s -= e / 100), (n.s = a(n.s)), new t(n);
          }),
          (t.prototype.saturate = function (e) {
            void 0 === e && (e = 10);
            const n = this.toHsl();
            return (n.s += e / 100), (n.s = a(n.s)), new t(n);
          }),
          (t.prototype.greyscale = function () {
            return this.desaturate(100);
          }),
          (t.prototype.spin = function (e) {
            const n = this.toHsl();
            const r = (n.h + e) % 360;
            return (n.h = r < 0 ? 360 + r : r), new t(n);
          }),
          (t.prototype.mix = function (e, n) {
            void 0 === n && (n = 50);
            const r = this.toRgb();
            const i = new t(e).toRgb();
            const o = n / 100;
            return new t({
              r: (i.r - r.r) * o + r.r,
              g: (i.g - r.g) * o + r.g,
              b: (i.b - r.b) * o + r.b,
              a: (i.a - r.a) * o + r.a,
            });
          }),
          (t.prototype.analogous = function (e, n) {
            void 0 === e && (e = 6), void 0 === n && (n = 30);
            const r = this.toHsl();
            const i = 360 / n;
            const o = [this];
            for (r.h = (r.h - ((i * e) >> 1) + 720) % 360; --e; )
              (r.h = (r.h + i) % 360), o.push(new t(r));
            return o;
          }),
          (t.prototype.complement = function () {
            const e = this.toHsl();
            return (e.h = (e.h + 180) % 360), new t(e);
          }),
          (t.prototype.monochromatic = function (e) {
            void 0 === e && (e = 6);
            for (var n = this.toHsv(), r = n.h, i = n.s, o = n.v, a = [], s = 1 / e; e--; )
              a.push(new t({ h: r, s: i, v: o })), (o = (o + s) % 1);
            return a;
          }),
          (t.prototype.splitcomplement = function () {
            const e = this.toHsl();
            const n = e.h;
            return [
              this,
              new t({ h: (n + 72) % 360, s: e.s, l: e.l }),
              new t({ h: (n + 216) % 360, s: e.s, l: e.l }),
            ];
          }),
          (t.prototype.onBackground = function (e) {
            const n = this.toRgb();
            const r = new t(e).toRgb();
            return new t({
              r: r.r + (n.r - r.r) * n.a,
              g: r.g + (n.g - r.g) * n.a,
              b: r.b + (n.b - r.b) * n.a,
            });
          }),
          (t.prototype.triad = function () {
            return this.polyad(3);
          }),
          (t.prototype.tetrad = function () {
            return this.polyad(4);
          }),
          (t.prototype.polyad = function (e) {
            for (var n = this.toHsl(), r = n.h, i = [this], o = 360 / e, a = 1; a < e; a++)
              i.push(new t({ h: (r + a * o) % 360, s: n.s, l: n.l }));
            return i;
          }),
          (t.prototype.equals = function (e) {
            return this.toRgbString() === new t(e).toRgbString();
          }),
          t
        );
      })();
      const E = [
        { index: 7, opacity: 0.15 },
        { index: 6, opacity: 0.25 },
        { index: 5, opacity: 0.3 },
        { index: 5, opacity: 0.45 },
        { index: 5, opacity: 0.65 },
        { index: 5, opacity: 0.85 },
        { index: 4, opacity: 0.9 },
        { index: 3, opacity: 0.95 },
        { index: 2, opacity: 0.97 },
        { index: 1, opacity: 0.98 },
      ];
      function k(t, e, n) {
        let r;
        return (
          (r =
            Math.round(t.h) >= 60 && Math.round(t.h) <= 240
              ? n
                ? Math.round(t.h) - 2 * e
                : Math.round(t.h) + 2 * e
              : n
              ? Math.round(t.h) + 2 * e
              : Math.round(t.h) - 2 * e) < 0
            ? (r += 360)
            : r >= 360 && (r -= 360),
          r
        );
      }
      function T(t, e, n) {
        return t.h === 0 && t.s === 0
          ? t.s
          : ((r = n ? t.s - 0.16 * e : e === 4 ? t.s + 0.16 : t.s + 0.05 * e) > 1 && (r = 1),
            n && e === 5 && r > 0.1 && (r = 0.1),
            r < 0.06 && (r = 0.06),
            Number(r.toFixed(2)));
        let r;
      }
      function P(t, e, n) {
        let r;
        return (r = n ? t.v + 0.05 * e : t.v - 0.15 * e) > 1 && (r = 1), Number(r.toFixed(2));
      }
      function I(t) {
        for (
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = [],
            r = new C(t),
            i = 5;
          i > 0;
          i -= 1
        ) {
          const o = r.toHsv();
          const a = new C({ h: k(o, i, !0), s: T(o, i, !0), v: P(o, i, !0) }).toHexString();
          n.push(a);
        }
        n.push(r.toHexString());
        for (let s = 1; s <= 4; s += 1) {
          const u = r.toHsv();
          const c = new C({ h: k(u, s), s: T(u, s), v: P(u, s) }).toHexString();
          n.push(c);
        }
        return e.theme === 'dark'
          ? E.map((t) => {
              const r = t.index;
              const i = t.opacity;
              return new C(e.backgroundColor || '#141414').mix(n[r], 100 * i).toHexString();
            })
          : n;
      }
      const A = {
        red: '#F5222D',
        volcano: '#FA541C',
        orange: '#FA8C16',
        gold: '#FAAD14',
        yellow: '#FADB14',
        lime: '#A0D911',
        green: '#52C41A',
        cyan: '#13C2C2',
        blue: '#1890FF',
        geekblue: '#2F54EB',
        purple: '#722ED1',
        magenta: '#EB2F96',
        grey: '#666666',
      };
      const j = {};
      const N = {};
      Object.keys(A).forEach((t) => {
        (j[t] = I(A[t])),
          (j[t].primary = j[t][5]),
          (N[t] = I(A[t], { theme: 'dark', backgroundColor: '#141414' })),
          (N[t].primary = N[t][5]);
      });
      j.red,
        j.volcano,
        j.gold,
        j.orange,
        j.yellow,
        j.lime,
        j.green,
        j.cyan,
        j.blue,
        j.geekblue,
        j.purple,
        j.magenta,
        j.grey;
      var _ = function (t, e, n) {
        const r = i()(t);
        const o = i()(e);
        return i()([
          (1 - n) * r.red() + n * o.red(),
          (1 - n) * r.green() + n * o.green(),
          (1 - n) * r.blue() + n * o.blue(),
        ]).rgb();
      };
      var B = function (t, e, n, r) {
        return (
          void 0 === e && (e = '#fff'),
          void 0 === n && (n = 'default'),
          void 0 === r && (r = 'rgb(150, 150, 150)'),
          n === 'default'
            ? (function (t, e, n) {
                void 0 === e && (e = '#fff'), void 0 === n && (n = 'rgb(150, 150, 150)');
                const r = _(e, t, 0.05).rgb().toString();
                const o = _(e, t, 0.1).rgb().toString();
                const a = _(e, t, 0.2).rgb().toString();
                const s = _(e, t, 0.4).rgb().toString();
                const u = _(e, n, 0.02).rgb().toString();
                const c = _(e, n, 0.05).rgb().toString();
                const h = _(e, n, 0.1).rgb().toString();
                const l = _(e, n, 0.2).rgb().toString();
                const f = _(e, n, 0.3).rgb().toString();
                const d = I(t, { theme: 'default', backgroundColor: e });
                const p = i()(t).hex().toLowerCase();
                const g = d.indexOf(p);
                let v = t;
                return (
                  g !== -1 && (v = d[g + 1]),
                  {
                    mainStroke: t,
                    mainFill: o,
                    activeStroke: t,
                    activeFill: r,
                    inactiveStroke: s,
                    inactiveFill: r,
                    selectedStroke: t,
                    selectedFill: e,
                    highlightStroke: v,
                    highlightFill: a,
                    disableStroke: f,
                    disableFill: c,
                    edgeMainStroke: f,
                    edgeActiveStroke: t,
                    edgeInactiveStroke: l,
                    edgeSelectedStroke: t,
                    edgeHighlightStroke: t,
                    edgeDisableStroke: h,
                    comboMainStroke: f,
                    comboMainFill: u,
                    comboActiveStroke: t,
                    comboActiveFill: r,
                    comboInactiveStroke: f,
                    comboInactiveFill: u,
                    comboSelectedStroke: t,
                    comboSelectedFill: u,
                    comboHighlightStroke: v,
                    comboHighlightFill: u,
                    comboDisableStroke: l,
                    comboDisableFill: c,
                  }
                );
              })(t, e, 'rgb(150, 150, 150)')
            : (function (t, e, n) {
                void 0 === e && (e = '#fff'), void 0 === n && (n = '#777');
                const r = _(e, t, 0.2).rgb().toString();
                const o = _(e, t, 0.3).rgb().toString();
                const a = _(e, t, 0.6).rgb().toString();
                const s = _(e, t, 0.8).rgb().toString();
                const u = _(e, n, 0.2).rgb().toString();
                const c = _(e, n, 0.25).rgb().toString();
                const h = _(e, n, 0.3).rgb().toString();
                const l = _(e, n, 0.4).rgb().toString();
                const f = _(e, n, 0.5).rgb().toString();
                const d = I(t, { theme: 'dark', backgroundColor: e });
                const p = i()(t).hex().toLowerCase();
                const g = d.indexOf(p);
                let v = t;
                return (
                  g !== -1 && (v = d[g + 1]),
                  {
                    mainStroke: s,
                    mainFill: r,
                    activeStroke: t,
                    activeFill: o,
                    inactiveStroke: s,
                    inactiveFill: r,
                    selectedStroke: t,
                    selectedFill: r,
                    highlightStroke: t,
                    highlightFill: a,
                    disableStroke: f,
                    disableFill: c,
                    edgeMainStroke: n,
                    edgeActiveStroke: t,
                    edgeInactiveStroke: n,
                    edgeSelectedStroke: t,
                    edgeHighlightStroke: t,
                    edgeDisableStroke: h,
                    comboMainStroke: l,
                    comboMainFill: c,
                    comboActiveStroke: t,
                    comboActiveFill: u,
                    comboInactiveStroke: l,
                    comboInactiveFill: c,
                    comboSelectedStroke: t,
                    comboSelectedFill: u,
                    comboHighlightStroke: v,
                    comboHighlightFill: c,
                    comboDisableStroke: l,
                    comboDisableFill: u,
                  }
                );
              })(t, e, '#777')
        );
      };
      var L = function (t, e, n, r) {
        void 0 === e && (e = '#fff'),
          void 0 === n && (n = 'default'),
          void 0 === r && (r = 'rgb(150, 150, 150)');
        const i = [];
        return (
          t.forEach((t) => {
            i.push(B(t, e, n, r));
          }),
          i
        );
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = u(n(54));
      const i = n(18);
      const o = n(26);
      const a = n(35);
      const s = u(n(130));
      function u(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class c extends r.default {
        constructor() {
          super(...arguments), (this.pX = null), (this.pY = null);
        }

        getTouchAction() {
          const {
            options: { direction: t },
          } = this;
          const e = [];
          return (
            t & i.DIRECTION_HORIZONTAL && e.push(a.TOUCH_ACTION_PAN_Y),
            t & i.DIRECTION_VERTICAL && e.push(a.TOUCH_ACTION_PAN_X),
            e
          );
        }

        directionTest(t) {
          const { options: e } = this;
          let n = !0;
          let { distance: r } = t;
          let { direction: o } = t;
          const a = t.deltaX;
          const s = t.deltaY;
          return (
            o & e.direction ||
              (e.direction & i.DIRECTION_HORIZONTAL
                ? ((o = a === 0 ? i.DIRECTION_NONE : a < 0 ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT),
                  (n = a !== this.pX),
                  (r = Math.abs(t.deltaX)))
                : ((o = s === 0 ? i.DIRECTION_NONE : s < 0 ? i.DIRECTION_UP : i.DIRECTION_DOWN),
                  (n = s !== this.pY),
                  (r = Math.abs(t.deltaY)))),
            (t.direction = o),
            n && r > e.threshold && o & e.direction
          );
        }

        attrTest(t) {
          return (
            r.default.prototype.attrTest.call(this, t) &&
            (this.state & o.STATE_BEGAN || (!(this.state & o.STATE_BEGAN) && this.directionTest(t)))
          );
        }

        emit(t) {
          (this.pX = t.deltaX), (this.pY = t.deltaY);
          const e = (0, s.default)(t.direction);
          e && (t.additionalEvent = this.options.event + e), super.emit(t);
        }
      }
      (e.default = c),
        (c.prototype.defaults = {
          event: 'pan',
          threshold: 10,
          pointers: 1,
          direction: i.DIRECTION_ALL,
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          n || (n = r.PROPS_XY);
          const i = e[n[0]] - t[n[0]];
          const o = e[n[1]] - t[n[1]];
          return Math.sqrt(i * i + o * o);
        });
      var r = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          for (; t; ) {
            if (t === e) return !0;
            t = t.parentNode;
          }
          return !1;
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      let r;
      const i = (r = n(66)) && r.__esModule ? r : { default: r };
      const o = n(143);
      e.default = class {
        constructor(t, e) {
          const n = this;
          (this.manager = t),
            (this.callback = e),
            (this.eventHandler = function (e) {
              (0, i.default)(t.options.enable, [t]) && n.handler(e);
            }),
            this.init();
        }

        handler() {}

        init() {
          (0, o.addManagerListeners)(this.manager, this.events || '', this.eventHandler);
        }

        destroy() {
          removeManagerListeners(this.manager, this.events || '', this.eventHandler);
        }
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.Layouts = e.Layout = void 0);
      const r = n(63);
      const i = (function () {
        function t(t) {
          const e = r.getLayoutByName(t.type);
          this.layoutInstance = new e(t);
        }
        return (
          (t.prototype.layout = function (t) {
            return this.layoutInstance.layout(t);
          }),
          (t.prototype.updateCfg = function (t) {
            this.layoutInstance.updateCfg(t);
          }),
          (t.prototype.init = function (t) {
            this.layoutInstance.init(t);
          }),
          (t.prototype.execute = function () {
            this.layoutInstance.execute();
          }),
          (t.prototype.getDefaultCfg = function () {
            return this.layoutInstance.getDefaultCfg();
          }),
          (t.prototype.destroy = function () {
            return this.layoutInstance.destroy();
          }),
          t
        );
      })();
      (e.Layout = i),
        (e.Layouts = new Proxy(
          {},
          {
            get(t, e) {
              return r.getLayoutByName(e);
            },
            set(t, e, n) {
              return r.registerLayout(e, n), !0;
            },
          },
        ));
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.assembleFont = e.getTextWidth = e.getLineSpaceing = e.getTextHeight = void 0);
      const r = n(253);
      const i = n(254);
      function o(t, e) {
        return e ? e - t : 0.14 * t;
      }
      (e.getTextHeight = function (t, e, n) {
        let i = 1;
        return r.isString(t) && (i = t.split('\n').length), i > 1 ? e * i + o(e, n) * (i - 1) : e;
      }),
        (e.getLineSpaceing = o),
        (e.getTextWidth = function (t, e) {
          const n = i.getOffScreenContext();
          let o = 0;
          if (r.isNil(t) || t === '') return o;
          if ((n.save(), (n.font = e), r.isString(t) && t.includes('\n'))) {
            const a = t.split('\n');
            r.each(a, (t) => {
              const e = n.measureText(t).width;
              o < e && (o = e);
            });
          } else o = n.measureText(t).width;
          return n.restore(), o;
        }),
        (e.assembleFont = function (t) {
          const e = t.fontSize;
          const n = t.fontFamily;
          const r = t.fontWeight;
          return [t.fontStyle, t.fontVariant, r, `${e}px`, n].join(' ').trim();
        });
    },
    ,
    function (t, e) {},
    function (t, e) {},
    function (t, e) {
      let n;
      let r;
      const i = (t.exports = {});
      function o() {
        throw new Error('setTimeout has not been defined');
      }
      function a() {
        throw new Error('clearTimeout has not been defined');
      }
      function s(t) {
        if (n === setTimeout) return setTimeout(t, 0);
        if ((n === o || !n) && setTimeout) return (n = setTimeout), setTimeout(t, 0);
        try {
          return n(t, 0);
        } catch (e) {
          try {
            return n.call(null, t, 0);
          } catch (e) {
            return n.call(this, t, 0);
          }
        }
      }
      !(function () {
        try {
          n = typeof setTimeout === 'function' ? setTimeout : o;
        } catch (t) {
          n = o;
        }
        try {
          r = typeof clearTimeout === 'function' ? clearTimeout : a;
        } catch (t) {
          r = a;
        }
      })();
      let u;
      let c = [];
      let h = !1;
      let l = -1;
      function f() {
        h && u && ((h = !1), u.length ? (c = u.concat(c)) : (l = -1), c.length && d());
      }
      function d() {
        if (!h) {
          const t = s(f);
          h = !0;
          for (let e = c.length; e; ) {
            for (u = c, c = []; ++l < e; ) u && u[l].run();
            (l = -1), (e = c.length);
          }
          (u = null),
            (h = !1),
            (function (t) {
              if (r === clearTimeout) return clearTimeout(t);
              if ((r === a || !r) && clearTimeout) return (r = clearTimeout), clearTimeout(t);
              try {
                r(t);
              } catch (e) {
                try {
                  return r.call(null, t);
                } catch (e) {
                  return r.call(this, t);
                }
              }
            })(t);
        }
      }
      function p(t, e) {
        (this.fun = t), (this.array = e);
      }
      function g() {}
      (i.nextTick = function (t) {
        const e = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (let n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        c.push(new p(t, e)), c.length !== 1 || h || s(d);
      }),
        (p.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (i.title = 'browser'),
        (i.browser = !0),
        (i.env = {}),
        (i.argv = []),
        (i.version = ''),
        (i.versions = {}),
        (i.on = g),
        (i.addListener = g),
        (i.once = g),
        (i.off = g),
        (i.removeListener = g),
        (i.removeAllListeners = g),
        (i.emit = g),
        (i.prependListener = g),
        (i.prependOnceListener = g),
        (i.listeners = function (t) {
          return [];
        }),
        (i.binding = function (t) {
          throw new Error('process.binding is not supported');
        }),
        (i.cwd = function () {
          return '/';
        }),
        (i.chdir = function (t) {
          throw new Error('process.chdir is not supported');
        }),
        (i.umask = function () {
          return 0;
        });
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      !(function (t) {
        function e() {
          return (t !== null && t.apply(this, arguments)) || this;
        }
        Object(r.c)(e, t),
          (e.prototype.isGroup = function () {
            return !0;
          }),
          (e.prototype.isEntityGroup = function () {
            return !1;
          }),
          (e.prototype.clone = function () {
            for (
              var e = t.prototype.clone.call(this), n = this.getChildren(), r = 0;
              r < n.length;
              r++
            ) {
              const i = n[r];
              e.add(i.clone());
            }
            return e;
          });
      })(n(90).a);
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      const i = n(91);
      const o = n(21);
      !(function (t) {
        function e(e) {
          return t.call(this, e) || this;
        }
        Object(r.c)(e, t),
          (e.prototype._isInBBox = function (t, e) {
            const n = this.getBBox();
            return n.minX <= t && n.maxX >= t && n.minY <= e && n.maxY >= e;
          }),
          (e.prototype.afterAttrsChange = function (e) {
            t.prototype.afterAttrsChange.call(this, e), this.clearCacheBBox();
          }),
          (e.prototype.getBBox = function () {
            let t = this.cfg.bbox;
            return t || ((t = this.calculateBBox()), this.set('bbox', t)), t;
          }),
          (e.prototype.getCanvasBBox = function () {
            let t = this.cfg.canvasBBox;
            return t || ((t = this.calculateCanvasBBox()), this.set('canvasBBox', t)), t;
          }),
          (e.prototype.applyMatrix = function (e) {
            t.prototype.applyMatrix.call(this, e), this.set('canvasBBox', null);
          }),
          (e.prototype.calculateCanvasBBox = function () {
            const t = this.getBBox();
            const e = this.getTotalMatrix();
            let n = t.minX;
            let r = t.minY;
            let i = t.maxX;
            let a = t.maxY;
            if (e) {
              const s = Object(o.c)(e, [t.minX, t.minY]);
              const u = Object(o.c)(e, [t.maxX, t.minY]);
              const c = Object(o.c)(e, [t.minX, t.maxY]);
              const h = Object(o.c)(e, [t.maxX, t.maxY]);
              (n = Math.min(s[0], u[0], c[0], h[0])),
                (i = Math.max(s[0], u[0], c[0], h[0])),
                (r = Math.min(s[1], u[1], c[1], h[1])),
                (a = Math.max(s[1], u[1], c[1], h[1]));
            }
            const l = this.attrs;
            if (l.shadowColor) {
              const f = l.shadowBlur;
              const d = void 0 === f ? 0 : f;
              const p = l.shadowOffsetX;
              const g = void 0 === p ? 0 : p;
              const v = l.shadowOffsetY;
              const y = void 0 === v ? 0 : v;
              const m = n - d + g;
              const b = i + d + g;
              const x = r - d + y;
              const M = a + d + y;
              (n = Math.min(n, m)),
                (i = Math.max(i, b)),
                (r = Math.min(r, x)),
                (a = Math.max(a, M));
            }
            return { x: n, y: r, minX: n, minY: r, maxX: i, maxY: a, width: i - n, height: a - r };
          }),
          (e.prototype.clearCacheBBox = function () {
            this.set('bbox', null), this.set('canvasBBox', null);
          }),
          (e.prototype.isClipShape = function () {
            return this.get('isClipShape');
          }),
          (e.prototype.isInShape = function (t, e) {
            return !1;
          }),
          (e.prototype.isOnlyHitBox = function () {
            return !1;
          }),
          (e.prototype.isHit = function (t, e) {
            const n = this.get('startArrowShape');
            const r = this.get('endArrowShape');
            let i = [t, e, 1];
            const o = (i = this.invertFromMatrix(i))[0];
            const a = i[1];
            const s = this._isInBBox(o, a);
            if (this.isOnlyHitBox()) return s;
            if (s && !this.isClipped(o, a)) {
              if (this.isInShape(o, a)) return !0;
              if (n && n.isHit(o, a)) return !0;
              if (r && r.isHit(o, a)) return !0;
            }
            return !1;
          });
      })(i.a);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = d(n(125));
      const i = n(35);
      const o = n(18);
      const a = d(n(126));
      const s = d(n(128));
      const u = d(n(129));
      const c = d(n(94));
      const h = d(n(131));
      const l = d(n(134));
      const f = d(n(135));
      function d(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class p {
        constructor(t) {
          return (
            ((t = t || {}).recognizers = (0, r.default)(t.recognizers, p.defaults.preset)),
            new f.default(t)
          );
        }
      }
      (e.default = p),
        (p.defaults = {
          domEvents: !1,
          touchAction: i.TOUCH_ACTION_COMPUTE,
          enable: !0,
          inputClass: null,
          preset: [
            [a.default, { enable: !1 }],
            [s.default, { enable: !1 }, ['rotate']],
            [u.default, { direction: o.DIRECTION_HORIZONTAL }],
            [c.default, { direction: o.DIRECTION_HORIZONTAL }, ['swipe']],
            [h.default],
            [h.default, { event: 'doubletap', taps: 2 }, ['tap']],
            [l.default],
          ],
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          return void 0 === t ? e : t;
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      let r;
      const i = (r = n(54)) && r.__esModule ? r : { default: r };
      const o = n(35);
      const a = n(26);
      class s extends i.default {
        constructor() {
          super(...arguments);
        }

        getTouchAction() {
          return [o.TOUCH_ACTION_NONE];
        }

        attrTest(t) {
          return (
            super.attrTest(t) &&
            (Math.abs(t.rotation) > this.options.threshold || this.state & a.STATE_BEGAN)
          );
        }
      }
      (e.default = s), (s.prototype.defaults = { event: 'rotate', threshold: 0, pointers: 2 });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          if (Array.isArray(t)) return (0, i.default)(t, n[e], n), !0;
          return !1;
        });
      let r;
      var i = (r = n(44)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      let r;
      const i = (r = n(54)) && r.__esModule ? r : { default: r };
      const o = n(35);
      const a = n(26);
      class s extends i.default {
        constructor() {
          super(...arguments);
        }

        getTouchAction() {
          return [o.TOUCH_ACTION_NONE];
        }

        attrTest(t) {
          return (
            super.attrTest(t) &&
            (Math.abs(t.scale - 1) > this.options.threshold || this.state & a.STATE_BEGAN)
          );
        }

        emit(t) {
          if (t.scale !== 1) {
            const e = t.scale < 1 ? 'in' : 'out';
            t.additionalEvent = this.options.event + e;
          }
          super.emit(t);
        }
      }
      (e.default = s), (s.prototype.defaults = { event: 'pinch', threshold: 0, pointers: 2 });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = u(n(54));
      const i = n(31);
      const o = n(18);
      const a = u(n(94));
      const s = u(n(130));
      function u(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class c extends r.default {
        constructor() {
          super(...arguments);
        }

        getTouchAction() {
          return a.default.prototype.getTouchAction.call(this);
        }

        attrTest(t) {
          let e;
          const { direction: n } = this.options;
          return (
            n & (o.DIRECTION_HORIZONTAL | o.DIRECTION_VERTICAL)
              ? (e = t.overallVelocity)
              : n & o.DIRECTION_HORIZONTAL
              ? (e = t.overallVelocityX)
              : n & o.DIRECTION_VERTICAL && (e = t.overallVelocityY),
            super.attrTest(t) &&
              n & t.offsetDirection &&
              t.distance > this.options.threshold &&
              t.maxPointers === this.options.pointers &&
              (0, i.abs)(e) > this.options.velocity &&
              t.eventType & o.INPUT_END
          );
        }

        emit(t) {
          const e = (0, s.default)(t.offsetDirection);
          e && this.manager.emit(this.options.event + e, t),
            this.manager.emit(this.options.event, t);
        }
      }
      (e.default = c),
        (c.prototype.defaults = {
          event: 'swipe',
          threshold: 10,
          velocity: 0.3,
          direction: o.DIRECTION_HORIZONTAL | o.DIRECTION_VERTICAL,
          pointers: 1,
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          if (t === r.DIRECTION_DOWN) return 'down';
          if (t === r.DIRECTION_UP) return 'up';
          if (t === r.DIRECTION_LEFT) return 'left';
          if (t === r.DIRECTION_RIGHT) return 'right';
          return '';
        });
      var r = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = c(n(132));
      const i = c(n(55));
      const o = n(35);
      const a = n(18);
      const s = n(26);
      const u = c(n(95));
      function c(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class h extends i.default {
        constructor() {
          super(...arguments),
            (this.pTime = !1),
            (this.pCenter = !1),
            (this._timer = null),
            (this._input = null),
            (this.count = 0);
        }

        getTouchAction() {
          return [o.TOUCH_ACTION_MANIPULATION];
        }

        process(t) {
          const { options: e } = this;
          const n = t.pointers.length === e.pointers;
          const i = t.distance < e.threshold;
          const o = t.deltaTime < e.time;
          if ((this.reset(), t.eventType & a.INPUT_START && this.count === 0))
            return this.failTimeout();
          if (i && o && n) {
            if (t.eventType !== a.INPUT_END) return this.failTimeout();
            const n = !this.pTime || t.timeStamp - this.pTime < e.interval;
            const i = !this.pCenter || (0, u.default)(this.pCenter, t.center) < e.posThreshold;
            if (
              ((this.pTime = t.timeStamp),
              (this.pCenter = t.center),
              i && n ? (this.count += 1) : (this.count = 1),
              (this._input = t),
              this.count % e.taps === 0)
            )
              return this.hasRequireFailures()
                ? ((this._timer = (0, r.default)(
                    () => {
                      (this.state = s.STATE_RECOGNIZED), this.tryEmit();
                    },
                    e.interval,
                    this,
                  )),
                  s.STATE_BEGAN)
                : s.STATE_RECOGNIZED;
          }
          return s.STATE_FAILED;
        }

        failTimeout() {
          return (
            (this._timer = (0, r.default)(
              () => {
                this.state = s.STATE_FAILED;
              },
              this.options.interval,
              this,
            )),
            s.STATE_FAILED
          );
        }

        reset() {
          clearTimeout(this._timer), (this._timer = null);
        }

        emit() {
          this.state === s.STATE_RECOGNIZED &&
            ((this._input.tapCount = this.count),
            this.manager.emit(this.options.event, this._input));
        }
      }
      (e.default = h),
        (h.prototype.defaults = {
          event: 'tap',
          pointers: 1,
          taps: 1,
          interval: 300,
          time: 250,
          threshold: 9,
          posThreshold: 10,
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          return setTimeout((0, i.default)(t, n), e);
        });
      let r;
      var i = (r = n(133)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          return function () {
            return t.apply(e, arguments);
          };
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = c(n(55));
      const i = n(26);
      const o = n(31);
      const a = c(n(132));
      const s = n(35);
      const u = n(18);
      function c(t) {
        return t && t.__esModule ? t : { default: t };
      }
      class h extends r.default {
        constructor() {
          super(...arguments), (this._timer = null), (this._input = null);
        }

        getTouchAction() {
          return [s.TOUCH_ACTION_AUTO];
        }

        process(t) {
          const { options: e } = this;
          const n = t.pointers.length === e.pointers;
          const r = t.distance < e.threshold;
          const o = t.deltaTime > e.time;
          if (((this._input = t), !r || !n || (t.eventType & (u.INPUT_END | u.INPUT_CANCEL) && !o)))
            this.reset();
          else if (t.eventType & u.INPUT_START)
            this.reset(),
              (this._timer = (0, a.default)(
                () => {
                  (this.state = i.STATE_RECOGNIZED), this.tryEmit();
                },
                e.time,
                this,
              ));
          else if (t.eventType & u.INPUT_END) return i.STATE_RECOGNIZED;
          return i.STATE_FAILED;
        }

        reset() {
          clearTimeout(this._timer), (this._timer = null);
        }

        emit(t) {
          this.state === i.STATE_RECOGNIZED &&
            (t && t.eventType & u.INPUT_END
              ? this.manager.emit(`${this.options.event}up`, t)
              : ((this._input.timeStamp = (0, o.now)()),
                this.manager.emit(this.options.event, this._input)));
        }
      }
      (e.default = h),
        (h.prototype.defaults = { event: 'press', pointers: 1, time: 251, threshold: 9 });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = d(n(65));
      const i = d(n(124));
      const o = d(n(136));
      const a = d(n(241));
      const s = d(n(44));
      const u = d(n(56));
      const c = d(n(127));
      const h = d(n(67));
      const l = d(n(55));
      const f = n(26);
      function d(t) {
        return t && t.__esModule ? t : { default: t };
      }
      e.default = class {
        constructor(t) {
          (this.options = (0, r.default)({}, i.default.defaults, t || {})),
            (this.handlers = {}),
            (this.filters = []),
            (this.session = {}),
            (this.recognizers = []),
            (this.input = (0, a.default)(this)),
            (this.touchAction = new o.default(this, this.options.touchAction)),
            (0, s.default)(
              this.options.recognizers,
              (t) => {
                const e = this.add(new t[0](t[1]));
                t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]);
              },
              this,
            );
        }

        set(t) {
          return (0, r.default)(this.options, t), t.touchAction && this.touchAction.update(), this;
        }

        stop(t) {
          this.session.stopped = t ? 2 : 1;
        }

        addFilter(t) {
          if (typeof t !== 'function') throw new Error('filter must be a function');
          this.filters.push(t);
        }

        recognize(t) {
          let e;
          const { session: n } = this;
          if (n.stopped) return;
          this.touchAction.preventDefaults(t);
          const { recognizers: r } = this;
          let { curRecognizer: i } = n;
          (!i || (i && i.state & f.STATE_RECOGNIZED)) && (i = n.curRecognizer = null);
          let o = 0;
          for (; o < r.length; )
            (e = r[o]),
              n.stopped === 2 || (i && e !== i && !e.canRecognizeWith(i))
                ? e.reset()
                : e.recognize(t),
              !i &&
                e.state & (f.STATE_BEGAN | f.STATE_CHANGED | f.STATE_ENDED) &&
                (i = n.curRecognizer = e),
              o++;
        }

        get(t) {
          if (t instanceof l.default) return t;
          const { recognizers: e } = this;
          for (let n = 0; n < e.length; n++) if (e[n].options.event === t) return e[n];
          return null;
        }

        add(t) {
          if ((0, c.default)(t, 'add', this)) return this;
          const e = this.get(t.options.event);
          return (
            e && this.remove(e),
            this.recognizers.push(t),
            (t.manager = this),
            this.touchAction.update(),
            t
          );
        }

        remove(t) {
          if ((0, c.default)(t, 'remove', this)) return this;
          if ((t = this.get(t))) {
            const { recognizers: e } = this;
            const n = (0, u.default)(e, t);
            n !== -1 && (e.splice(n, 1), this.touchAction.update());
          }
          return this;
        }

        on(t, e) {
          if (void 0 === t) return;
          if (void 0 === e) return;
          const { handlers: n } = this;
          return (
            (0, s.default)((0, h.default)(t), (t) => {
              (n[t] = n[t] || []), n[t].push(e);
            }),
            this
          );
        }

        off(t, e) {
          if (void 0 === t) return;
          const { handlers: n } = this;
          return (
            (0, s.default)((0, h.default)(t), (t) => {
              e ? n[t] && n[t].splice((0, u.default)(n[t], e), 1) : delete n[t];
            }),
            this
          );
        }

        emit(t, e) {
          const n = this.handlers[t] && this.handlers[t].slice();
          const { filters: r } = this;
          if (!n || !n.length) return;
          t.startsWith('origin_input') ||
            ((e.type = t),
            (e.preventDefault = function () {
              e.srcEvent.preventDefault && e.srcEvent.preventDefault();
            }));
          let i = 0;
          for (; i < n.length; ) n[i](e), i++;
        }

        destroy() {
          (this.handlers = {}), (this.filters = []), (this.session = {}), this.input.destroy();
        }
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = n(35);
      const i = n(18);
      const o = c(n(44));
      const a = c(n(66));
      const s = c(n(137));
      const u = c(n(240));
      function c(t) {
        return t && t.__esModule ? t : { default: t };
      }
      e.default = class {
        constructor(t, e) {
          (this.manager = t), this.set(e);
        }

        set(t) {
          t === r.TOUCH_ACTION_COMPUTE && (t = this.compute()),
            (this.actions = t.toLowerCase().trim());
        }

        update() {
          this.set(this.manager.options.touchAction);
        }

        compute() {
          let t = [];
          return (
            (0, o.default)(this.manager.recognizers, (e) => {
              (0, a.default)(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()));
            }),
            (0, u.default)(t.join(' '))
          );
        }

        preventDefaults(t) {
          const { srcEvent: e } = t;
          const n = t.offsetDirection;
          if (this.manager.session.prevented) return void e.preventDefault();
          const { actions: o } = this;
          const a =
            (0, s.default)(o, r.TOUCH_ACTION_NONE) && !r.TOUCH_ACTION_MAP[r.TOUCH_ACTION_NONE];
          const u =
            (0, s.default)(o, r.TOUCH_ACTION_PAN_Y) && !r.TOUCH_ACTION_MAP[r.TOUCH_ACTION_PAN_Y];
          const c =
            (0, s.default)(o, r.TOUCH_ACTION_PAN_X) && !r.TOUCH_ACTION_MAP[r.TOUCH_ACTION_PAN_X];
          if (a) {
            const e = t.pointers.length === 1;
            const n = t.distance < 2;
            const r = t.deltaTime < 250;
            if (e && n && r) return;
          }
          return c && u
            ? void 0
            : a || (u && n & i.DIRECTION_HORIZONTAL) || (c && n & i.DIRECTION_VERTICAL)
            ? this.preventSrc(e)
            : void 0;
        }

        preventSrc(t) {
          (this.manager.session.prevented = !0), t.preventDefault();
        }
      };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          return t.indexOf(e) > -1;
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          const e = t.length;
          if (e === 1) return { x: (0, r.round)(t[0].clientX), y: (0, r.round)(t[0].clientY) };
          let n = 0;
          let i = 0;
          let o = 0;
          for (; o < e; ) (n += t[o].clientX), (i += t[o].clientY), o++;
          return { x: (0, r.round)(n / e), y: (0, r.round)(i / e) };
        });
      var r = n(31);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          n || (n = r.PROPS_XY);
          const i = e[n[0]] - t[n[0]];
          const o = e[n[1]] - t[n[1]];
          return (180 * Math.atan2(o, i)) / Math.PI;
        });
      var r = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          if (t === e) return i.DIRECTION_NONE;
          if ((0, r.abs)(t) >= (0, r.abs)(e)) return t < 0 ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT;
          return e < 0 ? i.DIRECTION_UP : i.DIRECTION_DOWN;
        });
      var r = n(31);
      var i = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          return { x: e / t || 0, y: n / t || 0 };
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = n(18);
      const i = s(n(97));
      const o = s(n(144));
      const a = (s(n(96)), s(n(145)));
      function s(t) {
        return t && t.__esModule ? t : { default: t };
      }
      const u = {
        touchstart: r.INPUT_START,
        touchmove: r.INPUT_MOVE,
        touchend: r.INPUT_END,
        touchcancel: r.INPUT_CANCEL,
      };
      const c = 'touchstart touchmove touchend touchcancel';
      class h extends i.default {
        constructor() {
          (h.prototype.evTarget = c),
            (h.prototype.targetIds = {}),
            (h.prototype.events = c),
            super(...arguments),
            (this.evTarget = c),
            (this.targetIds = {});
        }

        handler(t) {
          const e = u[t.type];
          const n = l.call(this, t, e);
          n &&
            this.callback(this.manager, e, {
              pointers: n[0],
              changedPointers: n[1],
              pointerType: r.INPUT_TYPE_TOUCH,
              srcEvent: t,
            });
        }
      }
      function l(t, e) {
        let n;
        let i;
        const s = (0, o.default)(t.touches);
        const { targetIds: u } = this;
        if (e & (r.INPUT_START | r.INPUT_MOVE) && s.length === 1)
          return (u[s[0].identifier] = !0), [s, s];
        const c = (0, o.default)(t.changedTouches);
        const h = [];
        const { target: l } = this;
        if (((i = s), e === r.INPUT_START))
          for (n = 0; n < i.length; ) (u[i[n].identifier] = !0), n++;
        for (n = 0; n < c.length; )
          u[c[n].identifier] && h.push(c[n]),
            e & (r.INPUT_END | r.INPUT_CANCEL) && delete u[c[n].identifier],
            n++;
        return h.length ? [(0, a.default)(i.concat(h), 'identifier', !0), h] : void 0;
      }
      e.default = h;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          (0, r.default)((0, i.default)(e), (e) => {
            t.addEventListener(e, n, !1);
          });
        }),
        (e.addManagerListeners = function (t, e, n) {
          (0, r.default)((0, i.default)(e), (e) => {
            t.on(`origin_input:${e}`, n);
          });
        });
      var r = o(n(44));
      var i = o(n(67));
      function o(t) {
        return t && t.__esModule ? t : { default: t };
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          return Array.prototype.slice.call(t, 0);
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          let r = [];
          const o = [];
          let a = 0;
          for (; a < t.length; ) {
            const n = e ? t[a][e] : t[a];
            (0, i.default)(o, n) < 0 && r.push(t[a]), (o[a] = n), a++;
          }
          n && (r = e ? r.sort((t, n) => t[e] > n[e]) : r.sort());
          return r;
        });
      let r;
      var i = (r = n(56)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          const r = `DEPRECATED METHOD: ${e}\n${n} AT \n`;
          return function () {
            const e = new Error('get-stack-trace');
            const n =
              e && e.stack
                ? e.stack
                    .replace(/^[^\(]+?[\n$]/gm, '')
                    .replace(/^\s+at\s+/gm, '')
                    .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@')
                : 'Unknown Stack Trace';
            const i = console.warn;
            return i && i(r, n), t.apply(this, arguments);
          };
        });
    },
    function (t, e, n) {
      'use strict';
      let r;
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const i = (0, ((r = n(146)) && r.__esModule ? r : { default: r }).default)(
        (t, e, n) => {
          const r = Object.keys(e);
          let i = 0;
          for (; i < r.length; ) (!n || (n && void 0 === t[r[i]])) && (t[r[i]] = e[r[i]]), i++;
          return t;
        },
        'extend',
        'Use `assign`.',
      );
      e.default = i;
    },
    function (t, e, n) {
      const r = n(260);
      const i = {};
      for (const o in r) r.hasOwnProperty(o) && (i[r[o]] = o);
      const a = (t.exports = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      });
      for (const s in a)
        if (a.hasOwnProperty(s)) {
          if (!('channels' in a[s])) throw new Error(`missing channels property: ${s}`);
          if (!('labels' in a[s])) throw new Error(`missing channel labels property: ${s}`);
          if (a[s].labels.length !== a[s].channels)
            throw new Error(`channel and label counts mismatch: ${s}`);
          const u = a[s].channels;
          const c = a[s].labels;
          delete a[s].channels,
            delete a[s].labels,
            Object.defineProperty(a[s], 'channels', { value: u }),
            Object.defineProperty(a[s], 'labels', { value: c });
        }
      (a.rgb.hsl = function (t) {
        let e;
        let n;
        const r = t[0] / 255;
        const i = t[1] / 255;
        const o = t[2] / 255;
        const a = Math.min(r, i, o);
        const s = Math.max(r, i, o);
        const u = s - a;
        return (
          s === a
            ? (e = 0)
            : r === s
            ? (e = (i - o) / u)
            : i === s
            ? (e = 2 + (o - r) / u)
            : o === s && (e = 4 + (r - i) / u),
          (e = Math.min(60 * e, 360)) < 0 && (e += 360),
          (n = (a + s) / 2),
          [e, 100 * (s === a ? 0 : n <= 0.5 ? u / (s + a) : u / (2 - s - a)), 100 * n]
        );
      }),
        (a.rgb.hsv = function (t) {
          let e;
          let n;
          let r;
          let i;
          let o;
          const a = t[0] / 255;
          const s = t[1] / 255;
          const u = t[2] / 255;
          const c = Math.max(a, s, u);
          const h = c - Math.min(a, s, u);
          const l = function (t) {
            return (c - t) / 6 / h + 0.5;
          };
          return (
            h === 0
              ? (i = o = 0)
              : ((o = h / c),
                (e = l(a)),
                (n = l(s)),
                (r = l(u)),
                a === c
                  ? (i = r - n)
                  : s === c
                  ? (i = 1 / 3 + e - r)
                  : u === c && (i = 2 / 3 + n - e),
                i < 0 ? (i += 1) : i > 1 && (i -= 1)),
            [360 * i, 100 * o, 100 * c]
          );
        }),
        (a.rgb.hwb = function (t) {
          const e = t[0];
          const n = t[1];
          let r = t[2];
          return [
            a.rgb.hsl(t)[0],
            100 * ((1 / 255) * Math.min(e, Math.min(n, r))),
            100 * (r = 1 - (1 / 255) * Math.max(e, Math.max(n, r))),
          ];
        }),
        (a.rgb.cmyk = function (t) {
          let e;
          const n = t[0] / 255;
          const r = t[1] / 255;
          const i = t[2] / 255;
          return [
            100 * ((1 - n - (e = Math.min(1 - n, 1 - r, 1 - i))) / (1 - e) || 0),
            100 * ((1 - r - e) / (1 - e) || 0),
            100 * ((1 - i - e) / (1 - e) || 0),
            100 * e,
          ];
        }),
        (a.rgb.keyword = function (t) {
          const e = i[t];
          if (e) return e;
          let n;
          let o;
          let a;
          let s = 1 / 0;
          for (const u in r)
            if (r.hasOwnProperty(u)) {
              const c = r[u];
              const h =
                ((o = t),
                (a = c),
                Math.pow(o[0] - a[0], 2) + Math.pow(o[1] - a[1], 2) + Math.pow(o[2] - a[2], 2));
              h < s && ((s = h), (n = u));
            }
          return n;
        }),
        (a.keyword.rgb = function (t) {
          return r[t];
        }),
        (a.rgb.xyz = function (t) {
          let e = t[0] / 255;
          let n = t[1] / 255;
          let r = t[2] / 255;
          return [
            100 *
              (0.4124 * (e = e > 0.04045 ? Math.pow((e + 0.055) / 1.055, 2.4) : e / 12.92) +
                0.3576 * (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92) +
                0.1805 * (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92)),
            100 * (0.2126 * e + 0.7152 * n + 0.0722 * r),
            100 * (0.0193 * e + 0.1192 * n + 0.9505 * r),
          ];
        }),
        (a.rgb.lab = function (t) {
          const e = a.rgb.xyz(t);
          let n = e[0];
          let r = e[1];
          let i = e[2];
          return (
            (r /= 100),
            (i /= 108.883),
            (n = (n /= 95.047) > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116),
            [
              116 * (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16,
              500 * (n - r),
              200 * (r - (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116)),
            ]
          );
        }),
        (a.hsl.rgb = function (t) {
          let e;
          let n;
          let r;
          let i;
          let o;
          const a = t[0] / 360;
          const s = t[1] / 100;
          const u = t[2] / 100;
          if (s === 0) return [(o = 255 * u), o, o];
          (e = 2 * u - (n = u < 0.5 ? u * (1 + s) : u + s - u * s)), (i = [0, 0, 0]);
          for (let c = 0; c < 3; c++)
            (r = a + (1 / 3) * -(c - 1)) < 0 && r++,
              r > 1 && r--,
              (o =
                6 * r < 1
                  ? e + 6 * (n - e) * r
                  : 2 * r < 1
                  ? n
                  : 3 * r < 2
                  ? e + (n - e) * (2 / 3 - r) * 6
                  : e),
              (i[c] = 255 * o);
          return i;
        }),
        (a.hsl.hsv = function (t) {
          const e = t[0];
          let n = t[1] / 100;
          let r = t[2] / 100;
          let i = n;
          const o = Math.max(r, 0.01);
          return (
            (n *= (r *= 2) <= 1 ? r : 2 - r),
            (i *= o <= 1 ? o : 2 - o),
            [e, 100 * (r === 0 ? (2 * i) / (o + i) : (2 * n) / (r + n)), 100 * ((r + n) / 2)]
          );
        }),
        (a.hsv.rgb = function (t) {
          const e = t[0] / 60;
          const n = t[1] / 100;
          let r = t[2] / 100;
          const i = Math.floor(e) % 6;
          const o = e - Math.floor(e);
          const a = 255 * r * (1 - n);
          const s = 255 * r * (1 - n * o);
          const u = 255 * r * (1 - n * (1 - o));
          switch (((r *= 255), i)) {
            case 0:
              return [r, u, a];
            case 1:
              return [s, r, a];
            case 2:
              return [a, r, u];
            case 3:
              return [a, s, r];
            case 4:
              return [u, a, r];
            case 5:
              return [r, a, s];
          }
        }),
        (a.hsv.hsl = function (t) {
          let e;
          let n;
          let r;
          const i = t[0];
          const o = t[1] / 100;
          const a = t[2] / 100;
          const s = Math.max(a, 0.01);
          return (
            (r = (2 - o) * a),
            (n = o * s),
            [i, 100 * (n = (n /= (e = (2 - o) * s) <= 1 ? e : 2 - e) || 0), 100 * (r /= 2)]
          );
        }),
        (a.hwb.rgb = function (t) {
          let e;
          let n;
          let r;
          let i;
          let o;
          let a;
          let s;
          const u = t[0] / 360;
          let c = t[1] / 100;
          let h = t[2] / 100;
          const l = c + h;
          switch (
            (l > 1 && ((c /= l), (h /= l)),
            (r = 6 * u - (e = Math.floor(6 * u))),
            (1 & e) != 0 && (r = 1 - r),
            (i = c + r * ((n = 1 - h) - c)),
            e)
          ) {
            default:
            case 6:
            case 0:
              (o = n), (a = i), (s = c);
              break;
            case 1:
              (o = i), (a = n), (s = c);
              break;
            case 2:
              (o = c), (a = n), (s = i);
              break;
            case 3:
              (o = c), (a = i), (s = n);
              break;
            case 4:
              (o = i), (a = c), (s = n);
              break;
            case 5:
              (o = n), (a = c), (s = i);
          }
          return [255 * o, 255 * a, 255 * s];
        }),
        (a.cmyk.rgb = function (t) {
          const e = t[0] / 100;
          const n = t[1] / 100;
          const r = t[2] / 100;
          const i = t[3] / 100;
          return [
            255 * (1 - Math.min(1, e * (1 - i) + i)),
            255 * (1 - Math.min(1, n * (1 - i) + i)),
            255 * (1 - Math.min(1, r * (1 - i) + i)),
          ];
        }),
        (a.xyz.rgb = function (t) {
          let e;
          let n;
          let r;
          const i = t[0] / 100;
          const o = t[1] / 100;
          const a = t[2] / 100;
          return (
            (n = -0.9689 * i + 1.8758 * o + 0.0415 * a),
            (r = 0.0557 * i + -0.204 * o + 1.057 * a),
            (e =
              (e = 3.2406 * i + -1.5372 * o + -0.4986 * a) > 0.0031308
                ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055
                : 12.92 * e),
            (n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n),
            (r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r),
            [
              255 * (e = Math.min(Math.max(0, e), 1)),
              255 * (n = Math.min(Math.max(0, n), 1)),
              255 * (r = Math.min(Math.max(0, r), 1)),
            ]
          );
        }),
        (a.xyz.lab = function (t) {
          let e = t[0];
          let n = t[1];
          let r = t[2];
          return (
            (n /= 100),
            (r /= 108.883),
            (e = (e /= 95.047) > 0.008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116),
            [
              116 * (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16,
              500 * (e - n),
              200 * (n - (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116)),
            ]
          );
        }),
        (a.lab.xyz = function (t) {
          let e;
          let n;
          let r;
          const i = t[0];
          (e = t[1] / 500 + (n = (i + 16) / 116)), (r = n - t[2] / 200);
          const o = Math.pow(n, 3);
          const a = Math.pow(e, 3);
          const s = Math.pow(r, 3);
          return (
            (n = o > 0.008856 ? o : (n - 16 / 116) / 7.787),
            (e = a > 0.008856 ? a : (e - 16 / 116) / 7.787),
            (r = s > 0.008856 ? s : (r - 16 / 116) / 7.787),
            [(e *= 95.047), (n *= 100), (r *= 108.883)]
          );
        }),
        (a.lab.lch = function (t) {
          let e;
          const n = t[0];
          const r = t[1];
          const i = t[2];
          return (
            (e = (360 * Math.atan2(i, r)) / 2 / Math.PI) < 0 && (e += 360),
            [n, Math.sqrt(r * r + i * i), e]
          );
        }),
        (a.lch.lab = function (t) {
          let e;
          const n = t[0];
          const r = t[1];
          return (e = (t[2] / 360) * 2 * Math.PI), [n, r * Math.cos(e), r * Math.sin(e)];
        }),
        (a.rgb.ansi16 = function (t) {
          const e = t[0];
          const n = t[1];
          const r = t[2];
          let i = 1 in arguments ? arguments[1] : a.rgb.hsv(t)[2];
          if ((i = Math.round(i / 50)) === 0) return 30;
          let o =
            30 + ((Math.round(r / 255) << 2) | (Math.round(n / 255) << 1) | Math.round(e / 255));
          return i === 2 && (o += 60), o;
        }),
        (a.hsv.ansi16 = function (t) {
          return a.rgb.ansi16(a.hsv.rgb(t), t[2]);
        }),
        (a.rgb.ansi256 = function (t) {
          const e = t[0];
          const n = t[1];
          const r = t[2];
          return e === n && n === r
            ? e < 8
              ? 16
              : e > 248
              ? 231
              : Math.round(((e - 8) / 247) * 24) + 232
            : 16 +
                36 * Math.round((e / 255) * 5) +
                6 * Math.round((n / 255) * 5) +
                Math.round((r / 255) * 5);
        }),
        (a.ansi16.rgb = function (t) {
          let e = t % 10;
          if (e === 0 || e === 7) return t > 50 && (e += 3.5), [(e = (e / 10.5) * 255), e, e];
          const n = 0.5 * (1 + ~~(t > 50));
          return [(1 & e) * n * 255, ((e >> 1) & 1) * n * 255, ((e >> 2) & 1) * n * 255];
        }),
        (a.ansi256.rgb = function (t) {
          if (t >= 232) {
            const e = 10 * (t - 232) + 8;
            return [e, e, e];
          }
          let n;
          return (
            (t -= 16),
            [
              (Math.floor(t / 36) / 5) * 255,
              (Math.floor((n = t % 36) / 6) / 5) * 255,
              ((n % 6) / 5) * 255,
            ]
          );
        }),
        (a.rgb.hex = function (t) {
          const e = (
            ((255 & Math.round(t[0])) << 16) +
            ((255 & Math.round(t[1])) << 8) +
            (255 & Math.round(t[2]))
          )
            .toString(16)
            .toUpperCase();
          return '000000'.substring(e.length) + e;
        }),
        (a.hex.rgb = function (t) {
          const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e) return [0, 0, 0];
          let n = e[0];
          e[0].length === 3 &&
            (n = n
              .split('')
              .map((t) => {
                return t + t;
              })
              .join(''));
          const r = parseInt(n, 16);
          return [(r >> 16) & 255, (r >> 8) & 255, 255 & r];
        }),
        (a.rgb.hcg = function (t) {
          let e;
          const n = t[0] / 255;
          const r = t[1] / 255;
          const i = t[2] / 255;
          const o = Math.max(Math.max(n, r), i);
          const a = Math.min(Math.min(n, r), i);
          const s = o - a;
          return (
            (e =
              s <= 0
                ? 0
                : o === n
                ? ((r - i) / s) % 6
                : o === r
                ? 2 + (i - n) / s
                : 4 + (n - r) / s + 4),
            (e /= 6),
            [360 * (e %= 1), 100 * s, 100 * (s < 1 ? a / (1 - s) : 0)]
          );
        }),
        (a.hsl.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          let r = 1;
          let i = 0;
          return (
            (r = n < 0.5 ? 2 * e * n : 2 * e * (1 - n)) < 1 && (i = (n - 0.5 * r) / (1 - r)),
            [t[0], 100 * r, 100 * i]
          );
        }),
        (a.hsv.hcg = function (t) {
          const e = t[1] / 100;
          const n = t[2] / 100;
          const r = e * n;
          let i = 0;
          return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i];
        }),
        (a.hcg.rgb = function (t) {
          const e = t[0] / 360;
          const n = t[1] / 100;
          const r = t[2] / 100;
          if (n === 0) return [255 * r, 255 * r, 255 * r];
          let i;
          const o = [0, 0, 0];
          const a = (e % 1) * 6;
          const s = a % 1;
          const u = 1 - s;
          switch (Math.floor(a)) {
            case 0:
              (o[0] = 1), (o[1] = s), (o[2] = 0);
              break;
            case 1:
              (o[0] = u), (o[1] = 1), (o[2] = 0);
              break;
            case 2:
              (o[0] = 0), (o[1] = 1), (o[2] = s);
              break;
            case 3:
              (o[0] = 0), (o[1] = u), (o[2] = 1);
              break;
            case 4:
              (o[0] = s), (o[1] = 0), (o[2] = 1);
              break;
            default:
              (o[0] = 1), (o[1] = 0), (o[2] = u);
          }
          return (
            (i = (1 - n) * r), [255 * (n * o[0] + i), 255 * (n * o[1] + i), 255 * (n * o[2] + i)]
          );
        }),
        (a.hcg.hsv = function (t) {
          const e = t[1] / 100;
          const n = e + (t[2] / 100) * (1 - e);
          let r = 0;
          return n > 0 && (r = e / n), [t[0], 100 * r, 100 * n];
        }),
        (a.hcg.hsl = function (t) {
          const e = t[1] / 100;
          const n = (t[2] / 100) * (1 - e) + 0.5 * e;
          let r = 0;
          return (
            n > 0 && n < 0.5 ? (r = e / (2 * n)) : n >= 0.5 && n < 1 && (r = e / (2 * (1 - n))),
            [t[0], 100 * r, 100 * n]
          );
        }),
        (a.hcg.hwb = function (t) {
          const e = t[1] / 100;
          const n = e + (t[2] / 100) * (1 - e);
          return [t[0], 100 * (n - e), 100 * (1 - n)];
        }),
        (a.hwb.hcg = function (t) {
          const e = t[1] / 100;
          const n = 1 - t[2] / 100;
          const r = n - e;
          let i = 0;
          return r < 1 && (i = (n - r) / (1 - r)), [t[0], 100 * r, 100 * i];
        }),
        (a.apple.rgb = function (t) {
          return [(t[0] / 65535) * 255, (t[1] / 65535) * 255, (t[2] / 65535) * 255];
        }),
        (a.rgb.apple = function (t) {
          return [(t[0] / 255) * 65535, (t[1] / 255) * 65535, (t[2] / 255) * 65535];
        }),
        (a.gray.rgb = function (t) {
          return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255];
        }),
        (a.gray.hsl = a.gray.hsv =
          function (t) {
            return [0, 0, t[0]];
          }),
        (a.gray.hwb = function (t) {
          return [0, 100, t[0]];
        }),
        (a.gray.cmyk = function (t) {
          return [0, 0, 0, t[0]];
        }),
        (a.gray.lab = function (t) {
          return [t[0], 0, 0];
        }),
        (a.gray.hex = function (t) {
          const e = 255 & Math.round((t[0] / 100) * 255);
          const n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
          return '000000'.substring(n.length) + n;
        }),
        (a.rgb.gray = function (t) {
          return [((t[0] + t[1] + t[2]) / 3 / 255) * 100];
        });
    },
    function (t, e) {},
    function (t, e) {},
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      const r = {};
      n.r(r),
        n.d(r, 'easeLinear', () => {
          return k;
        }),
        n.d(r, 'easeQuad', () => {
          return I;
        }),
        n.d(r, 'easeQuadIn', () => {
          return T;
        }),
        n.d(r, 'easeQuadOut', () => {
          return P;
        }),
        n.d(r, 'easeQuadInOut', () => {
          return I;
        }),
        n.d(r, 'easeCubic', () => {
          return N;
        }),
        n.d(r, 'easeCubicIn', () => {
          return A;
        }),
        n.d(r, 'easeCubicOut', () => {
          return j;
        }),
        n.d(r, 'easeCubicInOut', () => {
          return N;
        }),
        n.d(r, 'easePoly', () => {
          return L;
        }),
        n.d(r, 'easePolyIn', () => {
          return _;
        }),
        n.d(r, 'easePolyOut', () => {
          return B;
        }),
        n.d(r, 'easePolyInOut', () => {
          return L;
        }),
        n.d(r, 'easeSin', () => {
          return X;
        }),
        n.d(r, 'easeSinIn', () => {
          return Y;
        }),
        n.d(r, 'easeSinOut', () => {
          return F;
        }),
        n.d(r, 'easeSinInOut', () => {
          return X;
        }),
        n.d(r, 'easeExp', () => {
          return U;
        }),
        n.d(r, 'easeExpIn', () => {
          return W;
        }),
        n.d(r, 'easeExpOut', () => {
          return G;
        }),
        n.d(r, 'easeExpInOut', () => {
          return U;
        }),
        n.d(r, 'easeCircle', () => {
          return V;
        }),
        n.d(r, 'easeCircleIn', () => {
          return H;
        }),
        n.d(r, 'easeCircleOut', () => {
          return q;
        }),
        n.d(r, 'easeCircleInOut', () => {
          return V;
        }),
        n.d(r, 'easeBounce', () => {
          return $;
        }),
        n.d(r, 'easeBounceIn', () => {
          return K;
        }),
        n.d(r, 'easeBounceOut', () => {
          return $;
        }),
        n.d(r, 'easeBounceInOut', () => {
          return Q;
        }),
        n.d(r, 'easeBack', () => {
          return et;
        }),
        n.d(r, 'easeBackIn', () => {
          return J;
        }),
        n.d(r, 'easeBackOut', () => {
          return tt;
        }),
        n.d(r, 'easeBackInOut', () => {
          return et;
        }),
        n.d(r, 'easeElastic', () => {
          return it;
        }),
        n.d(r, 'easeElasticIn', () => {
          return rt;
        }),
        n.d(r, 'easeElasticOut', () => {
          return it;
        }),
        n.d(r, 'easeElasticInOut', () => {
          return ot;
        });
      const i = n(1);
      const o = n(207);
      const a = n(90);
      const s = n(5);
      const u = n(0);
      function c(t) {
        return (c =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      let h;
      let l;
      let f = 0;
      let d = 0;
      let p = 0;
      let g = 0;
      let v = 0;
      let y = 0;
      const m =
        (typeof performance === 'undefined' ? 'undefined' : c(performance)) === 'object' &&
        performance.now
          ? performance
          : Date;
      const b =
        (typeof window === 'undefined' ? 'undefined' : c(window)) === 'object' &&
        window.requestAnimationFrame
          ? window.requestAnimationFrame.bind(window)
          : function (t) {
              setTimeout(t, 17);
            };
      function x() {
        return v || (b(M), (v = m.now() + y));
      }
      function M() {
        v = 0;
      }
      function S() {
        this._call = this._time = this._next = null;
      }
      function w(t, e, n) {
        const r = new S();
        return r.restart(t, e, n), r;
      }
      function O() {
        (v = (g = m.now()) + y), (f = d = 0);
        try {
          !(function () {
            x(), ++f;
            for (var t, e = h; e; ) (t = v - e._time) >= 0 && e._call.call(null, t), (e = e._next);
            --f;
          })();
        } finally {
          (f = 0),
            (function () {
              let t;
              let e;
              let n = h;
              let r = 1 / 0;
              for (; n; )
                n._call
                  ? (r > n._time && (r = n._time), (t = n), (n = n._next))
                  : ((e = n._next), (n._next = null), (n = t ? (t._next = e) : (h = e)));
              (l = t), E(r);
            })(),
            (v = 0);
        }
      }
      function C() {
        const t = m.now();
        const e = t - g;
        e > 1e3 && ((y -= e), (g = t));
      }
      function E(t) {
        f ||
          (d && (d = clearTimeout(d)),
          t - v > 24
            ? (t < 1 / 0 && (d = setTimeout(O, t - m.now() - y)), p && (p = clearInterval(p)))
            : (p || ((g = m.now()), (p = setInterval(C, 1e3))), (f = 1), b(O)));
      }
      function k(t) {
        return +t;
      }
      function T(t) {
        return t * t;
      }
      function P(t) {
        return t * (2 - t);
      }
      function I(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
      }
      function A(t) {
        return t * t * t;
      }
      function j(t) {
        return --t * t * t + 1;
      }
      function N(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
      }
      S.prototype = w.prototype = {
        constructor: S,
        restart(t, e, n) {
          if (typeof t !== 'function') throw new TypeError('callback is not a function');
          (n = (n == null ? x() : +n) + (e == null ? 0 : +e)),
            this._next || l === this || (l ? (l._next = this) : (h = this), (l = this)),
            (this._call = t),
            (this._time = n),
            E();
        },
        stop() {
          this._call && ((this._call = null), (this._time = 1 / 0), E());
        },
      };
      var _ = (function t(e) {
        function n(t) {
          return Math.pow(t, e);
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      var B = (function t(e) {
        function n(t) {
          return 1 - Math.pow(1 - t, e);
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      var L = (function t(e) {
        function n(t) {
          return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
        }
        return (e = +e), (n.exponent = t), n;
      })(3);
      const D = Math.PI;
      const R = D / 2;
      function Y(t) {
        return +t == 1 ? 1 : 1 - Math.cos(t * R);
      }
      function F(t) {
        return Math.sin(t * R);
      }
      function X(t) {
        return (1 - Math.cos(D * t)) / 2;
      }
      function z(t) {
        return 1.0009775171065494 * (Math.pow(2, -10 * t) - 0.0009765625);
      }
      function W(t) {
        return z(1 - +t);
      }
      function G(t) {
        return 1 - z(t);
      }
      function U(t) {
        return ((t *= 2) <= 1 ? z(1 - t) : 2 - z(t - 1)) / 2;
      }
      function H(t) {
        return 1 - Math.sqrt(1 - t * t);
      }
      function q(t) {
        return Math.sqrt(1 - --t * t);
      }
      function V(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
      }
      const Z = 7.5625;
      function K(t) {
        return 1 - $(1 - t);
      }
      function $(t) {
        return (t = +t) < 4 / 11
          ? Z * t * t
          : t < 8 / 11
          ? Z * (t -= 6 / 11) * t + 3 / 4
          : t < 10 / 11
          ? Z * (t -= 9 / 11) * t + 15 / 16
          : Z * (t -= 21 / 22) * t + 63 / 64;
      }
      function Q(t) {
        return ((t *= 2) <= 1 ? 1 - $(1 - t) : $(t - 1) + 1) / 2;
      }
      var J = (function t(e) {
        function n(t) {
          return (t = +t) * t * (e * (t - 1) + t);
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      var tt = (function t(e) {
        function n(t) {
          return --t * t * ((t + 1) * e + t) + 1;
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      var et = (function t(e) {
        function n(t) {
          return (
            ((t *= 2) < 1 ? t * t * ((e + 1) * t - e) : (t -= 2) * t * ((e + 1) * t + e) + 2) / 2
          );
        }
        return (e = +e), (n.overshoot = t), n;
      })(1.70158);
      const nt = 2 * Math.PI;
      var rt = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= nt);
        function i(t) {
          return e * z(-(--t)) * Math.sin((r - t) / n);
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * nt);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      var it = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= nt);
        function i(t) {
          return 1 - e * z((t = +t)) * Math.sin((t + r) / n);
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * nt);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      var ot = (function t(e, n) {
        const r = Math.asin(1 / (e = Math.max(1, e))) * (n /= nt);
        function i(t) {
          return (
            ((t = 2 * t - 1) < 0
              ? e * z(-t) * Math.sin((r - t) / n)
              : 2 - e * z(t) * Math.sin((r + t) / n)) / 2
          );
        }
        return (
          (i.amplitude = function (e) {
            return t(e, n * nt);
          }),
          (i.period = function (n) {
            return t(e, n);
          }),
          i
        );
      })(1, 0.3);
      const at = function (t, e, n) {
        (t.prototype = e.prototype = n), (n.constructor = t);
      };
      function st(t, e) {
        const n = Object.create(t.prototype);
        for (const r in e) n[r] = e[r];
        return n;
      }
      function ut() {}
      const ct = '\\s*([+-]?\\d+)\\s*';
      const ht = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*';
      const lt = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
      const ft = /^#([0-9a-f]{3,8})$/;
      const dt = new RegExp(`^rgb\\(${[ct, ct, ct]}\\)$`);
      const pt = new RegExp(`^rgb\\(${[lt, lt, lt]}\\)$`);
      const gt = new RegExp(`^rgba\\(${[ct, ct, ct, ht]}\\)$`);
      const vt = new RegExp(`^rgba\\(${[lt, lt, lt, ht]}\\)$`);
      const yt = new RegExp(`^hsl\\(${[ht, lt, lt]}\\)$`);
      const mt = new RegExp(`^hsla\\(${[ht, lt, lt, ht]}\\)$`);
      const bt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      };
      function xt() {
        return this.rgb().formatHex();
      }
      function Mt() {
        return this.rgb().formatRgb();
      }
      function St(t) {
        let e;
        let n;
        return (
          (t = `${t}`.trim().toLowerCase()),
          (e = ft.exec(t))
            ? ((n = e[1].length),
              (e = parseInt(e[1], 16)),
              n === 6
                ? wt(e)
                : n === 3
                ? new kt(
                    ((e >> 8) & 15) | ((e >> 4) & 240),
                    ((e >> 4) & 15) | (240 & e),
                    ((15 & e) << 4) | (15 & e),
                    1,
                  )
                : n === 8
                ? Ot((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, (255 & e) / 255)
                : n === 4
                ? Ot(
                    ((e >> 12) & 15) | ((e >> 8) & 240),
                    ((e >> 8) & 15) | ((e >> 4) & 240),
                    ((e >> 4) & 15) | (240 & e),
                    (((15 & e) << 4) | (15 & e)) / 255,
                  )
                : null)
            : (e = dt.exec(t))
            ? new kt(e[1], e[2], e[3], 1)
            : (e = pt.exec(t))
            ? new kt((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, 1)
            : (e = gt.exec(t))
            ? Ot(e[1], e[2], e[3], e[4])
            : (e = vt.exec(t))
            ? Ot((255 * e[1]) / 100, (255 * e[2]) / 100, (255 * e[3]) / 100, e[4])
            : (e = yt.exec(t))
            ? At(e[1], e[2] / 100, e[3] / 100, 1)
            : (e = mt.exec(t))
            ? At(e[1], e[2] / 100, e[3] / 100, e[4])
            : bt.hasOwnProperty(t)
            ? wt(bt[t])
            : t === 'transparent'
            ? new kt(NaN, NaN, NaN, 0)
            : null
        );
      }
      function wt(t) {
        return new kt((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
      }
      function Ot(t, e, n, r) {
        return r <= 0 && (t = e = n = NaN), new kt(t, e, n, r);
      }
      function Ct(t) {
        return (
          t instanceof ut || (t = St(t)),
          t ? new kt((t = t.rgb()).r, t.g, t.b, t.opacity) : new kt()
        );
      }
      function Et(t, e, n, r) {
        return arguments.length === 1 ? Ct(t) : new kt(t, e, n, r == null ? 1 : r);
      }
      function kt(t, e, n, r) {
        (this.r = +t), (this.g = +e), (this.b = +n), (this.opacity = +r);
      }
      function Tt() {
        return `#${It(this.r)}${It(this.g)}${It(this.b)}`;
      }
      function Pt() {
        let t = this.opacity;
        return `${
          ((t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) === 1 ? 'rgb(' : 'rgba(') +
          Math.max(0, Math.min(255, Math.round(this.r) || 0))
        }, ${Math.max(0, Math.min(255, Math.round(this.g) || 0))}, ${Math.max(
          0,
          Math.min(255, Math.round(this.b) || 0),
        )}${t === 1 ? ')' : `, ${t})`}`;
      }
      function It(t) {
        return (
          ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? '0' : '') + t.toString(16)
        );
      }
      function At(t, e, n, r) {
        return (
          r <= 0 ? (t = e = n = NaN) : n <= 0 || n >= 1 ? (t = e = NaN) : e <= 0 && (t = NaN),
          new Nt(t, e, n, r)
        );
      }
      function jt(t) {
        if (t instanceof Nt) return new Nt(t.h, t.s, t.l, t.opacity);
        if ((t instanceof ut || (t = St(t)), !t)) return new Nt();
        if (t instanceof Nt) return t;
        const e = (t = t.rgb()).r / 255;
        const n = t.g / 255;
        const r = t.b / 255;
        const i = Math.min(e, n, r);
        const o = Math.max(e, n, r);
        let a = NaN;
        let s = o - i;
        const u = (o + i) / 2;
        return (
          s
            ? ((a =
                e === o ? (n - r) / s + 6 * (n < r) : n === o ? (r - e) / s + 2 : (e - n) / s + 4),
              (s /= u < 0.5 ? o + i : 2 - o - i),
              (a *= 60))
            : (s = u > 0 && u < 1 ? 0 : a),
          new Nt(a, s, u, t.opacity)
        );
      }
      function Nt(t, e, n, r) {
        (this.h = +t), (this.s = +e), (this.l = +n), (this.opacity = +r);
      }
      function _t(t, e, n) {
        return (
          255 *
          (t < 60
            ? e + ((n - e) * t) / 60
            : t < 180
            ? n
            : t < 240
            ? e + ((n - e) * (240 - t)) / 60
            : e)
        );
      }
      function Bt(t, e, n, r, i) {
        const o = t * t;
        const a = o * t;
        return (
          ((1 - 3 * t + 3 * o - a) * e +
            (4 - 6 * o + 3 * a) * n +
            (1 + 3 * t + 3 * o - 3 * a) * r +
            a * i) /
          6
        );
      }
      at(ut, St, {
        copy(t) {
          return Object.assign(new this.constructor(), this, t);
        },
        displayable() {
          return this.rgb().displayable();
        },
        hex: xt,
        formatHex: xt,
        formatHsl() {
          return jt(this).formatHsl();
        },
        formatRgb: Mt,
        toString: Mt,
      }),
        at(
          kt,
          Et,
          st(ut, {
            brighter(t) {
              return (
                (t = t == null ? 1 / 0.7 : Math.pow(1 / 0.7, t)),
                new kt(this.r * t, this.g * t, this.b * t, this.opacity)
              );
            },
            darker(t) {
              return (
                (t = t == null ? 0.7 : Math.pow(0.7, t)),
                new kt(this.r * t, this.g * t, this.b * t, this.opacity)
              );
            },
            rgb() {
              return this;
            },
            displayable() {
              return (
                this.r >= -0.5 &&
                this.r < 255.5 &&
                this.g >= -0.5 &&
                this.g < 255.5 &&
                this.b >= -0.5 &&
                this.b < 255.5 &&
                this.opacity >= 0 &&
                this.opacity <= 1
              );
            },
            hex: Tt,
            formatHex: Tt,
            formatRgb: Pt,
            toString: Pt,
          }),
        ),
        at(
          Nt,
          function (t, e, n, r) {
            return arguments.length === 1 ? jt(t) : new Nt(t, e, n, r == null ? 1 : r);
          },
          st(ut, {
            brighter(t) {
              return (
                (t = t == null ? 1 / 0.7 : Math.pow(1 / 0.7, t)),
                new Nt(this.h, this.s, this.l * t, this.opacity)
              );
            },
            darker(t) {
              return (
                (t = t == null ? 0.7 : Math.pow(0.7, t)),
                new Nt(this.h, this.s, this.l * t, this.opacity)
              );
            },
            rgb() {
              const t = (this.h % 360) + 360 * (this.h < 0);
              const e = isNaN(t) || isNaN(this.s) ? 0 : this.s;
              const n = this.l;
              const r = n + (n < 0.5 ? n : 1 - n) * e;
              const i = 2 * n - r;
              return new kt(
                _t(t >= 240 ? t - 240 : t + 120, i, r),
                _t(t, i, r),
                _t(t < 120 ? t + 240 : t - 120, i, r),
                this.opacity,
              );
            },
            displayable() {
              return (
                ((this.s >= 0 && this.s <= 1) || isNaN(this.s)) &&
                this.l >= 0 &&
                this.l <= 1 &&
                this.opacity >= 0 &&
                this.opacity <= 1
              );
            },
            formatHsl() {
              let t = this.opacity;
              return `${
                ((t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) === 1 ? 'hsl(' : 'hsla(') +
                (this.h || 0)
              }, ${100 * (this.s || 0)}%, ${100 * (this.l || 0)}%${t === 1 ? ')' : `, ${t})`}`;
            },
          }),
        );
      const Lt = function (t) {
        return function () {
          return t;
        };
      };
      function Dt(t, e) {
        return function (n) {
          return t + n * e;
        };
      }
      function Rt(t) {
        return (t = +t) == 1
          ? Yt
          : function (e, n) {
              return n - e
                ? (function (t, e, n) {
                    return (
                      (t = Math.pow(t, n)),
                      (e = Math.pow(e, n) - t),
                      (n = 1 / n),
                      function (r) {
                        return Math.pow(t + r * e, n);
                      }
                    );
                  })(e, n, t)
                : Lt(isNaN(e) ? n : e);
            };
      }
      function Yt(t, e) {
        const n = e - t;
        return n ? Dt(t, n) : Lt(isNaN(t) ? e : t);
      }
      const Ft = (function t(e) {
        const n = Rt(e);
        function r(t, e) {
          const r = n((t = Et(t)).r, (e = Et(e)).r);
          const i = n(t.g, e.g);
          const o = n(t.b, e.b);
          const a = Yt(t.opacity, e.opacity);
          return function (e) {
            return (t.r = r(e)), (t.g = i(e)), (t.b = o(e)), (t.opacity = a(e)), `${t}`;
          };
        }
        return (r.gamma = t), r;
      })(1);
      function Xt(t) {
        return function (e) {
          let n;
          let r;
          const i = e.length;
          let o = new Array(i);
          let a = new Array(i);
          let s = new Array(i);
          for (n = 0; n < i; ++n)
            (r = Et(e[n])), (o[n] = r.r || 0), (a[n] = r.g || 0), (s[n] = r.b || 0);
          return (
            (o = t(o)),
            (a = t(a)),
            (s = t(s)),
            (r.opacity = 1),
            function (t) {
              return (r.r = o(t)), (r.g = a(t)), (r.b = s(t)), `${r}`;
            }
          );
        };
      }
      Xt((t) => {
        const e = t.length - 1;
        return function (n) {
          const r = n <= 0 ? (n = 0) : n >= 1 ? ((n = 1), e - 1) : Math.floor(n * e);
          const i = t[r];
          const o = t[r + 1];
          const a = r > 0 ? t[r - 1] : 2 * i - o;
          const s = r < e - 1 ? t[r + 2] : 2 * o - i;
          return Bt((n - r / e) * e, a, i, o, s);
        };
      }),
        Xt((t) => {
          const e = t.length;
          return function (n) {
            const r = Math.floor(((n %= 1) < 0 ? ++n : n) * e);
            const i = t[(r + e - 1) % e];
            const o = t[r % e];
            const a = t[(r + 1) % e];
            const s = t[(r + 2) % e];
            return Bt((n - r / e) * e, i, o, a, s);
          };
        });
      const zt = function (t, e) {
        e || (e = []);
        let n;
        const r = t ? Math.min(e.length, t.length) : 0;
        const i = e.slice();
        return function (o) {
          for (n = 0; n < r; ++n) i[n] = t[n] * (1 - o) + e[n] * o;
          return i;
        };
      };
      function Wt(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      }
      function Gt(t, e) {
        let n;
        const r = e ? e.length : 0;
        const i = t ? Math.min(r, t.length) : 0;
        const o = new Array(i);
        const a = new Array(r);
        for (n = 0; n < i; ++n) o[n] = Jt(t[n], e[n]);
        for (; n < r; ++n) a[n] = e[n];
        return function (t) {
          for (n = 0; n < i; ++n) a[n] = o[n](t);
          return a;
        };
      }
      const Ut = function (t, e) {
        const n = new Date();
        return (
          (t = +t),
          (e = +e),
          function (r) {
            return n.setTime(t * (1 - r) + e * r), n;
          }
        );
      };
      const Ht = function (t, e) {
        return (
          (t = +t),
          (e = +e),
          function (n) {
            return t * (1 - n) + e * n;
          }
        );
      };
      function qt(t) {
        return (qt =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const Vt = function (t, e) {
        let n;
        const r = {};
        const i = {};
        for (n in ((t !== null && qt(t) === 'object') || (t = {}),
        (e !== null && qt(e) === 'object') || (e = {}),
        e))
          n in t ? (r[n] = Jt(t[n], e[n])) : (i[n] = e[n]);
        return function (t) {
          for (n in r) i[n] = r[n](t);
          return i;
        };
      };
      const Zt = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
      const Kt = new RegExp(Zt.source, 'g');
      const $t = function (t, e) {
        let n;
        let r;
        let i;
        let o = (Zt.lastIndex = Kt.lastIndex = 0);
        let a = -1;
        const s = [];
        const u = [];
        for (t += '', e += ''; (n = Zt.exec(t)) && (r = Kt.exec(e)); )
          (i = r.index) > o && ((i = e.slice(o, i)), s[a] ? (s[a] += i) : (s[++a] = i)),
            (n = n[0]) === (r = r[0])
              ? s[a]
                ? (s[a] += r)
                : (s[++a] = r)
              : ((s[++a] = null), u.push({ i: a, x: Ht(n, r) })),
            (o = Kt.lastIndex);
        return (
          o < e.length && ((i = e.slice(o)), s[a] ? (s[a] += i) : (s[++a] = i)),
          s.length < 2
            ? u[0]
              ? (function (t) {
                  return function (e) {
                    return `${t(e)}`;
                  };
                })(u[0].x)
              : (function (t) {
                  return function () {
                    return t;
                  };
                })(e)
            : ((e = u.length),
              function (t) {
                for (var n, r = 0; r < e; ++r) s[(n = u[r]).i] = n.x(t);
                return s.join('');
              })
        );
      };
      function Qt(t) {
        return (Qt =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      var Jt = function (t, e) {
        let n;
        const r = Qt(e);
        return e == null || r === 'boolean'
          ? Lt(e)
          : (r === 'number'
              ? Ht
              : r === 'string'
              ? (n = St(e))
                ? ((e = n), Ft)
                : $t
              : e instanceof St
              ? Ft
              : e instanceof Date
              ? Ut
              : Wt(e)
              ? zt
              : Array.isArray(e)
              ? Gt
              : (typeof e.valueOf !== 'function' && typeof e.toString !== 'function') || isNaN(e)
              ? Vt
              : Ht)(t, e);
      };
      const te = n(29);
      const ee = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      function ne(t, e, n) {
        let i;
        const o = e.startTime;
        if (n < o + e.delay || e._paused) return !1;
        const a = e.duration;
        const s = e.easing;
        if (((n = n - o - e.delay), e.repeat)) (i = (n % a) / a), (i = r[s](i));
        else {
          if (!((i = n / a) < 1)) return e.onFrame ? t.attr(e.onFrame(1)) : t.attr(e.toAttrs), !0;
          i = r[s](i);
        }
        if (e.onFrame) {
          const c = e.onFrame(i);
          t.attr(c);
        } else
          !(function (t, e, n) {
            const r = {};
            const i = e.fromAttrs;
            const o = e.toAttrs;
            if (!t.destroyed) {
              let a;
              let s;
              let c;
              let h;
              for (const l in o)
                if (!Object(u.h)(i[l], o[l]))
                  if (l === 'path') {
                    let f = o[l];
                    let d = i[l];
                    f.length > d.length
                      ? ((f = te.c(o[l])),
                        (d = te.c(i[l])),
                        (d = te.a(d, f)),
                        (d = te.b(d, f)),
                        (e.fromAttrs.path = d),
                        (e.toAttrs.path = f))
                      : e.pathFormatted ||
                        ((f = te.c(o[l])),
                        (d = te.c(i[l])),
                        (d = te.b(d, f)),
                        (e.fromAttrs.path = d),
                        (e.toAttrs.path = f),
                        (e.pathFormatted = !0)),
                      (r[l] = []);
                    for (let p = 0; p < f.length; p++) {
                      for (var g = f[p], v = d[p], y = [], m = 0; m < g.length; m++)
                        Object(u.k)(g[m]) && v && Object(u.k)(v[m])
                          ? ((a = Jt(v[m], g[m])), y.push(a(n)))
                          : y.push(g[m]);
                      r[l].push(y);
                    }
                  } else if (l === 'matrix') {
                    const b = ((c = i[l] || ee), (Wt((h = o[l] || ee)) ? zt : Gt)(c, h))(n);
                    r[l] = b;
                  } else
                    ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(l) &&
                    ((s = o[l]), /^[r,R,L,l]{1}[\s]*\(/.test(s))
                      ? (r[l] = o[l])
                      : Object(u.i)(o[l]) || ((a = Jt(i[l], o[l])), (r[l] = a(n)));
              t.attr(r);
            }
          })(t, e, i);
        return !1;
      }
      const re = (function () {
        function t(t) {
          (this.animators = []), (this.current = 0), (this.timer = null), (this.canvas = t);
        }
        return (
          (t.prototype.initTimer = function () {
            let t;
            let e;
            let n;
            const r = this;
            this.timer = w((i) => {
              if (((r.current = i), r.animators.length > 0)) {
                for (let o = r.animators.length - 1; o >= 0; o--)
                  if ((t = r.animators[o]).destroyed) r.removeAnimator(o);
                  else {
                    if (!t.isAnimatePaused())
                      for (let a = (e = t.get('animations')).length - 1; a >= 0; a--)
                        (n = e[a]), ne(t, n, i) && (e.splice(a, 1), !1, n.callback && n.callback());
                    e.length === 0 && r.removeAnimator(o);
                  }
                r.canvas.get('autoDraw') || r.canvas.draw();
              }
            });
          }),
          (t.prototype.addAnimator = function (t) {
            this.animators.push(t);
          }),
          (t.prototype.removeAnimator = function (t) {
            this.animators.splice(t, 1);
          }),
          (t.prototype.isAnimating = function () {
            return !!this.animators.length;
          }),
          (t.prototype.stop = function () {
            this.timer && this.timer.stop();
          }),
          (t.prototype.stopAllAnimations = function (t) {
            void 0 === t && (t = !0),
              this.animators.forEach((e) => {
                e.stopAnimate(t);
              }),
              (this.animators = []),
              this.canvas.draw();
          }),
          (t.prototype.getTime = function () {
            return this.current;
          }),
          t
        );
      })();
      const ie = n(86);
      const oe = [
        'mousedown',
        'mouseup',
        'dblclick',
        'mouseout',
        'mouseover',
        'mousemove',
        'mouseleave',
        'mouseenter',
        'touchstart',
        'touchmove',
        'touchend',
        'dragenter',
        'dragover',
        'dragleave',
        'drop',
        'contextmenu',
        'mousewheel',
      ];
      function ae(t, e, n) {
        (n.name = e), (n.target = t), (n.currentTarget = t), (n.delegateTarget = t), t.emit(e, n);
      }
      function se(t, e, n) {
        if (n.bubbles) {
          let r = void 0;
          let i = !1;
          if (
            (e === 'mouseenter'
              ? ((r = n.fromShape), (i = !0))
              : e === 'mouseleave' && ((i = !0), (r = n.toShape)),
            t.isCanvas() && i)
          )
            return;
          if (r && Object(s.g)(t, r)) return void (n.bubbles = !1);
          (n.name = e), (n.currentTarget = t), (n.delegateTarget = t), t.emit(e, n);
        }
      }
      const ue = (function () {
        function t(t) {
          const e = this;
          (this.draggingShape = null),
            (this.dragging = !1),
            (this.currentShape = null),
            (this.mousedownShape = null),
            (this.mousedownPoint = null),
            (this._eventCallback = function (t) {
              const n = t.type;
              e._triggerEvent(n, t);
            }),
            (this._onDocumentMove = function (t) {
              if (e.canvas.get('el') !== t.target && (e.dragging || e.currentShape)) {
                const n = e._getPointInfo(t);
                e.dragging && e._emitEvent('drag', t, n, e.draggingShape);
              }
            }),
            (this._onDocumentMouseUp = function (t) {
              if (e.canvas.get('el') !== t.target && e.dragging) {
                const n = e._getPointInfo(t);
                e.draggingShape && e._emitEvent('drop', t, n, null),
                  e._emitEvent('dragend', t, n, e.draggingShape),
                  e._afterDrag(e.draggingShape, n, t);
              }
            }),
            (this.canvas = t.canvas);
        }
        return (
          (t.prototype.init = function () {
            this._bindEvents();
          }),
          (t.prototype._bindEvents = function () {
            const t = this;
            const e = this.canvas.get('el');
            Object(s.a)(oe, (n) => {
              e.addEventListener(n, t._eventCallback);
            }),
              document &&
                (document.addEventListener('mousemove', this._onDocumentMove),
                document.addEventListener('mouseup', this._onDocumentMouseUp));
          }),
          (t.prototype._clearEvents = function () {
            const t = this;
            const e = this.canvas.get('el');
            Object(s.a)(oe, (n) => {
              e.removeEventListener(n, t._eventCallback);
            }),
              document &&
                (document.removeEventListener('mousemove', this._onDocumentMove),
                document.removeEventListener('mouseup', this._onDocumentMouseUp));
          }),
          (t.prototype._getEventObj = function (t, e, n, r, i, o) {
            const a = new ie.a(t, e);
            return (
              (a.fromShape = i),
              (a.toShape = o),
              (a.x = n.x),
              (a.y = n.y),
              (a.clientX = n.clientX),
              (a.clientY = n.clientY),
              a.propagationPath.push(r),
              a
            );
          }),
          (t.prototype._getShape = function (t, e) {
            return this.canvas.getShape(t.x, t.y, e);
          }),
          (t.prototype._getPointInfo = function (t) {
            const e = this.canvas;
            const n = e.getClientByEvent(t);
            const r = e.getPointByEvent(t);
            return { x: r.x, y: r.y, clientX: n.x, clientY: n.y };
          }),
          (t.prototype._triggerEvent = function (t, e) {
            const n = this._getPointInfo(e);
            const r = this._getShape(n, e);
            const i = this[`_on${t}`];
            let o = !1;
            if (i) i.call(this, n, r, e);
            else {
              const a = this.currentShape;
              t === 'mouseenter' || t === 'dragenter' || t === 'mouseover'
                ? (this._emitEvent(t, e, n, null, null, r),
                  r && this._emitEvent(t, e, n, r, null, r),
                  t === 'mouseenter' &&
                    this.draggingShape &&
                    this._emitEvent('dragenter', e, n, null))
                : t === 'mouseleave' || t === 'dragleave' || t === 'mouseout'
                ? ((o = !0),
                  a && this._emitEvent(t, e, n, a, a, null),
                  this._emitEvent(t, e, n, null, a, null),
                  t === 'mouseleave' &&
                    this.draggingShape &&
                    this._emitEvent('dragleave', e, n, null))
                : this._emitEvent(t, e, n, r, null, null);
            }
            if ((o || (this.currentShape = r), r && !r.get('destroyed'))) {
              const s = this.canvas;
              s.get('el').style.cursor = r.attr('cursor') || s.get('cursor');
            }
          }),
          (t.prototype._onmousedown = function (t, e, n) {
            n.button === 0 &&
              ((this.mousedownShape = e),
              (this.mousedownPoint = t),
              (this.mousedownTimeStamp = n.timeStamp)),
              this._emitEvent('mousedown', n, t, e, null, null);
          }),
          (t.prototype._emitMouseoverEvents = function (t, e, n, r) {
            const i = this.canvas.get('el');
            n !== r &&
              (n &&
                (this._emitEvent('mouseout', t, e, n, n, r),
                this._emitEvent('mouseleave', t, e, n, n, r),
                (r && !r.get('destroyed')) || (i.style.cursor = this.canvas.get('cursor'))),
              r &&
                (this._emitEvent('mouseover', t, e, r, n, r),
                this._emitEvent('mouseenter', t, e, r, n, r)));
          }),
          (t.prototype._emitDragoverEvents = function (t, e, n, r, i) {
            r
              ? (r !== n &&
                  (n && this._emitEvent('dragleave', t, e, n, n, r),
                  this._emitEvent('dragenter', t, e, r, n, r)),
                i || this._emitEvent('dragover', t, e, r))
              : n && this._emitEvent('dragleave', t, e, n, n, r),
              i && this._emitEvent('dragover', t, e, r);
          }),
          (t.prototype._afterDrag = function (t, e, n) {
            t && (t.set('capture', !0), (this.draggingShape = null)), (this.dragging = !1);
            const r = this._getShape(e, n);
            r !== t && this._emitMouseoverEvents(n, e, t, r), (this.currentShape = r);
          }),
          (t.prototype._onmouseup = function (t, e, n) {
            if (n.button === 0) {
              const r = this.draggingShape;
              this.dragging
                ? (r && this._emitEvent('drop', n, t, e),
                  this._emitEvent('dragend', n, t, r),
                  this._afterDrag(r, t, n))
                : (this._emitEvent('mouseup', n, t, e),
                  e === this.mousedownShape && this._emitEvent('click', n, t, e),
                  (this.mousedownShape = null),
                  (this.mousedownPoint = null));
            }
          }),
          (t.prototype._ondragover = function (t, e, n) {
            n.preventDefault();
            const r = this.currentShape;
            this._emitDragoverEvents(n, t, r, e, !0);
          }),
          (t.prototype._onmousemove = function (t, e, n) {
            const r = this.canvas;
            const i = this.currentShape;
            let o = this.draggingShape;
            if (this.dragging)
              o && this._emitDragoverEvents(n, t, i, e, !1), this._emitEvent('drag', n, t, o);
            else {
              const a = this.mousedownPoint;
              if (a) {
                const s = this.mousedownShape;
                const u = n.timeStamp - this.mousedownTimeStamp;
                const c = a.clientX - t.clientX;
                const h = a.clientY - t.clientY;
                u > 120 || c * c + h * h > 40
                  ? s && s.get('draggable')
                    ? ((o = this.mousedownShape).set('capture', !1),
                      (this.draggingShape = o),
                      (this.dragging = !0),
                      this._emitEvent('dragstart', n, t, o),
                      (this.mousedownShape = null),
                      (this.mousedownPoint = null))
                    : !s && r.get('draggable')
                    ? ((this.dragging = !0),
                      this._emitEvent('dragstart', n, t, null),
                      (this.mousedownShape = null),
                      (this.mousedownPoint = null))
                    : (this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e))
                  : (this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e));
              } else this._emitMouseoverEvents(n, t, i, e), this._emitEvent('mousemove', n, t, e);
            }
          }),
          (t.prototype._emitEvent = function (t, e, n, r, i, o) {
            const a = this._getEventObj(t, e, n, r, i, o);
            if (r) {
              (a.shape = r), ae(r, t, a);
              for (let s = r.getParent(); s; )
                s.emitDelegation(t, a),
                  a.propagationStopped || se(s, t, a),
                  a.propagationPath.push(s),
                  (s = s.getParent());
            } else {
              ae(this.canvas, t, a);
            }
          }),
          (t.prototype.destroy = function () {
            this._clearEvents(),
              (this.canvas = null),
              (this.currentShape = null),
              (this.draggingShape = null),
              (this.mousedownPoint = null),
              (this.mousedownShape = null),
              (this.mousedownTimeStamp = null);
          }),
          t
        );
      })();
      const ce = Object(o.a)();
      const he = ce && ce.name === 'firefox';
      !(function (t) {
        function e(e) {
          const n = t.call(this, e) || this;
          return n.initContainer(), n.initDom(), n.initEvents(), n.initTimeline(), n;
        }
        Object(i.c)(e, t),
          (e.prototype.getDefaultCfg = function () {
            const e = t.prototype.getDefaultCfg.call(this);
            return (e.cursor = 'default'), (e.supportCSSTransform = !1), e;
          }),
          (e.prototype.initContainer = function () {
            let t = this.get('container');
            Object(s.h)(t) && ((t = document.getElementById(t)), this.set('container', t));
          }),
          (e.prototype.initDom = function () {
            const t = this.createDom();
            this.set('el', t),
              this.get('container').appendChild(t),
              this.setDOMSize(this.get('width'), this.get('height'));
          }),
          (e.prototype.initEvents = function () {
            const t = new ue({ canvas: this });
            t.init(), this.set('eventController', t);
          }),
          (e.prototype.initTimeline = function () {
            const t = new re(this);
            this.set('timeline', t);
          }),
          (e.prototype.setDOMSize = function (t, e) {
            const n = this.get('el');
            s.c && ((n.style.width = `${t}px`), (n.style.height = `${e}px`));
          }),
          (e.prototype.changeSize = function (t, e) {
            this.setDOMSize(t, e),
              this.set('width', t),
              this.set('height', e),
              this.onCanvasChange('changeSize');
          }),
          (e.prototype.getRenderer = function () {
            return this.get('renderer');
          }),
          (e.prototype.getCursor = function () {
            return this.get('cursor');
          }),
          (e.prototype.setCursor = function (t) {
            this.set('cursor', t);
            const e = this.get('el');
            s.c && e && (e.style.cursor = t);
          }),
          (e.prototype.getPointByEvent = function (t) {
            if (this.get('supportCSSTransform')) {
              if (he && !Object(s.e)(t.layerX) && t.layerX !== t.offsetX)
                return { x: t.layerX, y: t.layerY };
              if (!Object(s.e)(t.offsetX)) return { x: t.offsetX, y: t.offsetY };
            }
            const e = this.getClientByEvent(t);
            const n = e.x;
            const r = e.y;
            return this.getPointByClient(n, r);
          }),
          (e.prototype.getClientByEvent = function (t) {
            let e = t;
            return (
              t.touches && (e = t.type === 'touchend' ? t.changedTouches[0] : t.touches[0]),
              { x: e.clientX, y: e.clientY }
            );
          }),
          (e.prototype.getPointByClient = function (t, e) {
            const n = this.get('el').getBoundingClientRect();
            return { x: t - n.left, y: e - n.top };
          }),
          (e.prototype.getClientByPoint = function (t, e) {
            const n = this.get('el').getBoundingClientRect();
            return { x: t + n.left, y: e + n.top };
          }),
          (e.prototype.draw = function () {}),
          (e.prototype.removeDom = function () {
            const t = this.get('el');
            t.parentNode.removeChild(t);
          }),
          (e.prototype.clearEvents = function () {
            this.get('eventController').destroy();
          }),
          (e.prototype.isCanvas = function () {
            return !0;
          }),
          (e.prototype.getParent = function () {
            return null;
          }),
          (e.prototype.destroy = function () {
            const e = this.get('timeline');
            this.get('destroyed') ||
              (this.clear(),
              e && e.stop(),
              this.clearEvents(),
              this.removeDom(),
              t.prototype.destroy.call(this));
          });
      })(a.a);
    },
    ,
    function (t, e, n) {
      'use strict';
      const r = {};
      n.r(r),
        n.d(r, 'distance', () => {
          return h;
        }),
        n.d(r, 'isNumberEqual', () => {
          return l;
        }),
        n.d(r, 'getBBoxByArray', () => {
          return f;
        }),
        n.d(r, 'getBBoxRange', () => {
          return d;
        }),
        n.d(r, 'piMod', () => {
          return p;
        });
      const i = new Map();
      function o(t, e) {
        i.set(t, e);
      }
      const a = function (t) {
        const e = t.attr();
        return { x: e.x, y: e.y, width: e.width, height: e.height };
      };
      const s = function (t) {
        const e = t.attr();
        const n = e.x;
        const r = e.y;
        const i = e.r;
        return { x: n - i, y: r - i, width: 2 * i, height: 2 * i };
      };
      function u(t) {
        return Math.min.apply(null, t);
      }
      function c(t) {
        return Math.max.apply(null, t);
      }
      function h(t, e, n, r) {
        const i = t - n;
        const o = e - r;
        return Math.sqrt(i * i + o * o);
      }
      function l(t, e) {
        return Math.abs(t - e) < 0.001;
      }
      function f(t, e) {
        const n = u(t);
        const r = u(e);
        return { x: n, y: r, width: c(t) - n, height: c(e) - r };
      }
      function d(t, e, n, r) {
        return { minX: u([t, n]), maxX: c([t, n]), minY: u([e, r]), maxY: c([e, r]) };
      }
      function p(t) {
        return (t + 2 * Math.PI) % (2 * Math.PI);
      }
      n(51);
      function g(t, e, n, r) {
        const i = 1 - r;
        return i * i * t + 2 * r * i * e + r * r * n;
      }
      function v(t, e, n) {
        const r = t + n - 2 * e;
        if (l(r, 0)) return [0.5];
        const i = (t - e) / r;
        return i <= 1 && i >= 0 ? [i] : [];
      }
      const y = function (t, e, n, r, i, o) {
        const a = v(t, n, i)[0];
        const s = v(e, r, o)[0];
        const u = [t, i];
        const c = [e, o];
        return (
          void 0 !== a && u.push(g(t, n, i, a)), void 0 !== s && c.push(g(e, r, o, s)), f(u, c)
        );
      };
      function m(t, e, n, r, i) {
        const o = 1 - i;
        return o * o * o * t + 3 * e * i * o * o + 3 * n * i * i * o + r * i * i * i;
      }
      function b(t, e, n, r) {
        let i;
        let o;
        let a;
        const s = -3 * t + 9 * e - 9 * n + 3 * r;
        const u = 6 * t - 12 * e + 6 * n;
        const c = 3 * e - 3 * t;
        const h = [];
        if (l(s, 0)) l(u, 0) || ((i = -c / u) >= 0 && i <= 1 && h.push(i));
        else {
          const f = u * u - 4 * s * c;
          l(f, 0)
            ? h.push(-u / (2 * s))
            : f > 0 &&
              ((o = (-u - (a = Math.sqrt(f))) / (2 * s)),
              (i = (-u + a) / (2 * s)) >= 0 && i <= 1 && h.push(i),
              o >= 0 && o <= 1 && h.push(o));
        }
        return h;
      }
      const x = function (t, e, n, r, i, o, a, s) {
        for (
          var u = [t, a], c = [e, s], h = b(t, n, i, a), l = b(e, r, o, s), d = 0;
          d < h.length;
          d++
        )
          u.push(m(t, n, i, a, h[d]));
        for (d = 0; d < l.length; d++) c.push(m(e, r, o, s, l[d]));
        return f(u, c);
      };
      function M(t, e, n, r, i, o) {
        return n * Math.cos(i) * Math.cos(o) - r * Math.sin(i) * Math.sin(o) + t;
      }
      function S(t, e, n, r, i, o) {
        return n * Math.sin(i) * Math.cos(o) + r * Math.cos(i) * Math.sin(o) + e;
      }
      const w = function (t, e, n, r, i, o, a) {
        for (
          var s = (function (t, e, n) {
              return Math.atan((-e / t) * Math.tan(n));
            })(n, r, i),
            u = 1 / 0,
            c = -1 / 0,
            h = [o, a],
            l = 2 * -Math.PI;
          l <= 2 * Math.PI;
          l += Math.PI
        ) {
          const f = s + l;
          o < a ? o < f && f < a && h.push(f) : a < f && f < o && h.push(f);
        }
        for (l = 0; l < h.length; l++) {
          const d = M(t, 0, n, r, i, h[l]);
          d < u && (u = d), d > c && (c = d);
        }
        const p = (function (t, e, n) {
          return Math.atan(e / (t * Math.tan(n)));
        })(n, r, i);
        let g = 1 / 0;
        let v = -1 / 0;
        const y = [o, a];
        for (l = 2 * -Math.PI; l <= 2 * Math.PI; l += Math.PI) {
          const m = p + l;
          o < a ? o < m && m < a && y.push(m) : a < m && m < o && y.push(m);
        }
        for (l = 0; l < y.length; l++) {
          const b = S(0, e, n, r, i, y[l]);
          b < g && (g = b), b > v && (v = b);
        }
        return { x: u, y: g, width: c - u, height: v - g };
      };
      function O(t, e) {
        return t && e
          ? {
              minX: Math.min(t.minX, e.minX),
              minY: Math.min(t.minY, e.minY),
              maxX: Math.max(t.maxX, e.maxX),
              maxY: Math.max(t.maxY, e.maxY),
            }
          : t || e;
      }
      function C(t, e) {
        const n = t.get('startArrowShape');
        const r = t.get('endArrowShape');
        return n && (e = O(e, n.getCanvasBBox())), r && (e = O(e, r.getCanvasBBox())), e;
      }
      const E = n(42);
      const k = n(43);
      const T = n(0);
      function P(t, e) {
        const n = t.prePoint;
        const r = t.currentPoint;
        const i = t.nextPoint;
        const o = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2);
        const a = Math.pow(r[0] - i[0], 2) + Math.pow(r[1] - i[1], 2);
        const s = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2);
        const u = Math.acos((o + a - s) / (2 * Math.sqrt(o) * Math.sqrt(a)));
        if (!u || Math.sin(u) === 0 || Object(T.l)(u, 0)) return { xExtra: 0, yExtra: 0 };
        let c = Math.abs(Math.atan2(i[1] - r[1], i[0] - r[0]));
        let h = Math.abs(Math.atan2(i[0] - r[0], i[1] - r[1]));
        return (
          (c = c > Math.PI / 2 ? Math.PI - c : c),
          (h = h > Math.PI / 2 ? Math.PI - h : h),
          {
            xExtra: Math.cos(u / 2 - c) * ((e / 2) * (1 / Math.sin(u / 2))) - e / 2 || 0,
            yExtra: Math.cos(h - u / 2) * ((e / 2) * (1 / Math.sin(u / 2))) - e / 2 || 0,
          }
        );
      }
      o('rect', a),
        o('image', a),
        o('circle', s),
        o('marker', s),
        o('polyline', (t) => {
          for (var e = t.attr().points, n = [], i = [], o = 0; o < e.length; o++) {
            const a = e[o];
            n.push(a[0]), i.push(a[1]);
          }
          const s = r.getBBoxByArray(n, i);
          const u = s.x;
          const c = s.y;
          let h = { minX: u, minY: c, maxX: u + s.width, maxY: c + s.height };
          return {
            x: (h = C(t, h)).minX,
            y: h.minY,
            width: h.maxX - h.minX,
            height: h.maxY - h.minY,
          };
        }),
        o('polygon', (t) => {
          for (var e = t.attr().points, n = [], i = [], o = 0; o < e.length; o++) {
            const a = e[o];
            n.push(a[0]), i.push(a[1]);
          }
          return r.getBBoxByArray(n, i);
        }),
        o('text', (t) => {
          const e = t.attr();
          const n = e.x;
          const r = e.y;
          const i = e.text;
          const o = e.fontSize;
          const a = e.lineHeight;
          let s = e.font;
          s || (s = Object(E.a)(e));
          let u;
          const c = Object(E.c)(i, s);
          if (c) {
            const h = e.textAlign;
            const l = e.textBaseline;
            const f = Object(E.b)(i, o, a);
            const d = { x: n, y: r - f };
            h && (h === 'end' || h === 'right' ? (d.x -= c) : h === 'center' && (d.x -= c / 2)),
              l && (l === 'top' ? (d.y += f) : l === 'middle' && (d.y += f / 2)),
              (u = { x: d.x, y: d.y, width: c, height: f });
          } else u = { x: n, y: r, width: 0, height: 0 };
          return u;
        }),
        o('path', (t) => {
          const e = t.attr();
          const n = e.path;
          const r = e.stroke ? e.lineWidth : 0;
          const i = (function (t, e) {
            for (var n = [], r = [], i = [], o = 0; o < t.length; o++) {
              var a = (g = t[o]).currentPoint;
              const s = g.params;
              const u = g.prePoint;
              let c = void 0;
              switch (g.command) {
                case 'Q':
                  c = y(u[0], u[1], s[1], s[2], s[3], s[4]);
                  break;
                case 'C':
                  c = x(u[0], u[1], s[1], s[2], s[3], s[4], s[5], s[6]);
                  break;
                case 'A':
                  var h = g.arcParams;
                  c = w(h.cx, h.cy, h.rx, h.ry, h.xRotation, h.startAngle, h.endAngle);
                  break;
                default:
                  n.push(a[0]), r.push(a[1]);
              }
              c && ((g.box = c), n.push(c.x, c.x + c.width), r.push(c.y, c.y + c.height)),
                e &&
                  (g.command === 'L' || g.command === 'M') &&
                  g.prePoint &&
                  g.nextPoint &&
                  i.push(g);
            }
            (n = n.filter((t) => {
              return !Number.isNaN(t);
            })),
              (r = r.filter((t) => {
                return !Number.isNaN(t);
              }));
            let l = Object(T.q)(n);
            let f = Object(T.q)(r);
            let d = Object(T.p)(n);
            let p = Object(T.p)(r);
            if (i.length === 0) return { x: l, y: f, width: d - l, height: p - f };
            for (o = 0; o < i.length; o++) {
              var g;
              (a = (g = i[o]).currentPoint)[0] === l
                ? (l -= P(g, e).xExtra)
                : a[0] === d && (d += P(g, e).xExtra),
                a[1] === f ? (f -= P(g, e).yExtra) : a[1] === p && (p += P(g, e).yExtra);
            }
            return { x: l, y: f, width: d - l, height: p - f };
          })(t.get('segments') || Object(k.c)(n), r);
          const o = i.x;
          const a = i.y;
          let s = { minX: o, minY: a, maxX: o + i.width, maxY: a + i.height };
          return {
            x: (s = C(t, s)).minX,
            y: s.minY,
            width: s.maxX - s.minX,
            height: s.maxY - s.minY,
          };
        }),
        o('line', (t) => {
          const e = t.attr();
          const n = e.x1;
          const r = e.y1;
          const i = e.x2;
          const o = e.y2;
          let a = {
            minX: Math.min(n, i),
            maxX: Math.max(n, i),
            minY: Math.min(r, o),
            maxY: Math.max(r, o),
          };
          return {
            x: (a = C(t, a)).minX,
            y: a.minY,
            width: a.maxX - a.minX,
            height: a.maxY - a.minY,
          };
        }),
        o('ellipse', (t) => {
          const e = t.attr();
          const n = e.x;
          const r = e.y;
          const i = e.rx;
          const o = e.ry;
          return { x: n - i, y: r - o, width: 2 * i, height: 2 * o };
        });
    },
    function (t, e, n) {
      'use strict';
      (function (t) {
        n.d(e, 'a', () => {
          return f;
        });
        const r = function () {
          for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
          const r = Array(t);
          let i = 0;
          for (e = 0; e < n; e++)
            for (let o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];
          return r;
        };
        const i = function (t, e, n) {
          (this.name = t), (this.version = e), (this.os = n), (this.type = 'browser');
        };
        const o = function (e) {
          (this.version = e), (this.type = 'node'), (this.name = 'node'), (this.os = t.platform);
        };
        const a = function (t, e, n, r) {
          (this.name = t),
            (this.version = e),
            (this.os = n),
            (this.bot = r),
            (this.type = 'bot-device');
        };
        const s = function () {
          (this.type = 'bot'),
            (this.bot = !0),
            (this.name = 'bot'),
            (this.version = null),
            (this.os = null);
        };
        const u = function () {
          (this.type = 'react-native'),
            (this.name = 'react-native'),
            (this.version = null),
            (this.os = null);
        };
        const c = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
        const h = [
          ['aol', /AOLShield\/([0-9\._]+)/],
          ['edge', /Edge\/([0-9\._]+)/],
          ['edge-ios', /EdgiOS\/([0-9\._]+)/],
          ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
          ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
          ['samsung', /SamsungBrowser\/([0-9\.]+)/],
          ['silk', /\bSilk\/([0-9._-]+)\b/],
          ['miui', /MiuiBrowser\/([0-9\.]+)$/],
          ['beaker', /BeakerBrowser\/([0-9\.]+)/],
          ['edge-chromium', /EdgA?\/([0-9\.]+)/],
          ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
          ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
          ['fxios', /FxiOS\/([0-9\.]+)/],
          ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
          ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
          ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
          ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ['ie', /MSIE\s(7\.0)/],
          ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ['android', /Android\s([0-9\.]+)/],
          ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ['safari', /Version\/([0-9\._]+).*Safari/],
          ['facebook', /FBAV\/([0-9\.]+)/],
          ['instagram', /Instagram\s([0-9\.]+)/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          [
            'searchbot',
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ];
        const l = [
          ['iOS', /iP(hone|od|ad)/],
          ['Android OS', /Android/],
          ['BlackBerry OS', /BlackBerry|BB10/],
          ['Windows Mobile', /IEMobile/],
          ['Amazon OS', /Kindle/],
          ['Windows 3.11', /Win16/],
          ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
          ['Windows 98', /(Windows 98)|(Win98)/],
          ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
          ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
          ['Windows Server 2003', /(Windows NT 5.2)/],
          ['Windows Vista', /(Windows NT 6.0)/],
          ['Windows 7', /(Windows NT 6.1)/],
          ['Windows 8', /(Windows NT 6.2)/],
          ['Windows 8.1', /(Windows NT 6.3)/],
          ['Windows 10', /(Windows NT 10.0)/],
          ['Windows ME', /Windows ME/],
          ['Open BSD', /OpenBSD/],
          ['Sun OS', /SunOS/],
          ['Chrome OS', /CrOS/],
          ['Linux', /(Linux)|(X11)/],
          ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
          ['QNX', /QNX/],
          ['BeOS', /BeOS/],
          ['OS/2', /OS\/2/],
        ];
        function f(e) {
          return e
            ? p(e)
            : typeof document === 'undefined' &&
              typeof navigator !== 'undefined' &&
              navigator.product === 'ReactNative'
            ? new u()
            : typeof navigator !== 'undefined'
            ? p(navigator.userAgent)
            : void 0 !== t && t.version
            ? new o(t.version.slice(1))
            : null;
        }
        function d(t) {
          return (
            t !== '' &&
            h.reduce((e, n) => {
              const r = n[0];
              const i = n[1];
              if (e) return e;
              const o = i.exec(t);
              return !!o && [r, o];
            }, !1)
          );
        }
        function p(t) {
          const e = d(t);
          if (!e) return null;
          const n = e[0];
          const o = e[1];
          if (n === 'searchbot') return new s();
          let u = o[1] && o[1].split(/[._]/).slice(0, 3);
          u
            ? u.length < 3 &&
              (u = r(
                u,
                (function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push('0');
                  return e;
                })(3 - u.length),
              ))
            : (u = []);
          const h = u.join('.');
          const f = (function (t) {
            for (let e = 0, n = l.length; e < n; e++) {
              const r = l[e];
              const i = r[0];
              if (r[1].exec(t)) return i;
            }
            return null;
          })(t);
          const p = c.exec(t);
          return p && p[1] ? new a(n, h, f, p[1]) : new i(n, h, f);
        }
      }.call(this, n(121)));
    },
    function (t, e, n) {
      'use strict';
      (function (t) {
        n.d(e, 'a', () => {
          return f;
        });
        const r = function () {
          for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
          const r = Array(t);
          let i = 0;
          for (e = 0; e < n; e++)
            for (let o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];
          return r;
        };
        const i = function (t, e, n) {
          (this.name = t), (this.version = e), (this.os = n), (this.type = 'browser');
        };
        const o = function (e) {
          (this.version = e), (this.type = 'node'), (this.name = 'node'), (this.os = t.platform);
        };
        const a = function (t, e, n, r) {
          (this.name = t),
            (this.version = e),
            (this.os = n),
            (this.bot = r),
            (this.type = 'bot-device');
        };
        const s = function () {
          (this.type = 'bot'),
            (this.bot = !0),
            (this.name = 'bot'),
            (this.version = null),
            (this.os = null);
        };
        const u = function () {
          (this.type = 'react-native'),
            (this.name = 'react-native'),
            (this.version = null),
            (this.os = null);
        };
        const c = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
        const h = [
          ['aol', /AOLShield\/([0-9\._]+)/],
          ['edge', /Edge\/([0-9\._]+)/],
          ['edge-ios', /EdgiOS\/([0-9\._]+)/],
          ['yandexbrowser', /YaBrowser\/([0-9\._]+)/],
          ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/],
          ['samsung', /SamsungBrowser\/([0-9\.]+)/],
          ['silk', /\bSilk\/([0-9._-]+)\b/],
          ['miui', /MiuiBrowser\/([0-9\.]+)$/],
          ['beaker', /BeakerBrowser\/([0-9\.]+)/],
          ['edge-chromium', /EdgA?\/([0-9\.]+)/],
          ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
          ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/],
          ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/],
          ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/],
          ['fxios', /FxiOS\/([0-9\.]+)/],
          ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/],
          ['opera', /Opera\/([0-9\.]+)(?:\s|$)/],
          ['opera', /OPR\/([0-9\.]+)(:?\s|$)/],
          ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
          ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
          ['ie', /MSIE\s(7\.0)/],
          ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/],
          ['android', /Android\s([0-9\.]+)/],
          ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/],
          ['safari', /Version\/([0-9\._]+).*Safari/],
          ['facebook', /FBAV\/([0-9\.]+)/],
          ['instagram', /Instagram\s([0-9\.]+)/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/],
          ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
          [
            'searchbot',
            /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,
          ],
        ];
        const l = [
          ['iOS', /iP(hone|od|ad)/],
          ['Android OS', /Android/],
          ['BlackBerry OS', /BlackBerry|BB10/],
          ['Windows Mobile', /IEMobile/],
          ['Amazon OS', /Kindle/],
          ['Windows 3.11', /Win16/],
          ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],
          ['Windows 98', /(Windows 98)|(Win98)/],
          ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],
          ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],
          ['Windows Server 2003', /(Windows NT 5.2)/],
          ['Windows Vista', /(Windows NT 6.0)/],
          ['Windows 7', /(Windows NT 6.1)/],
          ['Windows 8', /(Windows NT 6.2)/],
          ['Windows 8.1', /(Windows NT 6.3)/],
          ['Windows 10', /(Windows NT 10.0)/],
          ['Windows ME', /Windows ME/],
          ['Open BSD', /OpenBSD/],
          ['Sun OS', /SunOS/],
          ['Chrome OS', /CrOS/],
          ['Linux', /(Linux)|(X11)/],
          ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],
          ['QNX', /QNX/],
          ['BeOS', /BeOS/],
          ['OS/2', /OS\/2/],
        ];
        function f(e) {
          return e
            ? p(e)
            : typeof document === 'undefined' &&
              typeof navigator !== 'undefined' &&
              navigator.product === 'ReactNative'
            ? new u()
            : typeof navigator !== 'undefined'
            ? p(navigator.userAgent)
            : void 0 !== t && t.version
            ? new o(t.version.slice(1))
            : null;
        }
        function d(t) {
          return (
            t !== '' &&
            h.reduce((e, n) => {
              const r = n[0];
              const i = n[1];
              if (e) return e;
              const o = i.exec(t);
              return !!o && [r, o];
            }, !1)
          );
        }
        function p(t) {
          const e = d(t);
          if (!e) return null;
          const n = e[0];
          const o = e[1];
          if (n === 'searchbot') return new s();
          let u = o[1] && o[1].split(/[._]/).slice(0, 3);
          u
            ? u.length < 3 &&
              (u = r(
                u,
                (function (t) {
                  for (var e = [], n = 0; n < t; n++) e.push('0');
                  return e;
                })(3 - u.length),
              ))
            : (u = []);
          const h = u.join('.');
          const f = (function (t) {
            for (let e = 0, n = l.length; e < n; e++) {
              const r = l[e];
              const i = r[0];
              if (r[1].exec(t)) return i;
            }
            return null;
          })(t);
          const p = c.exec(t);
          return p && p[1] ? new a(n, h, f, p[1]) : new i(n, h, f);
        }
      }.call(this, n(121)));
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      n.r(e),
        n.d(e, 'registerGraph', () => {
          return v;
        });
      const r = n(1);
      const i = n(2);
      n.d(e, 'Arrow', () => {
        return i.d;
      }),
        n.d(e, 'Marker', () => {
          return i.k;
        }),
        n.d(e, 'Shape', () => {
          return i.m;
        });
      const o = n(50);
      n.d(e, 'ICanvas', () => {
        return o.ICanvas;
      }),
        n.d(e, 'IGroup', () => {
          return o.IGroup;
        }),
        n.d(e, 'IShape', () => {
          return o.IShape;
        });
      const a = n(30);
      n.d(e, 'Algorithm', () => {
        return a;
      });
      const s = n(92);
      n.d(e, 'Graph', () => {
        return s.a;
      });
      const u = n(28);
      n.d(e, 'Layout', () => {
        return u.a;
      }),
        n.d(e, 'registerLayout', () => {
          return u.c;
        });
      const c = n(19);
      n.d(e, 'Global', () => {
        return c.a;
      });
      const h = n(37);
      n.d(e, 'Util', () => {
        return h.a;
      });
      n(462), n(463);
      n.d(e, 'G6GraphEvent', () => {
        return i.i;
      }),
        n.d(e, 'G6Event', () => {
          return i.h;
        }),
        n.d(e, 'Node', () => {
          return i.l;
        }),
        n.d(e, 'Edge', () => {
          return i.g;
        }),
        n.d(e, 'Combo', () => {
          return i.f;
        }),
        n.d(e, 'Hull', () => {
          return i.j;
        }),
        n.d(e, 'registerNode', () => {
          return i.r;
        }),
        n.d(e, 'registerCombo', () => {
          return i.p;
        }),
        n.d(e, 'AbstractGraph', () => {
          return i.b;
        }),
        n.d(e, 'registerEdge', () => {
          return i.q;
        }),
        n.d(e, 'registerBehavior', () => {
          return i.o;
        }),
        n.d(e, 'AbstractLayout', () => {
          return i.c;
        }),
        n.d(e, 'AbstractEvent', () => {
          return i.a;
        }),
        n.d(e, 'BaseGlobal', () => {
          return i.e;
        });
      const l = n(149);
      for (var f in l)
        [
          'default',
          'Graph',
          'Util',
          'Layout',
          'registerLayout',
          'registerGraph',
          'Global',
          'Algorithm',
          'Arrow',
          'Marker',
          'Shape',
          'ICanvas',
          'IGroup',
          'IShape',
          'G6GraphEvent',
          'G6Event',
          'Node',
          'Edge',
          'Combo',
          'Hull',
          'registerNode',
          'registerCombo',
          'AbstractGraph',
          'registerEdge',
          'registerBehavior',
          'AbstractLayout',
          'AbstractEvent',
          'BaseGlobal',
        ].indexOf(f) < 0 &&
          (function (t) {
            n.d(e, t, () => {
              return l[t];
            });
          })(f);
      const d = n(150);
      for (var f in d)
        [
          'default',
          'Graph',
          'Util',
          'Layout',
          'registerLayout',
          'registerGraph',
          'Global',
          'Algorithm',
          'Arrow',
          'Marker',
          'Shape',
          'ICanvas',
          'IGroup',
          'IShape',
          'G6GraphEvent',
          'G6Event',
          'Node',
          'Edge',
          'Combo',
          'Hull',
          'registerNode',
          'registerCombo',
          'AbstractGraph',
          'registerEdge',
          'registerBehavior',
          'AbstractLayout',
          'AbstractEvent',
          'BaseGlobal',
        ].indexOf(f) < 0 &&
          (function (t) {
            n.d(e, t, () => {
              return d[t];
            });
          })(f);
      const p = {
        version: c.a.version,
        Graph: s.a,
        Util: h.a,
        Layout: u.a,
        Layouts: u.b,
        registerLayout: u.c,
        unRegisterLayout: u.d,
        Global: c.a,
        registerBehavior: i.o,
        registerCombo: i.p,
        registerEdge: i.q,
        registerNode: i.r,
        Algorithm: a,
        Arrow: i.d,
        Marker: i.k,
        Shape: i.m,
      };
      let g;
      var v =
        ((g = s.b),
        function () {
          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
          return g.apply(null, Object(r.g)(t, [p]));
        });
      (p.registerGraph = v), (e.default = p);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function () {
          const t = {};
          return (
            ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(
              (e) => (t[e] = !0),
            ),
            t
          );
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function () {
          return r++;
        });
      let r = 1;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          const { manager: n } = e;
          if (n) return n.get(t);
          return t;
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          if (t & r.STATE_CANCELLED) return 'cancel';
          if (t & r.STATE_ENDED) return 'end';
          if (t & r.STATE_CHANGED) return 'move';
          if (t & r.STATE_BEGAN) return 'start';
          return '';
        });
      var r = n(26);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          if ((0, i.default)(t, o.TOUCH_ACTION_NONE)) return o.TOUCH_ACTION_NONE;
          const e = (0, i.default)(t, o.TOUCH_ACTION_PAN_X);
          const n = (0, i.default)(t, o.TOUCH_ACTION_PAN_Y);
          if (e && n) return o.TOUCH_ACTION_NONE;
          if (e || n) return e ? o.TOUCH_ACTION_PAN_X : o.TOUCH_ACTION_PAN_Y;
          if ((0, i.default)(t, o.TOUCH_ACTION_MANIPULATION)) return o.TOUCH_ACTION_MANIPULATION;
          return o.TOUCH_ACTION_AUTO;
        });
      let r;
      var i = (r = n(137)) && r.__esModule ? r : { default: r };
      var o = n(35);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          let e = i.default;
          t.options.inputClass && (e = inputClass);
          return new e(t, r.default);
        });
      var r = o(n(242));
      var i = o(n(142));
      function o(t) {
        return t && t.__esModule ? t : { default: t };
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          const r = n.pointers.length;
          const a = n.changedPointers.length;
          const s = e & i.INPUT_START && r - a == 0;
          const u = e & (i.INPUT_END | i.INPUT_CANCEL) && r - a == 0;
          (n.isFirst = !!s), (n.isFinal = !!u), s && (t.session = {});
          (n.eventType = e),
            (0, o.default)(t, n),
            t.emit('hammer.input', n),
            t.recognize(n),
            (t.session.prevInput = n);
        });
      let r;
      var i = n(18);
      var o = (r = n(243)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          const { session: n } = t;
          const { pointers: p } = e;
          const { length: g } = p;
          n.firstInput || (n.firstInput = (0, i.default)(e));
          g > 1 && !n.firstMultiple
            ? (n.firstMultiple = (0, i.default)(e))
            : g === 1 && (n.firstMultiple = !1);
          const { firstInput: v, firstMultiple: y } = n;
          const m = y ? y.center : v.center;
          const b = (e.center = (0, o.default)(p));
          (e.timeStamp = (0, r.now)()),
            (e.deltaTime = e.timeStamp - v.timeStamp),
            (e.angle = (0, s.default)(m, b)),
            (e.distance = (0, a.default)(m, b)),
            (0, c.default)(n, e),
            (e.offsetDirection = (0, u.default)(e.deltaX, e.deltaY));
          const x = (0, h.default)(e.deltaTime, e.deltaX, e.deltaY);
          (e.overallVelocityX = x.x),
            (e.overallVelocityY = x.y),
            (e.overallVelocity = (0, r.abs)(x.x) > (0, r.abs)(x.y) ? x.x : x.y),
            (e.scale = y ? (0, l.default)(y.pointers, p) : 1),
            (e.rotation = y ? (0, f.default)(y.pointers, p) : 0),
            (e.maxPointers = n.prevInput
              ? e.pointers.length > n.prevInput.maxPointers
                ? e.pointers.length
                : n.prevInput.maxPointers
              : e.pointers.length),
            (0, d.default)(n, e);
        });
      var r = n(31);
      var i = (p(n(96)), p(n(244)));
      var o = p(n(138));
      var a = p(n(95));
      var s = p(n(139));
      var u = p(n(140));
      var c = p(n(245));
      var h = p(n(141));
      var l = p(n(246));
      var f = p(n(247));
      var d = p(n(248));
      function p(t) {
        return t && t.__esModule ? t : { default: t };
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t) {
          const e = [];
          let n = 0;
          for (; n < t.pointers.length; )
            (e[n] = {
              clientX: (0, i.round)(t.pointers[n].clientX),
              clientY: (0, i.round)(t.pointers[n].clientY),
            }),
              n++;
          return {
            timeStamp: (0, i.now)(),
            pointers: e,
            center: (0, o.default)(e),
            deltaX: t.deltaX,
            deltaY: t.deltaY,
          };
        });
      let r;
      var i = n(31);
      var o = (r = n(138)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          const { center: n } = e;
          let i = t.offsetDelta || {};
          let o = t.prevDelta || {};
          const a = t.prevInput || {};
          (e.eventType !== r.INPUT_START && a.eventType !== r.INPUT_END) ||
            ((o = t.prevDelta = { x: a.deltaX || 0, y: a.deltaY || 0 }),
            (i = t.offsetDelta = { x: n.x, y: n.y }));
          (e.deltaX = o.x + (n.x - i.x)), (e.deltaY = o.y + (n.y - i.y));
        });
      var r = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          return (
            (0, o.default)(e[0], e[1], i.PROPS_CLIENT_XY) /
            (0, o.default)(t[0], t[1], i.PROPS_CLIENT_XY)
          );
        });
      let r;
      var i = n(18);
      var o = (r = n(95)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          return (
            (0, i.default)(e[1], e[0], o.PROPS_CLIENT_XY) +
            (0, i.default)(t[1], t[0], o.PROPS_CLIENT_XY)
          );
        });
      let r;
      var i = (r = n(139)) && r.__esModule ? r : { default: r };
      var o = n(18);
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e) {
          let n;
          let s;
          let u;
          let c;
          const h = t.lastInterval || e;
          const l = e.timeStamp - h.timeStamp;
          if (e.eventType !== r.INPUT_CANCEL && (l > r.COMPUTE_INTERVAL || void 0 === h.velocity)) {
            const r = e.deltaX - h.deltaX;
            const f = e.deltaY - h.deltaY;
            const d = (0, o.default)(l, r, f);
            (s = d.x),
              (u = d.y),
              (n = (0, i.abs)(d.x) > (0, i.abs)(d.y) ? d.x : d.y),
              (c = (0, a.default)(r, f)),
              (t.lastInterval = e);
          } else (n = h.velocity), (s = h.velocityX), (u = h.velocityY), (c = h.direction);
          (e.velocity = n), (e.velocityX = s), (e.velocityY = u), (e.direction = c);
        });
      var r = n(18);
      var i = n(31);
      var o = s(n(141));
      var a = s(n(140));
      function s(t) {
        return t && t.__esModule ? t : { default: t };
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = n(18);
      const i = a(n(97));
      const o = a(n(56));
      function a(t) {
        return t && t.__esModule ? t : { default: t };
      }
      const s = {
        pointerdown: r.INPUT_START,
        pointermove: r.INPUT_MOVE,
        pointerup: r.INPUT_END,
        pointercancel: r.INPUT_CANCEL,
        pointerout: r.INPUT_CANCEL,
      };
      const u = {
        2: r.INPUT_TYPE_TOUCH,
        3: r.INPUT_TYPE_PEN,
        4: r.INPUT_TYPE_MOUSE,
        5: r.INPUT_TYPE_KINECT,
      };
      class c extends i.default {
        constructor() {
          (c.prototype.events = 'pointerdown pointermove pointerup pointercancel'),
            super(...arguments),
            (this.evEl = 'pointerdown'),
            (this.evWin = 'pointermove pointerup pointercancel'),
            (this.store = this.manager.session.pointerEvents = []);
        }

        handler(t) {
          const { store: e } = this;
          let n = !1;
          const i = t.type.toLowerCase().replace('ms', '');
          const a = s[i];
          const c = u[t.pointerType] || t.pointerType;
          const h = c === r.INPUT_TYPE_TOUCH;
          let l = (0, o.default)(e, t.pointerId, 'pointerId');
          a & r.INPUT_START && (t.button === 0 || h)
            ? l < 0 && (e.push(t), (l = e.length - 1))
            : a & (r.INPUT_END | r.INPUT_CANCEL) && (n = !0),
            l < 0 ||
              ((e[l] = t),
              this.callback(this.manager, a, {
                pointers: e,
                changedPointers: [t],
                pointerType: c,
                srcEvent: t,
              }),
              n && e.splice(l, 1));
        }
      }
      e.default = c;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          (0, r.default)((0, i.default)(e), (e) => {
            t.removeEventListener(e, n, !1);
          });
        }),
        (e.removeManagerListeners = function (t, e, n) {
          (0, r.default)((0, i.default)(e), (e) => {
            t.off(`origin_input:${e}`, n);
          });
        });
      var r = o(n(44));
      var i = o(n(67));
      function o(t) {
        return t && t.__esModule ? t : { default: t };
      }
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.default = void 0);
      const r = o(n(146));
      const i = o(n(147));
      function o(t) {
        return t && t.__esModule ? t : { default: t };
      }
      const a = (0, r.default)((t, e) => (0, i.default)(t, e, !0), 'merge', 'Use `assign`.');
      e.default = a;
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.default = function (t, e, n) {
          let r;
          const o = e.prototype;
          (r = t.prototype = Object.create(o)),
            (r.constructor = t),
            (r._super = o),
            n && (0, i.default)(r, n);
        });
      let r;
      var i = (r = n(65)) && r.__esModule ? r : { default: r };
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isAllowCapture =
          e.isParent =
          e.upperFirst =
          e.each =
          e.mix =
          e.isArray =
          e.isObject =
          e.isString =
          e.isFunction =
          e.isNil =
          e.isBrowser =
          e.removeFromArray =
            void 0),
        (e.removeFromArray = function (t, e) {
          const n = t.indexOf(e);
          n !== -1 && t.splice(n, 1);
        }),
        (e.isBrowser = typeof window !== 'undefined' && void 0 !== window.document);
      const r = n(3);
      Object.defineProperty(e, 'isNil', {
        enumerable: !0,
        get() {
          return r.isNil;
        },
      }),
        Object.defineProperty(e, 'isFunction', {
          enumerable: !0,
          get() {
            return r.isFunction;
          },
        }),
        Object.defineProperty(e, 'isString', {
          enumerable: !0,
          get() {
            return r.isString;
          },
        }),
        Object.defineProperty(e, 'isObject', {
          enumerable: !0,
          get() {
            return r.isObject;
          },
        }),
        Object.defineProperty(e, 'isArray', {
          enumerable: !0,
          get() {
            return r.isArray;
          },
        }),
        Object.defineProperty(e, 'mix', {
          enumerable: !0,
          get() {
            return r.mix;
          },
        }),
        Object.defineProperty(e, 'each', {
          enumerable: !0,
          get() {
            return r.each;
          },
        }),
        Object.defineProperty(e, 'upperFirst', {
          enumerable: !0,
          get() {
            return r.upperFirst;
          },
        }),
        (e.isParent = function (t, e) {
          if (t.isCanvas()) return !0;
          for (var n = e.getParent(), r = !1; n; ) {
            if (n === t) {
              r = !0;
              break;
            }
            n = n.getParent();
          }
          return r;
        }),
        (e.isAllowCapture = function (t) {
          return t.cfg.visible && t.cfg.capture;
        });
    },
    function (t, e, n) {
      'use strict';
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.getOffScreenContext = void 0);
      let r = null;
      e.getOffScreenContext = function () {
        if (!r) {
          const t = document.createElement('canvas');
          (t.width = 1), (t.height = 1), (r = t.getContext('2d'));
        }
        return r;
      };
    },
    function (t, e, n) {
      const r = n(256);
      const i = n(257);
      const o = {};
      for (const a in r) r.hasOwnProperty(a) && (o[r[a]] = a);
      const s = (t.exports = { to: {}, get: {} });
      function u(t, e, n) {
        return Math.min(Math.max(e, t), n);
      }
      function c(t) {
        const e = t.toString(16).toUpperCase();
        return e.length < 2 ? `0${e}` : e;
      }
      (s.get = function (t) {
        let e;
        let n;
        switch (t.substring(0, 3).toLowerCase()) {
          case 'hsl':
            (e = s.get.hsl(t)), (n = 'hsl');
            break;
          case 'hwb':
            (e = s.get.hwb(t)), (n = 'hwb');
            break;
          default:
            (e = s.get.rgb(t)), (n = 'rgb');
        }
        return e ? { model: n, value: e } : null;
      }),
        (s.get.rgb = function (t) {
          if (!t) return null;
          let e;
          let n;
          let i;
          let o = [0, 0, 0, 1];
          if ((e = t.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i))) {
            for (i = e[2], e = e[1], n = 0; n < 3; n++) {
              const a = 2 * n;
              o[n] = parseInt(e.slice(a, a + 2), 16);
            }
            i && (o[3] = parseInt(i, 16) / 255);
          } else if ((e = t.match(/^#([a-f0-9]{3,4})$/i))) {
            for (i = (e = e[1])[3], n = 0; n < 3; n++) o[n] = parseInt(e[n] + e[n], 16);
            i && (o[3] = parseInt(i + i, 16) / 255);
          } else if (
            (e = t.match(
              /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
            ))
          ) {
            for (n = 0; n < 3; n++) o[n] = parseInt(e[n + 1], 0);
            e[4] && (o[3] = parseFloat(e[4]));
          } else {
            if (
              !(e = t.match(
                /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
              ))
            )
              return (e = t.match(/(\D+)/))
                ? e[1] === 'transparent'
                  ? [0, 0, 0, 0]
                  : (o = r[e[1]])
                  ? ((o[3] = 1), o)
                  : null
                : null;
            for (n = 0; n < 3; n++) o[n] = Math.round(2.55 * parseFloat(e[n + 1]));
            e[4] && (o[3] = parseFloat(e[4]));
          }
          for (n = 0; n < 3; n++) o[n] = u(o[n], 0, 255);
          return (o[3] = u(o[3], 0, 1)), o;
        }),
        (s.get.hsl = function (t) {
          if (!t) return null;
          const e = t.match(
            /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?[\d\.]+)\s*)?\)$/,
          );
          if (e) {
            const n = parseFloat(e[4]);
            return [
              (parseFloat(e[1]) + 360) % 360,
              u(parseFloat(e[2]), 0, 100),
              u(parseFloat(e[3]), 0, 100),
              u(isNaN(n) ? 1 : n, 0, 1),
            ];
          }
          return null;
        }),
        (s.get.hwb = function (t) {
          if (!t) return null;
          const e = t.match(
            /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
          );
          if (e) {
            const n = parseFloat(e[4]);
            return [
              ((parseFloat(e[1]) % 360) + 360) % 360,
              u(parseFloat(e[2]), 0, 100),
              u(parseFloat(e[3]), 0, 100),
              u(isNaN(n) ? 1 : n, 0, 1),
            ];
          }
          return null;
        }),
        (s.to.hex = function () {
          const t = i(arguments);
          return `#${c(t[0])}${c(t[1])}${c(t[2])}${t[3] < 1 ? c(Math.round(255 * t[3])) : ''}`;
        }),
        (s.to.rgb = function () {
          const t = i(arguments);
          return t.length < 4 || t[3] === 1
            ? `rgb(${Math.round(t[0])}, ${Math.round(t[1])}, ${Math.round(t[2])})`
            : `rgba(${Math.round(t[0])}, ${Math.round(t[1])}, ${Math.round(t[2])}, ${t[3]})`;
        }),
        (s.to.rgb.percent = function () {
          const t = i(arguments);
          const e = Math.round((t[0] / 255) * 100);
          const n = Math.round((t[1] / 255) * 100);
          const r = Math.round((t[2] / 255) * 100);
          return t.length < 4 || t[3] === 1
            ? `rgb(${e}%, ${n}%, ${r}%)`
            : `rgba(${e}%, ${n}%, ${r}%, ${t[3]})`;
        }),
        (s.to.hsl = function () {
          const t = i(arguments);
          return t.length < 4 || t[3] === 1
            ? `hsl(${t[0]}, ${t[1]}%, ${t[2]}%)`
            : `hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${t[3]})`;
        }),
        (s.to.hwb = function () {
          const t = i(arguments);
          let e = '';
          return (
            t.length >= 4 && t[3] !== 1 && (e = `, ${t[3]}`), `hwb(${t[0]}, ${t[1]}%, ${t[2]}%${e})`
          );
        }),
        (s.to.keyword = function (t) {
          return o[t.slice(0, 3)];
        });
    },
    function (t, e, n) {
      'use strict';
      t.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
    },
    function (t, e, n) {
      'use strict';
      const r = n(258);
      const i = Array.prototype.concat;
      const o = Array.prototype.slice;
      const a = (t.exports = function (t) {
        for (var e = [], n = 0, a = t.length; n < a; n++) {
          const s = t[n];
          r(s) ? (e = i.call(e, o.call(s))) : e.push(s);
        }
        return e;
      });
      a.wrap = function (t) {
        return function () {
          return t(a(arguments));
        };
      };
    },
    function (t, e) {
      t.exports = function (t) {
        return (
          !(!t || typeof t === 'string') &&
          (t instanceof Array ||
            Array.isArray(t) ||
            (t.length >= 0 &&
              (t.splice instanceof Function ||
                (Object.getOwnPropertyDescriptor(t, t.length - 1) &&
                  t.constructor.name !== 'String'))))
        );
      };
    },
    function (t, e, n) {
      function r(t) {
        return (r =
          typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
            ? function (t) {
                return typeof t;
              }
            : function (t) {
                return t &&
                  typeof Symbol === 'function' &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? 'symbol'
                  : typeof t;
              })(t);
      }
      const i = n(148);
      const o = n(261);
      const a = {};
      Object.keys(i).forEach((t) => {
        (a[t] = {}),
          Object.defineProperty(a[t], 'channels', { value: i[t].channels }),
          Object.defineProperty(a[t], 'labels', { value: i[t].labels });
        const e = o(t);
        Object.keys(e).forEach((n) => {
          const i = e[n];
          (a[t][n] = (function (t) {
            const e = function (e) {
              if (e == null) return e;
              arguments.length > 1 && (e = Array.prototype.slice.call(arguments));
              const n = t(e);
              if (r(n) === 'object')
                for (let i = n.length, o = 0; o < i; o++) n[o] = Math.round(n[o]);
              return n;
            };
            return 'conversion' in t && (e.conversion = t.conversion), e;
          })(i)),
            (a[t][n].raw = (function (t) {
              const e = function (e) {
                return e == null
                  ? e
                  : (arguments.length > 1 && (e = Array.prototype.slice.call(arguments)), t(e));
              };
              return 'conversion' in t && (e.conversion = t.conversion), e;
            })(i));
        });
      }),
        (t.exports = a);
    },
    function (t, e, n) {
      'use strict';
      t.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      };
    },
    function (t, e, n) {
      const r = n(148);
      function i(t) {
        const e = (function () {
          for (var t = {}, e = Object.keys(r), n = e.length, i = 0; i < n; i++)
            t[e[i]] = { distance: -1, parent: null };
          return t;
        })();
        const n = [t];
        for (e[t].distance = 0; n.length; )
          for (let i = n.pop(), o = Object.keys(r[i]), a = o.length, s = 0; s < a; s++) {
            const u = o[s];
            const c = e[u];
            c.distance === -1 && ((c.distance = e[i].distance + 1), (c.parent = i), n.unshift(u));
          }
        return e;
      }
      function o(t, e) {
        return function (n) {
          return e(t(n));
        };
      }
      function a(t, e) {
        for (var n = [e[t].parent, t], i = r[e[t].parent][t], a = e[t].parent; e[a].parent; )
          n.unshift(e[a].parent), (i = o(r[e[a].parent][a], i)), (a = e[a].parent);
        return (i.conversion = n), i;
      }
      t.exports = function (t) {
        for (var e = i(t), n = {}, r = Object.keys(e), o = r.length, s = 0; s < o; s++) {
          const u = r[s];
          e[u].parent !== null && (n[u] = a(u, e));
        }
        return n;
      };
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function (t, e, n) {
      'use strict';
      var r = function () {
        return (r =
          Object.assign ||
          function (t) {
            for (var e, n = 1, r = arguments.length; n < r; n++)
              for (const i in (e = arguments[n]))
                Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
            return t;
          }).apply(this, arguments);
      };
      function i(t, e) {
        const n = {};
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
        if (t != null && typeof Object.getOwnPropertySymbols === 'function') {
          let i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            e.indexOf(r[i]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
              (n[r[i]] = t[r[i]]);
        }
        return n;
      }
      const o = n(2);
      const a = n(0);
      Object(o.r)(
        'circle',
        {
          options: {
            size: o.e.defaultNode.size,
            style: {
              x: 0,
              y: 0,
              stroke: o.e.defaultNode.style.stroke,
              fill: o.e.defaultNode.style.fill,
              lineWidth: o.e.defaultNode.style.lineWidth,
            },
            labelCfg: {
              style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
            },
            linkPoints: {
              top: !1,
              right: !1,
              bottom: !1,
              left: !1,
              size: o.e.defaultNode.linkPoints.size,
              lineWidth: o.e.defaultNode.linkPoints.lineWidth,
              fill: o.e.defaultNode.linkPoints.fill,
              stroke: o.e.defaultNode.linkPoints.stroke,
            },
            icon: {
              show: !1,
              img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
              width: 20,
              height: 20,
            },
            stateStyles: r({}, o.e.nodeStateStyles),
          },
          shapeType: 'circle',
          labelPosition: 'center',
          drawShape(t, e) {
            const n = this.getOptions(t).icon;
            const i = void 0 === n ? {} : n;
            const o = this.getShapeStyle(t);
            const s = Object(a.b)({}, i, t.icon);
            const u = e.addShape('circle', {
              attrs: o,
              className: `${this.type}-keyShape`,
              draggable: !0,
            });
            const c = s.width;
            const h = s.height;
            const l = s.show;
            const f = s.text;
            return (
              l &&
                (f
                  ? e.addShape('text', {
                      attrs: r(
                        {
                          x: 0,
                          y: 0,
                          fontSize: 12,
                          fill: '#000',
                          stroke: '#000',
                          textBaseline: 'middle',
                          textAlign: 'center',
                        },
                        s,
                      ),
                      className: `${this.type}-icon`,
                      name: `${this.type}-icon`,
                      draggable: !0,
                    })
                  : e.addShape('image', {
                      attrs: r({ x: -c / 2, y: -h / 2 }, s),
                      className: `${this.type}-icon`,
                      name: `${this.type}-icon`,
                      draggable: !0,
                    })),
              this.drawLinkPoints(t, e),
              u
            );
          },
          drawLinkPoints(t, e) {
            const n = this.getOptions(t).linkPoints;
            const o = void 0 === n ? {} : n;
            const a = o.top;
            const s = o.left;
            const u = o.right;
            const c = o.bottom;
            const h = o.size;
            const l = o.r;
            const f = i(o, ['top', 'left', 'right', 'bottom', 'size', 'r']);
            const d = this.getSize(t)[0] / 2;
            s &&
              e.addShape('circle', {
                attrs: r(r({}, f), { x: -d, y: 0, r: h / 2 || l || 5 }),
                className: 'link-point-left',
                name: 'link-point-left',
                isAnchorPoint: !0,
              }),
              u &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: d, y: 0, r: h / 2 || l || 5 }),
                  className: 'link-point-right',
                  name: 'link-point-right',
                  isAnchorPoint: !0,
                }),
              a &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: 0, y: -d, r: h / 2 || l || 5 }),
                  className: 'link-point-top',
                  name: 'link-point-top',
                  isAnchorPoint: !0,
                }),
              c &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: 0, y: d, r: h / 2 || l || 5 }),
                  className: 'link-point-bottom',
                  name: 'link-point-bottom',
                  isAnchorPoint: !0,
                });
          },
          getShapeStyle(t) {
            const e = this.getOptions(t).style;
            const n = { stroke: t.color };
            const i = Object(a.b)({}, e, n);
            const o = this.getSize(t)[0] / 2;
            return r({ x: 0, y: 0, r: o }, i);
          },
          update(t, e) {
            const n = e.getContainer();
            const r = this.getSize(t);
            const i = { stroke: t.color, r: r[0] / 2 };
            const o = e.get('keyShape');
            const s = Object(a.b)({}, o.attr(), i, t.style);
            this.updateShape(t, e, s, !0), this.updateLinkPoints(t, n);
          },
        },
        'single-node',
      ),
        Object(o.r)(
          'rect',
          {
            options: {
              size: [100, 30],
              style: {
                radius: 0,
                stroke: o.e.defaultNode.style.stroke,
                fill: o.e.defaultNode.style.fill,
                lineWidth: o.e.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
              },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: o.e.defaultNode.linkPoints.size,
                lineWidth: o.e.defaultNode.linkPoints.lineWidth,
                fill: o.e.defaultNode.linkPoints.fill,
                stroke: o.e.defaultNode.linkPoints.stroke,
              },
              icon: {
                show: !1,
                img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
                width: 20,
                height: 20,
              },
              anchorPoints: [
                [0, 0.5],
                [1, 0.5],
              ],
              stateStyles: r({}, o.e.nodeStateStyles),
            },
            shapeType: 'rect',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getShapeStyle(t);
              const r = e.addShape('rect', {
                attrs: n,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              return this.drawLinkPoints(t, e), r;
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t).linkPoints;
              const o = void 0 === n ? {} : n;
              const a = o.top;
              const s = o.left;
              const u = o.right;
              const c = o.bottom;
              const h = o.size;
              const l = o.r;
              const f = i(o, ['top', 'left', 'right', 'bottom', 'size', 'r']);
              const d = this.getSize(t);
              const p = d[0];
              const g = d[1];
              s &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: -p / 2, y: 0, r: h / 2 || l || 5 }),
                  className: 'link-point-left',
                  name: 'link-point-left',
                  isAnchorPoint: !0,
                }),
                u &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: p / 2, y: 0, r: h / 2 || l || 5 }),
                    className: 'link-point-right',
                    name: 'link-point-right',
                    isAnchorPoint: !0,
                  }),
                a &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: -g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-top',
                    name: 'link-point-top',
                    isAnchorPoint: !0,
                  }),
                c &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-bottom',
                    name: 'link-point-bottom',
                    isAnchorPoint: !0,
                  });
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getSize(t);
              const s = i.width || o[0];
              const u = i.height || o[1];
              return r({ x: -s / 2, y: -u / 2, width: s, height: u }, i);
            },
            update(t, e) {
              const n = e.getContainer();
              const r = this.getOptions({}).style;
              const i = this.getSize(t);
              const o = e.get('keyShape');
              t.size ||
                ((i[0] = o.attr('width') || r.width), (i[1] = o.attr('height') || r.height));
              const s = { stroke: t.color, x: -i[0] / 2, y: -i[1] / 2, width: i[0], height: i[1] };
              let u = Object(a.r)({}, r, o.attr(), s);
              (u = Object(a.r)(u, t.style)),
                this.updateShape(t, e, u, !1),
                this.updateLinkPoints(t, n);
            },
          },
          'single-node',
        ),
        Object(o.r)(
          'ellipse',
          {
            options: {
              size: [80, 40],
              style: {
                x: 0,
                y: 0,
                stroke: o.e.defaultNode.style.stroke,
                fill: o.e.defaultNode.style.fill,
                lineWidth: o.e.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
              },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: o.e.defaultNode.linkPoints.size,
                lineWidth: o.e.defaultNode.linkPoints.lineWidth,
                fill: o.e.defaultNode.linkPoints.fill,
                stroke: o.e.defaultNode.linkPoints.stroke,
              },
              icon: {
                show: !1,
                img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
                width: 20,
                height: 20,
              },
              stateStyles: r({}, o.e.nodeStateStyles),
            },
            shapeType: 'ellipse',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getOptions(t).icon;
              const i = void 0 === n ? {} : n;
              const o = this.getShapeStyle(t);
              const a = e.addShape('ellipse', {
                attrs: o,
                className: 'ellipse-keyShape',
                name: 'ellipse-keyShape',
                draggable: !0,
              });
              const s = i.width;
              const u = i.height;
              const c = i.show;
              const h = i.text;
              return (
                c &&
                  (h
                    ? e.addShape('text', {
                        attrs: r(
                          {
                            x: 0,
                            y: 0,
                            fontSize: 12,
                            fill: '#000',
                            stroke: '#000',
                            textBaseline: 'middle',
                            textAlign: 'center',
                          },
                          i,
                        ),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })
                    : e.addShape('image', {
                        attrs: r({ x: -s / 2, y: -u / 2 }, i),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })),
                this.drawLinkPoints(t, e),
                a
              );
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t).linkPoints;
              const o = void 0 === n ? {} : n;
              const a = o.top;
              const s = o.left;
              const u = o.right;
              const c = o.bottom;
              const h = o.size;
              const l = o.r;
              const f = i(o, ['top', 'left', 'right', 'bottom', 'size', 'r']);
              const d = this.getSize(t);
              const p = d[0] / 2;
              const g = d[1] / 2;
              s &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: -p, y: 0, r: h / 2 || l || 5 }),
                  className: 'link-point-left',
                  name: 'link-point-left',
                  isAnchorPoint: !0,
                }),
                u &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: p, y: 0, r: h / 2 || l || 5 }),
                    className: 'link-point-right',
                    name: 'link-point-right',
                    isAnchorPoint: !0,
                  }),
                a &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: -g, r: h / 2 || l || 5 }),
                    className: 'link-point-top',
                    name: 'link-point-top',
                    isAnchorPoint: !0,
                  }),
                c &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: g, r: h / 2 || l || 5 }),
                    className: 'link-point-bottom',
                    name: 'link-point-bottom',
                    isAnchorPoint: !0,
                  });
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getSize(t);
              const s = o[0] / 2;
              const u = o[1] / 2;
              return r({ x: 0, y: 0, rx: s, ry: u }, i);
            },
            update(t, e) {
              const n = e.getContainer();
              const r = this.getOptions({}).style;
              const i = this.getSize(t);
              const o = { stroke: t.color, rx: i[0] / 2, ry: i[1] / 2 };
              const s = e.get('keyShape');
              let u = Object(a.r)({}, r, s.attr(), o);
              (u = Object(a.r)(u, t.style)),
                this.updateShape(t, e, u, !0),
                this.updateLinkPoints(t, n);
            },
          },
          'single-node',
        ),
        Object(o.r)(
          'diamond',
          {
            options: {
              size: [80, 80],
              style: {
                stroke: o.e.defaultNode.style.stroke,
                fill: o.e.defaultNode.style.fill,
                lineWidth: o.e.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
              },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: o.e.defaultNode.linkPoints.size,
                lineWidth: o.e.defaultNode.linkPoints.lineWidth,
                fill: o.e.defaultNode.linkPoints.fill,
                stroke: o.e.defaultNode.linkPoints.stroke,
              },
              icon: {
                show: !1,
                img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
                width: 20,
                height: 20,
              },
              stateStyles: r({}, o.e.nodeStateStyles),
            },
            shapeType: 'diamond',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getOptions(t).icon;
              const i = void 0 === n ? {} : n;
              const o = this.getShapeStyle(t);
              const a = e.addShape('path', {
                attrs: o,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              const s = i.width;
              const u = i.height;
              const c = i.show;
              const h = i.text;
              return (
                c &&
                  (h
                    ? e.addShape('text', {
                        attrs: r(
                          {
                            x: 0,
                            y: 0,
                            fontSize: 12,
                            fill: '#000',
                            stroke: '#000',
                            textBaseline: 'middle',
                            textAlign: 'center',
                          },
                          i,
                        ),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })
                    : e.addShape('image', {
                        attrs: r({ x: -s / 2, y: -u / 2 }, i),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })),
                this.drawLinkPoints(t, e),
                a
              );
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t).linkPoints;
              const o = void 0 === n ? {} : n;
              const a = o.top;
              const s = o.left;
              const u = o.right;
              const c = o.bottom;
              const h = o.size;
              const l = o.r;
              const f = i(o, ['top', 'left', 'right', 'bottom', 'size', 'r']);
              const d = this.getSize(t);
              const p = d[0];
              const g = d[1];
              s &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: -p / 2, y: 0, r: h / 2 || l || 5 }),
                  className: 'link-point-left',
                  name: 'link-point-left',
                  isAnchorPoint: !0,
                }),
                u &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: p / 2, y: 0, r: h / 2 || l || 5 }),
                    className: 'link-point-right',
                    name: 'link-point-right',
                    isAnchorPoint: !0,
                  }),
                a &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: -g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-top',
                    name: 'link-point-top',
                    isAnchorPoint: !0,
                  }),
                c &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-bottom',
                    name: 'link-point-bottom',
                    isAnchorPoint: !0,
                  });
            },
            getPath(t) {
              const e = this.getSize(t);
              const n = e[0];
              const r = e[1];
              return [['M', 0, -r / 2], ['L', n / 2, 0], ['L', 0, r / 2], ['L', -n / 2, 0], ['Z']];
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getPath(t);
              return r({ path: o }, i);
            },
            update(t, e) {
              const n = e.getContainer();
              const r = this.getOptions({}).style;
              const i = this.getPath(t);
              const o = { stroke: t.color, path: i };
              const s = e.get('keyShape');
              let u = Object(a.r)({}, r, s.attr(), o);
              (u = Object(a.r)(u, t.style)),
                this.updateShape(t, e, u, !0),
                this.updateLinkPoints(t, n);
            },
          },
          'single-node',
        ),
        Object(o.r)(
          'triangle',
          {
            options: {
              size: 40,
              direction: 'up',
              style: {
                stroke: o.e.defaultNode.style.stroke,
                fill: o.e.defaultNode.style.fill,
                lineWidth: o.e.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
                offset: 15,
              },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: o.e.defaultNode.linkPoints.size,
                lineWidth: o.e.defaultNode.linkPoints.lineWidth,
                fill: o.e.defaultNode.linkPoints.fill,
                stroke: o.e.defaultNode.linkPoints.stroke,
              },
              icon: {
                show: !1,
                img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
                width: 20,
                height: 20,
                offset: 6,
              },
              stateStyles: r({}, o.e.nodeStateStyles),
            },
            shapeType: 'triangle',
            labelPosition: 'bottom',
            drawShape(t, e) {
              const n = this.getOptions(t);
              const i = n.icon;
              const o = void 0 === i ? {} : i;
              const a = n.direction;
              const s = this.getShapeStyle(t);
              const u = t.direction || a;
              const c = e.addShape('path', {
                attrs: s,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              const h = o.width;
              const l = o.height;
              const f = o.show;
              const d = o.offset;
              const p = o.text;
              if (f)
                if (p)
                  e.addShape('text', {
                    attrs: r(
                      {
                        x: 0,
                        y: 0,
                        fontSize: 12,
                        fill: '#000',
                        stroke: '#000',
                        textBaseline: 'middle',
                        textAlign: 'center',
                      },
                      o,
                    ),
                    className: `${this.type}-icon`,
                    name: `${this.type}-icon`,
                    draggable: !0,
                  });
                else {
                  let g = -h / 2;
                  let v = -l / 2;
                  (u !== 'up' && u !== 'down') || (v += d),
                    (u !== 'left' && u !== 'right') || (g += d),
                    e.addShape('image', {
                      attrs: r({ x: g, y: v }, o),
                      className: `${this.type}-icon`,
                      name: `${this.type}-icon`,
                      draggable: !0,
                    });
                }
              return this.drawLinkPoints(t, e), c;
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t);
              const o = n.linkPoints;
              const a = void 0 === o ? {} : o;
              const s = n.direction;
              const u = t.direction || s;
              const c = a.top;
              const h = a.left;
              const l = a.right;
              const f = a.bottom;
              const d = a.size;
              const p = a.r;
              const g = i(a, ['top', 'left', 'right', 'bottom', 'size', 'r']);
              const v = this.getSize(t)[0];
              if (h) {
                let y = null;
                var m = v * Math.sin((1 / 3) * Math.PI);
                var b = v * Math.sin((1 / 3) * Math.PI);
                u === 'up'
                  ? (y = [-b, m])
                  : u === 'down'
                  ? (y = [-b, -m])
                  : u === 'left' && (y = [-b, b - m]),
                  y &&
                    e.addShape('circle', {
                      attrs: r(r({}, g), { x: y[0], y: y[1], r: d / 2 || p || 5 }),
                      className: 'link-point-left',
                      name: 'link-point-left',
                    });
              }
              if (l) {
                let x = null;
                (m = v * Math.sin((1 / 3) * Math.PI)), (b = v * Math.sin((1 / 3) * Math.PI));
                u === 'up'
                  ? (x = [b, m])
                  : u === 'down'
                  ? (x = [b, -m])
                  : u === 'right' && (x = [b, b - m]),
                  x &&
                    e.addShape('circle', {
                      attrs: r(r({}, g), { x: x[0], y: x[1], r: d / 2 || p || 5 }),
                      className: 'link-point-right',
                      name: 'link-point-right',
                    });
              }
              if (c) {
                let M = null;
                (m = v * Math.sin((1 / 3) * Math.PI)), (b = v * Math.sin((1 / 3) * Math.PI));
                u === 'up'
                  ? (M = [b - m, -m])
                  : u === 'left'
                  ? (M = [b, -m])
                  : u === 'right' && (M = [-b, -m]),
                  M &&
                    e.addShape('circle', {
                      attrs: r(r({}, g), { x: M[0], y: M[1], r: d / 2 || p || 5 }),
                      className: 'link-point-top',
                      name: 'link-point-top',
                    });
              }
              if (f) {
                let S = null;
                (m = v * Math.sin((1 / 3) * Math.PI)), (b = v * Math.sin((1 / 3) * Math.PI));
                u === 'down'
                  ? (S = [-b + m, m])
                  : u === 'left'
                  ? (S = [b, m])
                  : u === 'right' && (S = [-b, m]),
                  S &&
                    e.addShape('circle', {
                      attrs: r(r({}, g), { x: S[0], y: S[1], r: d / 2 || p || 5 }),
                      className: 'link-point-bottom',
                      name: 'link-point-bottom',
                    });
              }
            },
            getPath(t) {
              const e = this.getOptions(t).direction;
              const n = t.direction || e;
              const r = this.getSize(t)[0];
              const i = r * Math.sin((1 / 3) * Math.PI);
              const o = r * Math.sin((1 / 3) * Math.PI);
              let a = [['M', -o, i], ['L', 0, -i], ['L', o, i], ['Z']];
              return (
                n === 'down'
                  ? (a = [['M', -o, -i], ['L', o, -i], ['L', 0, i], ['Z']])
                  : n === 'left'
                  ? (a = [['M', -o, o - i], ['L', o, -o], ['L', o, o], ['Z']])
                  : n === 'right' && (a = [['M', o, o - i], ['L', -o, o], ['L', -o, -o], ['Z']]),
                a
              );
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getPath(t);
              return r({ path: o }, i);
            },
            update(t, e) {
              const n = e.getContainer();
              const r = this.getOptions({}).style;
              const i = this.getPath(t);
              const o = { stroke: t.color, path: i };
              const s = e.get('keyShape');
              let u = Object(a.r)({}, r, s.attr(), o);
              (u = Object(a.r)(u, t.style)),
                this.updateShape(t, e, u, !0),
                this.updateLinkPoints(t, n);
            },
            updateLinkPoints(t, e) {
              const n = this.getOptions({});
              const i = n.linkPoints;
              const o = n.direction;
              const s = t.direction || o;
              const u = e.find((t) => {
                return t.get('className') === 'link-point-left';
              });
              const c = e.find((t) => {
                return t.get('className') === 'link-point-right';
              });
              const h = e.find((t) => {
                return t.get('className') === 'link-point-top';
              });
              const l = e.find((t) => {
                return t.get('className') === 'link-point-bottom';
              });
              let f = i;
              const d = u || c || h || l;
              d && (f = d.attr());
              const p = Object(a.r)({}, f, t.linkPoints);
              const g = p.fill;
              const v = p.stroke;
              const y = p.lineWidth;
              let m = p.size / 2;
              m || (m = p.r);
              const b = t.linkPoints
                ? t.linkPoints
                : { left: void 0, right: void 0, top: void 0, bottom: void 0 };
              const x = b.left;
              const M = b.right;
              const S = b.top;
              const w = b.bottom;
              const O = this.getSize(t)[0];
              const C = { r: m, fill: g, stroke: v, lineWidth: y };
              let E = null;
              const k = O * Math.sin((1 / 3) * Math.PI);
              const T = O * Math.sin((1 / 3) * Math.PI);
              s === 'up'
                ? (E = [-T, k])
                : s === 'down'
                ? (E = [-T, -k])
                : s === 'left' && (E = [-T, T - k]),
                E &&
                  (u
                    ? x || void 0 === x
                      ? u.attr(r(r({}, C), { x: E[0], y: E[1] }))
                      : u.remove()
                    : x &&
                      e.addShape('circle', {
                        attrs: r(r({}, C), { x: E[0], y: E[1] }),
                        className: 'link-point-left',
                        name: 'link-point-left',
                        isAnchorPoint: !0,
                      }));
              let P = null;
              s === 'up'
                ? (P = [T, k])
                : s === 'down'
                ? (P = [T, -k])
                : s === 'right' && (P = [T, T - k]),
                P &&
                  (c
                    ? M || void 0 === M
                      ? c.attr(r(r({}, C), { x: P[0], y: P[1] }))
                      : c.remove()
                    : M &&
                      e.addShape('circle', {
                        attrs: r(r({}, C), { x: P[0], y: P[1] }),
                        className: 'link-point-right',
                        name: 'link-point-right',
                        isAnchorPoint: !0,
                      }));
              let I = null;
              s === 'up'
                ? (I = [T - k, -k])
                : s === 'left'
                ? (I = [T, -k])
                : s === 'right' && (I = [-T, -k]),
                I &&
                  (h
                    ? S || void 0 === S
                      ? h.attr(r(r({}, C), { x: I[0], y: I[1] }))
                      : h.remove()
                    : S &&
                      e.addShape('circle', {
                        attrs: r(r({}, C), { x: I[0], y: I[1] }),
                        className: 'link-point-top',
                        name: 'link-point-top',
                        isAnchorPoint: !0,
                      }));
              let A = null;
              s === 'down'
                ? (A = [-T + k, k])
                : s === 'left'
                ? (A = [T, k])
                : s === 'right' && (A = [-T, k]),
                A &&
                  (l
                    ? w || void 0 === w
                      ? l.attr(r(r({}, C), { x: A[0], y: A[1] }))
                      : l.remove()
                    : w &&
                      e.addShape('circle', {
                        attrs: r(r({}, C), { x: A[0], y: A[1] }),
                        className: 'link-point-bottom',
                        name: 'link-point-bottom',
                        isAnchorPoint: !0,
                      }));
            },
          },
          'single-node',
        ),
        Object(o.r)(
          'modelRect',
          {
            options: {
              size: [185, 70],
              style: {
                radius: 5,
                stroke: '#69c0ff',
                fill: '#ffffff',
                lineWidth: o.e.defaultNode.style.lineWidth,
                fillOpacity: 1,
              },
              labelCfg: { style: { fill: '#595959', fontSize: 14 }, offset: 30 },
              descriptionCfg: { style: { fontSize: 12, fill: '#bfbfbf' }, paddingTop: 0 },
              preRect: { show: !0, width: 4, fill: '#40a9ff', radius: 2 },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: 10,
                lineWidth: 1,
                fill: '#72CC4A',
                stroke: '#72CC4A',
              },
              logoIcon: {
                show: !0,
                x: 0,
                y: 0,
                img: 'https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg',
                width: 16,
                height: 16,
                offset: 0,
              },
              stateIcon: {
                show: !0,
                x: 0,
                y: 0,
                img: 'https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg',
                width: 16,
                height: 16,
                offset: -5,
              },
              anchorPoints: [
                [0, 0.5],
                [1, 0.5],
              ],
            },
            shapeType: 'modelRect',
            drawShape(t, e) {
              const n = this.getOptions(t).preRect;
              const o = void 0 === n ? {} : n;
              const a = this.getShapeStyle(t);
              const s = this.getSize(t);
              const u = s[0];
              const c = s[1];
              const h = e.addShape('rect', {
                attrs: a,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              const l = o.show;
              const f = i(o, ['show']);
              return (
                l &&
                  e.addShape('rect', {
                    attrs: r({ x: -u / 2, y: -c / 2, height: c }, f),
                    className: 'pre-rect',
                    name: 'pre-rect',
                    draggable: !0,
                  }),
                this.drawLogoIcon(t, e),
                this.drawStateIcon(t, e),
                this.drawLinkPoints(t, e),
                h
              );
            },
            drawLogoIcon(t, e) {
              const n = this.getOptions(t).logoIcon;
              const o = void 0 === n ? {} : n;
              const a = this.getSize(t)[0];
              if (o.show) {
                const s = o.width;
                const u = o.height;
                const c = o.x;
                const h = o.y;
                const l = o.offset;
                const f = o.text;
                const d = i(o, ['width', 'height', 'x', 'y', 'offset', 'text']);
                f
                  ? e.addShape('text', {
                      attrs: r(
                        {
                          x: 0,
                          y: 0,
                          fontSize: 12,
                          fill: '#000',
                          stroke: '#000',
                          textBaseline: 'middle',
                          textAlign: 'center',
                        },
                        d,
                      ),
                      className: 'rect-logo-icon',
                      name: 'rect-logo-icon',
                      draggable: !0,
                    })
                  : e.addShape('image', {
                      attrs: r(r({}, d), {
                        x: c || -a / 2 + s + l,
                        y: h || -u / 2,
                        width: s,
                        height: u,
                      }),
                      className: 'rect-logo-icon',
                      name: 'rect-logo-icon',
                      draggable: !0,
                    });
              }
            },
            drawStateIcon(t, e) {
              const n = this.getOptions(t).stateIcon;
              const o = void 0 === n ? {} : n;
              const a = this.getSize(t)[0];
              if (o.show) {
                const s = o.width;
                const u = o.height;
                const c = o.x;
                const h = o.y;
                const l = o.offset;
                const f = o.text;
                const d = i(o, ['width', 'height', 'x', 'y', 'offset', 'text']);
                f
                  ? e.addShape('text', {
                      attrs: r(
                        {
                          x: 0,
                          y: 0,
                          fontSize: 12,
                          fill: '#000',
                          stroke: '#000',
                          textBaseline: 'middle',
                          textAlign: 'center',
                        },
                        d,
                      ),
                      className: 'rect-state-icon',
                      name: 'rect-state-icon',
                      draggable: !0,
                    })
                  : e.addShape('image', {
                      attrs: r(r({}, d), {
                        x: c || a / 2 - s + l,
                        y: h || -u / 2,
                        width: s,
                        height: u,
                      }),
                      className: 'rect-state-icon',
                      name: 'rect-state-icon',
                      draggable: !0,
                    });
              }
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t).linkPoints;
              const o = void 0 === n ? {} : n;
              const a = o.top;
              const s = o.left;
              const u = o.right;
              const c = o.bottom;
              const h = o.size;
              const l = o.r;
              const f = i(o, ['top', 'left', 'right', 'bottom', 'size', 'r']);
              const d = this.getSize(t);
              const p = d[0];
              const g = d[1];
              s &&
                e.addShape('circle', {
                  attrs: r(r({}, f), { x: -p / 2, y: 0, r: h / 2 || l || 5 }),
                  className: 'link-point-left',
                  name: 'link-point-left',
                  isAnchorPoint: !0,
                }),
                u &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: p / 2, y: 0, r: h / 2 || l || 5 }),
                    className: 'link-point-right',
                    name: 'link-point-right',
                    isAnchorPoint: !0,
                  }),
                a &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: -g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-top',
                    name: 'link-point-top',
                    isAnchorPoint: !0,
                  }),
                c &&
                  e.addShape('circle', {
                    attrs: r(r({}, f), { x: 0, y: g / 2, r: h / 2 || l || 5 }),
                    className: 'link-point-bottom',
                    name: 'link-point-bottom',
                    isAnchorPoint: !0,
                  });
            },
            drawLabel(t, e) {
              const n = this.getOptions(t);
              const i = n.labelCfg;
              const o = void 0 === i ? {} : i;
              const s = n.logoIcon;
              const u = void 0 === s ? {} : s;
              const c = n.descriptionCfg;
              const h = void 0 === c ? {} : c;
              const l = this.getSize(t)[0];
              let f = null;
              const d = u.show;
              const p = u.width;
              let g = -l / 2 + o.offset;
              d && (g = -l / 2 + p + o.offset);
              const v = o.style;
              const y = h.style;
              const m = h.paddingTop;
              return (
                Object(a.o)(t.description)
                  ? ((f = e.addShape('text', {
                      attrs: r(r({}, v), { x: g, y: -5, text: t.label }),
                      className: 'text-shape',
                      name: 'text-shape',
                      draggable: !0,
                    })),
                    e.addShape('text', {
                      attrs: r(r({}, y), { x: g, y: 17 + (m || 0), text: t.description }),
                      className: 'rect-description',
                      name: 'rect-description',
                      draggable: !0,
                    }))
                  : (f = e.addShape('text', {
                      attrs: r(r({}, v), { x: g, y: 7, text: t.label }),
                      className: 'text-shape',
                      name: 'text-shape',
                      draggable: !0,
                    })),
                f
              );
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getSize(t);
              const s = i.width || o[0];
              const u = i.height || o[1];
              return r({ x: -s / 2, y: -u / 2, width: s, height: u }, i);
            },
            update(t, e) {
              const n = this.getOptions(t);
              const o = n.style;
              const s = void 0 === o ? {} : o;
              const u = n.labelCfg;
              const c = void 0 === u ? {} : u;
              const h = n.descriptionCfg;
              const l = void 0 === h ? {} : h;
              const f = this.getSize(t);
              const d = f[0];
              const p = f[1];
              e.get('keyShape').attr(r(r({}, s), { x: -d / 2, y: -p / 2, width: d, height: p }));
              const g = e.getContainer();
              const v = g.find((t) => {
                return t.get('className') === 'rect-logo-icon';
              });
              const y = v ? v.attr() : {};
              const m = Object(a.r)({}, y, t.logoIcon);
              let b = m.width;
              void 0 === b && (b = this.options.logoIcon.width);
              const x = t.logoIcon ? t.logoIcon.show : void 0;
              const M = c.offset;
              let S = -d / 2 + b + M;
              x || void 0 === x || (S = -d / 2 + M);
              const w = g.find((t) => {
                return t.get('className') === 'node-label';
              });
              const O = g.find((t) => {
                return t.get('className') === 'rect-description';
              });
              if (t.label)
                if (w) {
                  var C = t.labelCfg ? t.labelCfg.style : {};
                  const E = Object(a.r)({}, w.attr(), C);
                  t.label && (E.text = t.label),
                    (E.x = S),
                    Object(a.o)(t.description) && (E.y = -5),
                    O && (O.resetMatrix(), O.attr({ x: S })),
                    w.resetMatrix(),
                    w.attr(E);
                } else
                  g.addShape('text', {
                    attrs: r(r({}, c.style), { x: S, y: t.description ? -5 : 7, text: t.label }),
                    className: 'node-label',
                    name: 'node-label',
                    draggable: !0,
                  });
              if (Object(a.o)(t.description)) {
                const k = l.paddingTop;
                if (O) {
                  C = t.descriptionCfg ? t.descriptionCfg.style : {};
                  const T = Object(a.r)({}, O.attr(), C);
                  Object(a.o)(t.description) && (T.text = t.description),
                    (T.x = S),
                    O.resetMatrix(),
                    O.attr(r(r({}, T), { y: 17 + (k || 0) }));
                } else
                  g.addShape('text', {
                    attrs: r(r({}, l.style), { x: S, y: 17 + (k || 0), text: t.description }),
                    className: 'rect-description',
                    name: 'rect-description',
                    draggable: !0,
                  });
              }
              const P = g.find((t) => {
                return t.get('className') === 'pre-rect';
              });
              if (P) {
                const I = Object(a.r)({}, P.attr(), t.preRect);
                P.attr(r(r({}, I), { x: -d / 2, y: -p / 2, height: p }));
              }
              if (v)
                if (x || void 0 === x) {
                  const A = m.width;
                  var j = m.height;
                  var N = m.x;
                  var _ = m.y;
                  const B = m.offset;
                  const L = i(m, ['width', 'height', 'x', 'y', 'offset']);
                  v.attr(
                    r(r({}, L), { x: N || -d / 2 + A + B, y: _ || -j / 2, width: A, height: j }),
                  );
                } else v.remove();
              else x && this.drawLogoIcon(t, g);
              const D = g.find((t) => {
                return t.get('className') === 'rect-state-icon';
              });
              const R = D ? D.attr() : {};
              const Y = Object(a.r)({}, R, t.stateIcon);
              if (D) {
                Y.show || void 0 === Y.show || D.remove();
                const F = Y.width;
                const X = ((j = Y.height), (N = Y.x), (_ = Y.y), Y.offset);
                const z = i(Y, ['width', 'height', 'x', 'y', 'offset']);
                D.attr(r(r({}, z), { x: N || d / 2 - F + X, y: _ || -j / 2, width: F, height: j }));
              } else Y.show && this.drawStateIcon(t, g);
              this.updateLinkPoints(t, g);
            },
          },
          'single-node',
        ),
        Object(o.r)(
          'star',
          {
            options: {
              size: 60,
              style: {
                stroke: o.e.defaultNode.style.stroke,
                fill: o.e.defaultNode.style.fill,
                lineWidth: o.e.defaultNode.style.lineWidth,
              },
              labelCfg: {
                style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
              },
              linkPoints: {
                top: !1,
                right: !1,
                bottom: !1,
                left: !1,
                size: o.e.defaultNode.linkPoints.size,
                lineWidth: o.e.defaultNode.linkPoints.lineWidth,
                fill: o.e.defaultNode.linkPoints.fill,
                stroke: o.e.defaultNode.linkPoints.stroke,
              },
              icon: {
                show: !1,
                img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
                width: 20,
                height: 20,
              },
              stateStyles: r({}, o.e.nodeStateStyles),
            },
            shapeType: 'star',
            labelPosition: 'center',
            drawShape(t, e) {
              const n = this.getOptions(t).icon;
              const i = void 0 === n ? {} : n;
              const o = this.getShapeStyle(t);
              const a = e.addShape('path', {
                attrs: o,
                className: `${this.type}-keyShape`,
                name: `${this.type}-keyShape`,
                draggable: !0,
              });
              const s = i.width;
              const u = i.height;
              const c = i.show;
              const h = i.text;
              return (
                c &&
                  (h
                    ? e.addShape('text', {
                        attrs: r(
                          {
                            x: 0,
                            y: 0,
                            fontSize: 12,
                            fill: '#000',
                            stroke: '#000',
                            textBaseline: 'middle',
                            textAlign: 'center',
                          },
                          i,
                        ),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })
                    : e.addShape('image', {
                        attrs: r({ x: -s / 2, y: -u / 2 }, i),
                        className: `${this.type}-icon`,
                        name: `${this.type}-icon`,
                        draggable: !0,
                      })),
                this.drawLinkPoints(t, e),
                a
              );
            },
            drawLinkPoints(t, e) {
              const n = this.getOptions(t).linkPoints;
              const o = void 0 === n ? {} : n;
              const a = o.top;
              const s = o.left;
              const u = o.right;
              const c = o.leftBottom;
              const h = o.rightBottom;
              const l = o.size;
              const f = o.r;
              const d = i(o, ['top', 'left', 'right', 'leftBottom', 'rightBottom', 'size', 'r']);
              const p = this.getSize(t)[0];
              if (u) {
                var g = Math.cos(0.1 * Math.PI) * p;
                var v = Math.sin(0.1 * Math.PI) * p;
                e.addShape('circle', {
                  attrs: r(r({}, d), { x: g, y: -v, r: l / 2 || f || 5 }),
                  className: 'link-point-right',
                  name: 'link-point-right',
                });
              }
              if (a) {
                (g = Math.cos(0.5 * Math.PI) * p), (v = Math.sin(0.5 * Math.PI) * p);
                e.addShape('circle', {
                  attrs: r(r({}, d), { x: g, y: -v, r: l / 2 || f || 5 }),
                  className: 'link-point-top',
                  name: 'link-point-top',
                });
              }
              if (s) {
                (g = Math.cos(0.9 * Math.PI) * p), (v = Math.sin(0.9 * Math.PI) * p);
                e.addShape('circle', {
                  attrs: r(r({}, d), { x: g, y: -v, r: l / 2 || f || 5 }),
                  className: 'link-point-left',
                  name: 'link-point-left',
                });
              }
              if (c) {
                (g = Math.cos(1.3 * Math.PI) * p), (v = Math.sin(1.3 * Math.PI) * p);
                e.addShape('circle', {
                  attrs: r(r({}, d), { x: g, y: -v, r: l / 2 || f || 5 }),
                  className: 'link-point-left-bottom',
                  name: 'link-point-left-bottom',
                });
              }
              if (h) {
                (g = Math.cos(1.7 * Math.PI) * p), (v = Math.sin(1.7 * Math.PI) * p);
                e.addShape('circle', {
                  attrs: r(r({}, d), { x: g, y: -v, r: l / 2 || f || 5 }),
                  className: 'link-point-right-bottom',
                  name: 'link-point-right-bottom',
                });
              }
            },
            getPath(t) {
              for (
                var e = this.getSize(t)[0], n = (3 * e) / 8, r = t.innerR || n, i = [], o = 0;
                o < 5;
                o++
              ) {
                const a = Math.cos(((18 + 72 * o) / 180) * Math.PI) * e;
                const s = Math.sin(((18 + 72 * o) / 180) * Math.PI) * e;
                const u = Math.cos(((54 + 72 * o) / 180) * Math.PI) * r;
                const c = Math.sin(((54 + 72 * o) / 180) * Math.PI) * r;
                o === 0 ? i.push(['M', a, -s]) : i.push(['L', a, -s]), i.push(['L', u, -c]);
              }
              return i.push(['Z']), i;
            },
            getShapeStyle(t) {
              const e = this.getOptions(t).style;
              const n = { stroke: t.color };
              const i = Object(a.r)({}, e, n);
              const o = this.getPath(t);
              return r({ path: o }, i);
            },
            update(t, e) {
              const n = e.getContainer();
              const r = this.getOptions({}).style;
              const i = this.getPath(t);
              const o = { stroke: t.color, path: i };
              const s = e.get('keyShape');
              let u = Object(a.r)({}, r, s.attr(), o);
              (u = Object(a.r)(u, t.style)),
                this.updateShape(t, e, u, !0),
                this.updateLinkPoints(t, n);
            },
            updateLinkPoints(t, e) {
              const n = this.getOptions({}).linkPoints;
              const i = e.find((t) => {
                return t.get('className') === 'link-point-left';
              });
              const o = e.find((t) => {
                return t.get('className') === 'link-point-right';
              });
              const s = e.find((t) => {
                return t.get('className') === 'link-point-top';
              });
              const u = e.find((t) => {
                return t.get('className') === 'link-point-left-bottom';
              });
              const c = e.find((t) => {
                return t.get('className') === 'link-point-right-bottom';
              });
              let h = n;
              const l = i || o || s || u || c;
              l && (h = l.attr());
              const f = Object(a.r)({}, h, t.linkPoints);
              const d = f.fill;
              const p = f.stroke;
              const g = f.lineWidth;
              let v = f.size / 2;
              v || (v = f.r);
              const y = t.linkPoints
                ? t.linkPoints
                : {
                    left: void 0,
                    right: void 0,
                    top: void 0,
                    leftBottom: void 0,
                    rightBottom: void 0,
                  };
              const m = y.left;
              const b = y.right;
              const x = y.top;
              const M = y.leftBottom;
              const S = y.rightBottom;
              const w = this.getSize(t)[0];
              const O = { r: v, fill: d, stroke: p, lineWidth: g };
              let C = Math.cos(0.1 * Math.PI) * w;
              let E = Math.sin(0.1 * Math.PI) * w;
              o
                ? b || void 0 === b
                  ? o.attr(r(r({}, O), { x: C, y: -E }))
                  : o.remove()
                : b &&
                  e.addShape('circle', {
                    attrs: r(r({}, O), { x: C, y: -E }),
                    className: 'link-point-right',
                    name: 'link-point-right',
                    isAnchorPoint: !0,
                  }),
                (C = Math.cos(0.5 * Math.PI) * w),
                (E = Math.sin(0.5 * Math.PI) * w),
                s
                  ? x || void 0 === x
                    ? s.attr(r(r({}, O), { x: C, y: -E }))
                    : s.remove()
                  : x &&
                    e.addShape('circle', {
                      attrs: r(r({}, O), { x: C, y: -E }),
                      className: 'link-point-top',
                      name: 'link-point-top',
                      isAnchorPoint: !0,
                    }),
                (C = Math.cos(0.9 * Math.PI) * w),
                (E = Math.sin(0.9 * Math.PI) * w),
                i
                  ? m || void 0 === m
                    ? i.attr(r(r({}, O), { x: C, y: -E }))
                    : i.remove()
                  : m &&
                    e.addShape('circle', {
                      attrs: r(r({}, O), { x: C, y: -E }),
                      className: 'link-point-left',
                      name: 'link-point-left',
                      isAnchorPoint: !0,
                    }),
                (C = Math.cos(1.3 * Math.PI) * w),
                (E = Math.sin(1.3 * Math.PI) * w),
                u
                  ? M || void 0 === M
                    ? u.attr(r(r({}, O), { x: C, y: -E }))
                    : u.remove()
                  : M &&
                    e.addShape('circle', {
                      attrs: r(r({}, O), { x: C, y: -E }),
                      className: 'link-point-left-bottom',
                      name: 'link-point-left-bottom',
                      isAnchorPoint: !0,
                    }),
                (C = Math.cos(1.7 * Math.PI) * w),
                (E = Math.sin(1.7 * Math.PI) * w),
                c
                  ? S || void 0 === S
                    ? c.attr(r(r({}, O), { x: C, y: -E }))
                    : u.remove()
                  : S &&
                    e.addShape('circle', {
                      attrs: r(r({}, O), { x: C, y: -E }),
                      className: 'link-point-right-bottom',
                      name: 'link-point-right-bottom',
                      isAnchorPoint: !0,
                    });
            },
          },
          'single-node',
        );
      const s = o.n.defaultSubjectColors;
      Object(o.r)(
        'donut',
        {
          options: {
            size: o.e.defaultNode.size,
            style: {
              x: 0,
              y: 0,
              stroke: o.e.defaultNode.style.stroke,
              fill: o.e.defaultNode.style.fill,
              lineWidth: o.e.defaultNode.style.lineWidth,
            },
            labelCfg: {
              style: { fill: o.e.nodeLabel.style.fill, fontSize: o.e.nodeLabel.style.fontSize },
            },
            linkPoints: {
              top: !1,
              right: !1,
              bottom: !1,
              left: !1,
              size: o.e.defaultNode.linkPoints.size,
              lineWidth: o.e.defaultNode.linkPoints.lineWidth,
              fill: o.e.defaultNode.linkPoints.fill,
              stroke: o.e.defaultNode.linkPoints.stroke,
            },
            icon: {
              show: !1,
              img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',
              width: 20,
              height: 20,
            },
            stateStyles: r({}, o.e.nodeStateStyles),
          },
          shapeType: 'circle',
          labelPosition: 'center',
          drawShape(t, e) {
            const n = this.getOptions(t).icon;
            const i = void 0 === n ? {} : n;
            const o = this.getShapeStyle(t);
            const u = Object(a.b)({}, i, t.icon);
            const c = e.addShape('circle', {
              attrs: o,
              className: `${this.type}-keyShape`,
              draggable: !0,
              name: `${this.type}-keyShape`,
            });
            const h = u.width;
            const l = u.height;
            const f = u.show;
            const d = u.text;
            f &&
              (d
                ? e.addShape('text', {
                    attrs: r(
                      {
                        x: 0,
                        y: 0,
                        fontSize: 12,
                        fill: '#000',
                        stroke: '#000',
                        textBaseline: 'middle',
                        textAlign: 'center',
                      },
                      u,
                    ),
                    className: `${this.type}-icon`,
                    name: `${this.type}-icon`,
                    draggable: !0,
                  })
                : e.addShape('image', {
                    attrs: r({ x: -h / 2, y: -l / 2 }, u),
                    className: `${this.type}-icon`,
                    name: `${this.type}-icon`,
                    draggable: !0,
                  }));
            const p = c.attr('r');
            const g = 0.6 * p;
            const v = (p + g) / 2;
            const y = t;
            const m = y.donutAttrs;
            const b = void 0 === m ? {} : m;
            const x = y.donutColorMap;
            const M = void 0 === x ? {} : x;
            const S = Object.keys(b).length;
            if (b && S > 1) {
              const w = [];
              let O = 0;
              if (
                (Object.keys(b).forEach((t) => {
                  const e = b[t] || 0;
                  Object(a.k)(e) && (w.push({ key: t, value: e, color: M[t] }), (O += e));
                }),
                O)
              ) {
                const C = p - g;
                if (S === 1)
                  return void e.addShape('circle', {
                    attrs: { r: v, x: 0, y: 0, stroke: w[0].color || s[0], lineWidth: C },
                    name: 'fan-shape-0',
                  });
                let E = [v, 0];
                let k = 0;
                w.forEach((t, n) => {
                  let r = t.value / O;
                  if (!(r < 0.001))
                    if ((r > 0.999 && (r = 1), r !== 1)) {
                      (t.percent = r),
                        (t.angle = r * Math.PI * 2),
                        (t.beginAgnle = k),
                        (k += t.angle),
                        (t.endAngle = k),
                        (t.arcBegin = E),
                        (t.arcEnd = [v * Math.cos(t.endAngle), -v * Math.sin(t.endAngle)]);
                      const i = t.angle > Math.PI ? 1 : 0;
                      const o = [
                        ['M', t.arcBegin[0], t.arcBegin[1]],
                        ['A', v, v, 0, i, 0, t.arcEnd[0], t.arcEnd[1]],
                        ['L', t.arcEnd[0], t.arcEnd[1]],
                      ];
                      e.addShape('path', {
                        attrs: { path: o, lineWidth: C, stroke: t.color || s[n % s.length] },
                        name: `fan-shape-${n}`,
                      }),
                        (E = t.arcEnd);
                    } else
                      e.addShape('circle', {
                        attrs: {
                          r: v,
                          x: 0,
                          y: 0,
                          stroke: t.color || s[n % s.length],
                          lineWidth: C,
                        },
                        name: `fan-shape-${n}`,
                      });
                });
              }
            }
            return this.drawLinkPoints(t, e), c;
          },
          update: void 0,
        },
        'circle',
      );
      const u = function (t) {
        const e = t.x;
        const n = t.y;
        return {
          x: e,
          y: n,
          centerX: e,
          centerY: n,
          minX: e,
          minY: n,
          maxX: e,
          maxY: n,
          height: 0,
          width: 0,
        };
      };
      const c = function (t) {
        for (var e = [], n = {}, r = t.length - 1; r >= 0; r--) {
          const i = t[r];
          (i.id = `${i.x}|||${i.y}`), (n[i.id] = i), e.push(i);
        }
        return e;
      };
      const h = function (t) {
        return c(t);
      };
      const l = function (t, e) {
        return t.width || t.height
          ? {
              centerX: t.centerX,
              centerY: t.centerY,
              minX: t.minX - e,
              minY: t.minY - e,
              maxX: t.maxX + e,
              maxY: t.maxY + e,
              height: t.height + 2 * e,
              width: t.width + 2 * e,
            }
          : t;
      };
      const f = function (t, e, n) {
        const r = (function (t, e) {
          const n = Math.abs(t.x - e.centerX);
          const r = Math.abs(t.y - e.centerY);
          return n === 0 && r === 0 ? 0 : n / e.width > r / e.height;
        })(e, t);
        if (r === 0) {
          let i = t.centerX;
          let o = t.centerY;
          return (
            n.y < e.y
              ? (o = t.minY)
              : n.x > e.x
              ? (i = t.maxX)
              : n.x < e.x
              ? (i = t.minX)
              : n.x === e.x && (o = t.maxY),
            { x: i, y: o }
          );
        }
        return r
          ? { x: e.x > t.centerX ? t.maxX : t.minX, y: e.y }
          : { x: e.x, y: e.y > t.centerY ? t.maxY : t.minY };
      };
      const d = function (t, e) {
        const n = Math.min(t.minX, e.minX);
        const r = Math.min(t.minY, e.minY);
        const i = Math.max(t.maxX, e.maxX);
        const o = Math.max(t.maxY, e.maxY);
        return {
          centerX: (n + i) / 2,
          centerY: (r + o) / 2,
          minX: n,
          minY: r,
          maxX: i,
          maxY: o,
          height: o - r,
          width: i - n,
        };
      };
      const p = function (t) {
        return [
          { x: t.minX, y: t.minY },
          { x: t.maxX, y: t.minY },
          { x: t.maxX, y: t.maxY },
          { x: t.minX, y: t.maxY },
        ];
      };
      const g = function (t, e) {
        const n = t.x;
        const r = t.y;
        return n < e.minX || n > e.maxX || r < e.minY || r > e.maxY;
      };
      const v = function (t, e) {
        return Math.abs(t.x - e.x) + Math.abs(t.y - e.y);
      };
      const y = function (t, e, n, r, i) {
        return (
          v(t, e) +
          v(t, n) +
          (function (t, e) {
            let n = 0;
            return (
              e.forEach((e) => {
                e && (t.x === e.x && (n += -2), t.y === e.y && (n += -2));
              }),
              n
            );
          })(t, [e, n, r, i])
        );
      };
      const m = function t(e, n, r, i, o) {
        void 0 === o && (o = 0),
          e.unshift(n[i]),
          r[i] && r[i] !== i && o <= 100 && t(e, n, r, r[i], o + 1);
      };
      const b = function (t, e, n, r) {
        const i = n.x - t.x;
        const o = n.y - t.y;
        const a = r.x - t.x;
        const s = r.y - t.y;
        const u = n.x - e.x;
        const c = n.y - e.y;
        const h = r.x - e.x;
        const l = r.y - e.y;
        return (i * s - o * a) * (u * l - c * h) <= 0 && (i * c - o * u) * (a * l - s * h) <= 0;
      };
      const x = function (t, e, n) {
        if (n.width || n.height) {
          const r = p(n);
          const i = r[0];
          const o = r[1];
          const a = r[2];
          const s = r[3];
          return b(t, e, i, o) || b(t, e, i, s) || b(t, e, o, a) || b(t, e, a, s);
        }
        return !1;
      };
      const M = function (t, e, n, r) {
        const i = [];
        return (
          t.forEach((t) => {
            if (t !== e && (t.x === e.x || t.y === e.y)) {
              if (x(t, e, n) || x(t, e, r)) return;
              i.push(t);
            }
          }),
          c(i)
        );
      };
      const S = function (t, e) {
        const n = [];
        const r = t[0];
        return (
          n.push(`M${r.x} ${r.y}`),
          t.forEach((r, i) => {
            const o = t[i + 1];
            const a = t[i + 2];
            if (o && a)
              if (
                (function (t, e, n) {
                  return !((t.x === e.x && e.x === n.x) || (t.y === e.y && e.y === n.y));
                })(r, o, a)
              ) {
                const s = (function (t, e, n, r) {
                  const i = v(t, e);
                  const o = v(n, e);
                  return (
                    i < r && (r = i),
                    o < r && (r = o),
                    [
                      { x: e.x - (r / i) * (e.x - t.x), y: e.y - (r / i) * (e.y - t.y) },
                      { x: e.x - (r / o) * (e.x - n.x), y: e.y - (r / o) * (e.y - n.y) },
                    ]
                  );
                })(r, o, a, e);
                const u = s[0];
                const c = s[1];
                n.push(`L${u.x} ${u.y}`),
                  n.push(`Q${o.x} ${o.y} ${c.x} ${c.y}`),
                  n.push(`L${c.x} ${c.y}`);
              } else n.push(`L${o.x} ${o.y}`);
            else o && n.push(`L${o.x} ${o.y}`);
          }),
          n.join('')
        );
      };
      const w = function (t, e, n, r, i) {
        let o;
        let a;
        if (n && n.getType())
          if (n.getType() === 'combo') {
            ((o = n.getKeyShape().getCanvasBBox() || u(t)).centerX = (o.minX + o.maxX) / 2),
              (o.centerY = (o.minY + o.maxY) / 2);
          } else o = n.getBBox();
        else o = u(t);
        if (r && r.getType())
          if (r.getType() === 'combo') {
            const s = r.getKeyShape().getBBox();
            if (s) {
              const b = r.getModel();
              const { x } = b;
              const S = b.y;
              ((a = {
                x,
                y: S,
                width: s.width,
                height: s.height,
                minX: s.minX + x,
                maxX: s.maxX + x,
                minY: s.minY + S,
                maxY: s.maxY + S,
              }).centerX = (a.minX + a.maxX) / 2),
                (a.centerY = (a.minY + a.maxY) / 2);
            } else a = u(e);
          } else a = r && r.getBBox();
        else a = u(e);
        const w = l(o, i);
        const O = l(a, i);
        const C = f(w, t, e);
        const E = f(O, e, t);
        const k = (function (t) {
          void 0 === t && (t = []);
          const e = [];
          const n = [];
          t.forEach((t) => {
            e.push(t.x), n.push(t.y);
          });
          const r = Math.min.apply(Math, e);
          const i = Math.max.apply(Math, e);
          const o = Math.min.apply(Math, n);
          const a = Math.max.apply(Math, n);
          return {
            centerX: (r + i) / 2,
            centerY: (o + a) / 2,
            maxX: i,
            maxY: a,
            minX: r,
            minY: o,
            height: a - o,
            width: i - r,
          };
        })([C, E]);
        const T = d(w, k);
        const P = d(O, k);
        let I = [];
        I = I.concat(p(T)).concat(p(P));
        const A = { x: (t.x + e.x) / 2, y: (t.y + e.y) / 2 };
        [k, T, P].forEach((t) => {
          I = I.concat(
            (function (t, e) {
              return (function (t, e) {
                return e < t.minX || e > t.maxX
                  ? []
                  : [
                      { x: e, y: t.minY },
                      { x: e, y: t.maxY },
                    ];
              })(t, e.x).concat(
                (function (t, e) {
                  return e < t.minY || e > t.maxY
                    ? []
                    : [
                        { x: t.minX, y: e },
                        { x: t.maxX, y: e },
                      ];
                })(t, e.y),
              );
            })(t, A).filter((t) => {
              return g(t, w) && g(t, O);
            }),
          );
        }),
          [
            { x: C.x, y: E.y },
            { x: E.x, y: C.y },
          ].forEach((t) => {
            g(t, w) && g(t, O) && I.push(t);
          }),
          I.unshift(C),
          I.push(E);
        const j = (function (t, e, n, r, i, o, a) {
          const s = [];
          const u = [e];
          const c = {};
          const h = {};
          const l = {};
          (h[e.id] = 0), (l[e.id] = y(e, n, e));
          let f;
          let d;
          let p;
          let g;
          let b;
          const x = {};
          for (
            t.forEach((t) => {
              x[t.id] = t;
            });
            u.length;

          ) {
            if (
              ((f = void 0),
              (d = 1 / 0),
              u.forEach((t) => {
                l[t.id] <= d && ((d = l[t.id]), (f = t));
              }),
              f === n)
            ) {
              const S = [];
              return m(S, x, c, n.id), S;
            }
            (g = f),
              (b = void 0),
              (b = (p = u).indexOf(g)) > -1 && p.splice(b, 1),
              s.push(f),
              M(t, f, r, i).forEach((t) => {
                if (s.indexOf(t) === -1) {
                  u.indexOf(t) === -1 && u.push(t);
                  const r = l[f.id] + v(f, t);
                  (h[t.id] && r >= h[t.id]) ||
                    ((c[t.id] = f.id), (h[t.id] = r), (l[t.id] = h[t.id] + y(t, n, e, o, a)));
                }
              });
          }
          return [e, n];
        })((I = c(I)), C, E, o, a, t, e);
        return j.unshift(t), j.push(e), h(j);
      };
      const O = {
        offset: 20,
        maxAllowedDirectionChange: Math.PI / 2,
        maximumLoops: 2e3,
        gridSize: 10,
        directions: [
          { stepX: 1, stepY: 0 },
          { stepX: -1, stepY: 0 },
          { stepX: 0, stepY: 1 },
          { stepX: 0, stepY: -1 },
        ],
        get penalties() {
          return { 0: 0, 45: this.gridSize / 2, 90: this.gridSize / 2 };
        },
        distFunc(t, e) {
          return Math.abs(t.x - e.x) + Math.abs(t.y - e.y);
        },
        fallbackRoute(t, e, n, r, i) {
          return h(w(t, e, n, r, i.offset));
        },
      };
      const C =
        (Math.PI,
        function (t, e) {
          const n = Math.round(Math.abs(t / e));
          return n < 0 ? 0 : (t < 0 ? -1 : 1) * n;
        });
      const E = function (t, e) {
        const n = e.x - t.x;
        const r = e.y - t.y;
        return n || r ? Math.atan2(r, n) : 0;
      };
      const k = function (t, e) {
        const n = Math.abs(t - e);
        return n > Math.PI ? 2 * Math.PI - n : n;
      };
      const T = function (t, e, n) {
        for (var r = 1 / 0, i = 0, o = e.length; i < o; i++) {
          const a = n(t, e[i]);
          a < r && (r = a);
        }
        return r;
      };
      const P = function (t, e, n, r, i) {
        const a = [];
        if (!n) return [t];
        const s = i.directions;
        const u = i.offset;
        const c = n.getBBox();
        const h = e.x > c.minX && e.x < c.maxX && e.y > c.minY && e.y < c.maxY;
        const d = l(c, u);
        for (var p in d) d[p] = C(d[p], i.gridSize);
        if (h) {
          for (let g = 0, v = s; g < v.length; g++) {
            const y = v[g];
            const m = [
              [
                { x: d.minX, y: d.minY },
                { x: d.maxX, y: d.minY },
              ],
              [
                { x: d.minX, y: d.minY },
                { x: d.minX, y: d.maxY },
              ],
              [
                { x: d.maxX, y: d.minY },
                { x: d.maxX, y: d.maxY },
              ],
              [
                { x: d.minX, y: d.maxY },
                { x: d.maxX, y: d.maxY },
              ],
            ];
            for (p = 0; p < 4; p++) {
              const b = m[p];
              const M = o.n.getLineIntersect(
                t,
                { x: t.x + y.stepX * d.width, y: t.y + y.stepY * d.height },
                b[0],
                b[1],
              );
              M && !x(t, M, c) && ((M.id = `${M.x}|||${M.y}`), a.push(M));
            }
          }
          return a;
        }
        const S = f(d, t, r);
        return (S.id = `${S.x}|||${S.y}`), [S];
      };
      const I = function (t, e, n, r) {
        const i = E(t, e);
        if (!n[t.id]) {
          const o = E(r, t);
          return k(o, i);
        }
        const a = E({ x: n[t.id].x, y: n[t.id].y }, t);
        return k(a, i);
      };
      const A = function (t, e, n, r, i, o, a) {
        const s = [r];
        let u = t.id;
        let c = t.x;
        let h = t.y;
        const l = { x: c, y: h, id: u };
        for (
          I(l, o, e, n) &&
          s.unshift({ x: o.x === r.x ? r.x : l.x * a, y: o.y === r.y ? r.y : l.y * a });
          e[u] && e[u].id !== u;

        ) {
          const f = { x: c, y: h, id: u };
          const d = e[u].id;
          const p = e[u].x;
          const g = e[u].y;
          const v = { x: p, y: g, id: d };
          I(v, f, e, n) &&
            s.unshift({ x: v.x === f.x ? s[0].x : v.x * a, y: v.y === f.y ? s[0].y : v.y * a }),
            (u = d),
            (c = p),
            (h = g);
        }
        const y = c;
        const m = h;
        return (
          (s[0].x = y === n.x ? i.x : s[0].x), (s[0].y = m === n.y ? i.y : s[0].y), s.unshift(i), s
        );
      };
      const j = function (t, e, n, r, i) {
        if (isNaN(t.x) || isNaN(e.x)) return [];
        const o = Object(a.b)(O, i);
        o.obstacles = o.obstacles || [];
        const s = o.gridSize;
        const u = (function (t, e, n) {
          const r = {};
          return (
            t.forEach((t) => {
              if (t)
                for (let i = l(t.getBBox(), n), o = C(i.minX, e); o <= C(i.maxX, e); o += 1)
                  for (let a = C(i.minY, e); a <= C(i.maxY, e); a += 1) r[`${o}|||${a}`] = !0;
            }),
            r
          );
        })(o.obstacles.concat([n, r]), s, o.offset);
        const c = { x: C(t.x, s), y: C(t.y, s) };
        const h = { x: C(e.x, s), y: C(e.y, s) };
        (t.id = `${c.x}|||${c.y}`), (e.id = `${h.x}|||${h.y}`);
        const f = P(c, t, n, h, o);
        const d = P(h, e, r, c, o);
        f.forEach((t) => {
          delete u[t.id];
        }),
          d.forEach((t) => {
            delete u[t.id];
          });
        for (var p = {}, g = {}, v = {}, y = {}, m = {}, b = 0; b < f.length; b++) {
          const x = f[b];
          (p[x.id] = x), (y[x.id] = 0), (m[x.id] = T(x, d, o.distFunc));
        }
        for (
          var M, S, w, E, k, j, N, _ = o.maximumLoops, B = o.penalties;
          Object.keys(p).length > 0 &&
          _ > 0 &&
          ((M = void 0),
          (S = 1 / 0),
          Object.keys(p).forEach((t) => {
            const e = p[t].id;
            m[e] <= S && ((S = m[e]), (M = p[e]));
          }),
          M);

        ) {
          if (
            d.findIndex((t) => {
              return t.x === M.x && t.y === M.y;
            }) > -1
          )
            return A(M, v, c, e, t, h, s);
          delete p[M.id], (g[M.id] = !0);
          for (b = 0; b < o.directions.length; b++)
            (w = o.directions[b]),
              g[
                (E = {
                  x: M.x + w.stepX,
                  y: M.y + w.stepY,
                  id: `${Math.round(M.x) + w.stepX}|||${Math.round(M.y) + w.stepY}`,
                }).id
              ] ||
                (N = I(M, E, v, c)) > o.maxAllowedDirectionChange ||
                u[E.id] ||
                (p[E.id] || (p[E.id] = E),
                (k = o.distFunc(M, E) + (isNaN(B[N]) ? s : B[N])),
                (j = y[M.id] + k),
                (y[E.id] && j >= y[E.id]) ||
                  ((v[E.id] = M), (y[E.id] = j), (m[E.id] = j + T(E, d, o.distFunc))));
          _ -= 1;
        }
        return o.fallbackRoute(t, e, n, r, o);
      };
      Object(o.q)(
        'polyline',
        {
          options: {
            color: o.e.defaultEdge.color,
            size: o.e.defaultEdge.size,
            style: {
              radius: 0,
              offset: 15,
              x: 0,
              y: 0,
              stroke: o.e.defaultEdge.style.stroke,
              lineAppendWidth: o.e.defaultEdge.style.lineAppendWidth,
            },
            labelCfg: {
              style: { fill: o.e.edgeLabel.style.fill, fontSize: o.e.edgeLabel.style.fontSize },
            },
            routeCfg: {
              obstacles: [],
              maxAllowedDirectionChange: Math.PI,
              maximumLoops: 500,
              gridSize: 10,
            },
            stateStyles: r({}, o.e.edgeStateStyles),
          },
          shapeType: 'polyline',
          labelPosition: 'center',
          drawShape(t, e) {
            const n = this.getShapeStyle(t);
            return (
              n.radius === 0 && delete n.radius,
              e.addShape('path', { className: 'edge-shape', name: 'edge-shape', attrs: n })
            );
          },
          getShapeStyle(t) {
            const e = this.options.style;
            const n = { stroke: t.color };
            const r = Object(a.r)({}, e, n, t.style);
            (t = this.getPathPoints(t)), (this.radius = r.radius), (this.offset = r.offset);
            const i = t.startPoint;
            const s = t.endPoint;
            const u = this.getControlPoints(t);
            let c = [i];
            u && (c = c.concat(u)), c.push(s);
            const h = t.sourceNode;
            const l = t.targetNode;
            const f = r.radius;
            const d = this.options.routeCfg;
            const p = Object(a.r)({}, d, t.routeCfg);
            p.offset = r.offset;
            let g = this.getPath(c, h, l, f, p);
            return (
              ((Object(a.f)(g) && g.length <= 1) || (Object(a.o)(g) && g.indexOf('L') === -1)) &&
                (g = 'M0 0, L0 0'),
              (isNaN(i.x) || isNaN(i.y) || isNaN(s.x) || isNaN(s.y)) && (g = 'M0 0, L0 0'),
              Object(a.r)({}, o.e.defaultEdge.style, r, { lineWidth: t.size, path: g })
            );
          },
          updateShapeStyle(t, e) {
            const n = e.getContainer();
            if (e.isVisible()) {
              const r = { stroke: t.color };
              const i =
                n.find((t) => {
                  return t.get('className') === 'edge-shape';
                }) || e.getKeyShape();
              const o = t.size;
              const s = (t = this.getPathPoints(t)).startPoint;
              const u = t.endPoint;
              const c = this.getControlPoints(t);
              let h = [s];
              c && (h = h.concat(c)), h.push(u);
              const l = i.attr();
              const f = Object(a.r)({}, r, l, t.style);
              const d = t.sourceNode;
              const p = t.targetNode;
              const g = f.radius;
              const v = this.options.routeCfg;
              const y = Object(a.r)({}, v, t.routeCfg);
              y.offset = f.offset;
              let m = this.getPath(h, d, p, g, y);
              ((Object(a.f)(m) && m.length <= 1) || (Object(a.o)(m) && m.indexOf('L') === -1)) &&
                (m = 'M0 0, L0 0'),
                (isNaN(s.x) || isNaN(s.y) || isNaN(u.x) || isNaN(u.y)) && (m = 'M0 0, L0 0'),
                l.endArrow && !1 === f.endArrow && (t.style.endArrow = { path: '' }),
                l.startArrow && !1 === f.startArrow && (t.style.startArrow = { path: '' });
              const b = Object(a.r)(r, i.attr(), { lineWidth: o, path: m }, t.style);
              i && i.attr(b);
            }
          },
          getPath(t, e, n, r, i) {
            const s = i.offset;
            const u = i.simple;
            if (!s || t.length > 2) {
              if (r) return S(t, r);
              const c = [];
              return (
                Object(a.c)(t, (t, e) => {
                  e === 0 ? c.push(['M', t.x, t.y]) : c.push(['L', t.x, t.y]);
                }),
                c
              );
            }
            const h = u ? w(t[t.length - 1], t[0], n, e, s) : j(t[0], t[t.length - 1], e, n, i);
            return h && h.length ? (r ? S(h, r) : o.n.pointsToPolygon(h)) : 'M0 0, L0 0';
          },
        },
        'single-edge',
      );
    },
    function (t, e, n) {
      'use strict';
      const r = n(1);
      const i = n(0);
      const o = n(2);
      const a = n(37);
      const s = a.a.cloneEvent;
      const u = a.a.isNaN;
      const c = Math.abs;
      const h = {
        getDefaultCfg() {
          return { direction: 'both', enableOptimize: !1, scalableRange: 0, allowDragOnItem: !1 };
        },
        getEvents() {
          return { dragstart: 'onDragStart', drag: 'onDragMove', dragend: 'onDragEnd' };
        },
        updateViewport(t) {
          const e = this.origin;
          const n = +t.clientX;
          const r = +t.clientY;
          if (!u(n) && !u(r)) {
            let i = n - e.x;
            let o = r - e.y;
            this.get('direction') === 'x' ? (o = 0) : this.get('direction') === 'y' && (i = 0),
              (this.origin = { x: n, y: r });
            const a = this.graph.get('width');
            const s = this.graph.get('height');
            const c = this.graph.get('canvas').getCanvasBBox();
            ((c.minX <= a + this.scalableRange && c.minX + i > a + this.scalableRange) ||
              (c.maxX + this.scalableRange >= 0 && c.maxX + this.scalableRange + i < 0)) &&
              (i = 0),
              ((c.minY <= s + this.scalableRange && c.minY + o > s + this.scalableRange) ||
                (c.maxY + this.scalableRange >= 0 && c.maxY + this.scalableRange + o < 0)) &&
                (o = 0),
              this.graph.translate(i, o);
          }
        },
        onDragStart(t) {
          t.originalEvent;
          if (this.shouldBegin.call(this, t)) {
            const e = t.target;
            const n = e && e.isCanvas && e.isCanvas();
            if (
              (this.allowDragOnItem || n) &&
              ((this.origin = { x: t.clientX, y: t.clientY }),
              (this.dragging = !1),
              this.enableOptimize)
            ) {
              for (var r = this.graph, i = r.getEdges(), o = 0, a = i.length; o < a; o++) {
                const s = i[o].get('group').get('children');
                s &&
                  s.forEach((t) => {
                    t.set('ori-visibility', t.get('ori-visibility') || t.get('visible')), t.hide();
                  });
              }
              for (let u = r.getNodes(), c = 0, h = u.length; c < h; c++)
                for (let l = 0, f = u[c].getContainer().get('children'); l < f.length; l++) {
                  const d = f[l];
                  d.get('isKeyShape') ||
                    (d.set('ori-visibility', d.get('ori-visibility') || d.get('visible')),
                    d.hide());
                }
            }
          }
        },
        onDragMove(t) {
          this.graph;
          const e = t.target;
          const n = e && e.isCanvas && e.isCanvas();
          if ((this.allowDragOnItem || n) && ((t = s(t)), this.origin)) {
            if (!this.dragging) {
              if (c(this.origin.x - t.clientX) + c(this.origin.y - t.clientY) < 10) return;
              this.shouldBegin.call(this, t) && ((t.type = 'dragstart'), (this.dragging = !0));
            }
            this.shouldUpdate.call(this, t) && this.updateViewport(t);
          }
        },
        onDragEnd(t) {
          const e = this.graph;
          if (this.enableOptimize) {
            for (let n = e.getEdges(), r = 0, i = n.length; r < i; r++) {
              const o = n[r].get('group').get('children');
              o &&
                o.forEach((t) => {
                  t.get('ori-visibility') && t.show();
                });
            }
            for (let a = e.getNodes(), u = 0, c = a.length; u < c; u++)
              for (let h = 0, l = a[u].getContainer().get('children'); h < l.length; h++) {
                const f = l[h];
                if (!f.get('isKeyShape')) f.get('ori-visibility') && f.show();
              }
          }
          this.dragging
            ? ((t = s(t)),
              this.shouldEnd.call(this, t) && this.updateViewport(t),
              (t.type = 'dragend'),
              this.endDrag())
            : (this.origin = null);
        },
        endDrag() {
          (this.origin = null), (this.dragging = !1), (this.dragbegin = !1);
        },
      };
      const l = n(19);
      const f = {
        getDefaultCfg() {
          return {
            updateEdge: !0,
            delegateStyle: {},
            enableDelegate: !1,
            onlyChangeComboSize: !1,
            comboActiveState: '',
            selectedState: 'selected',
          };
        },
        getEvents() {
          return {
            'node:dragstart': 'onDragStart',
            'node:drag': 'onDrag',
            'node:dragend': 'onDragEnd',
            'combo:dragenter': 'onDragEnter',
            'combo:dragleave': 'onDragLeave',
            'combo:drop': 'onDropCombo',
            'node:drop': 'onDropNode',
            'canvas:drop': 'onDropCanvas',
          };
        },
        validationCombo(t) {
          return !(!this.origin || !t || t.destroyed) && t.getType() === 'combo';
        },
        onDragStart(t) {
          const e = this;
          if (this.shouldBegin.call(this, t)) {
            const n = t.item;
            if (n && !n.destroyed && !n.hasLocked()) {
              const r = t.target;
              if (r) if (r.get('isAnchorPoint')) return;
              const o = this.graph;
              (this.targets = []), (this.targetCombo = null);
              const a = o.findAllByState('node', this.selectedState);
              const s = n.get('id');
              a.filter((t) => {
                const e = t.get('id');
                return s === e;
              }).length === 0
                ? this.targets.push(n)
                : a.length > 1
                ? a.forEach((t) => {
                    t.hasLocked() || e.targets.push(t);
                  })
                : this.targets.push(n);
              const u = [];
              this.targets.forEach((t) => {
                u.push(Object(i.a)(t.getModel()));
              }),
                this.set('beforeDragNodes', u),
                (this.origin = { x: t.x, y: t.y }),
                (this.point = {}),
                (this.originPoint = {});
            }
          }
        },
        onDrag(t) {
          const e = this;
          this.origin &&
            this.shouldUpdate(this, t) &&
            (this.get('enableDelegate')
              ? this.updateDelegate(t)
              : this.targets.map((n) => {
                  e.update(n, t);
                }));
        },
        onDragEnd(t) {
          if (this.origin && this.shouldEnd.call(this, t)) {
            const e = t.item;
            if (e) e.getContainer().set('capture', !0);
            this.delegateRect && (this.delegateRect.remove(), (this.delegateRect = null)),
              this.updatePositions(t);
            const n = this.graph;
            if (n.get('enabledStack')) {
              const r = {
                before: { nodes: this.get('beforeDragNodes'), edges: [], combos: [] },
                after: { nodes: [], edges: [], combos: [] },
              };
              this.targets.forEach((t) => {
                r.after.nodes.push(t.getModel());
              }),
                n.pushStack('update', Object(i.a)(r));
            }
            n.emit('dragnodeend', { items: this.targets, targetItem: null }),
              (this.point = {}),
              (this.origin = null),
              (this.originPoint = {}),
              (this.targets.length = 0),
              (this.targetCombo = null);
          }
        },
        onDropCombo(t) {
          const e = t.item;
          if (this.validationCombo(e)) {
            this.updatePositions(t);
            const n = this.graph;
            if (
              (this.comboActiveState && n.setItemState(e, this.comboActiveState, !1),
              (this.targetCombo = e),
              this.onlyChangeComboSize)
            )
              n.updateCombos();
            else {
              const r = e.getModel();
              this.targets.map((t) => {
                t.getModel().comboId !== r.id && n.updateComboTree(t, r.id);
              }),
                n.updateCombo(e);
            }
            n.emit('dragnodeend', { items: this.targets, targetItem: this.targetCombo });
          }
        },
        onDropCanvas(t) {
          const e = this.graph;
          this.targets &&
            this.targets.length !== 0 &&
            (this.updatePositions(t),
            this.onlyChangeComboSize
              ? e.updateCombos()
              : this.targets.map((t) => {
                  t.getModel().comboId && e.updateComboTree(t);
                }));
        },
        onDropNode(t) {
          if (this.targets && this.targets.length !== 0) {
            const e = t.item;
            this.updatePositions(t);
            const n = this.graph;
            const r = e.getModel().comboId;
            if (r) {
              const i = n.findById(r);
              this.comboActiveState && n.setItemState(i, this.comboActiveState, !1),
                this.targets.map((t) => {
                  const e = t.getModel();
                  r !== e.comboId && n.updateComboTree(t, r);
                }),
                n.updateCombo(i);
            } else
              this.targets.map((t) => {
                t.getModel().comboId && n.updateComboTree(t);
              });
            n.emit('dragnodeend', { items: this.targets, targetItem: e });
          }
        },
        onDragEnter(t) {
          const e = t.item;
          if (this.validationCombo(e)) {
            const n = this.graph;
            this.comboActiveState && n.setItemState(e, this.comboActiveState, !0);
          }
        },
        onDragLeave(t) {
          const e = t.item;
          if (this.validationCombo(e)) {
            const n = this.graph;
            this.comboActiveState && n.setItemState(e, this.comboActiveState, !1);
          }
        },
        updatePositions(t) {
          const e = this;
          this.targets &&
            this.targets.length !== 0 &&
            this.get('enableDelegate') &&
            this.targets.map((n) => {
              return e.update(n, t);
            });
        },
        update(t, e) {
          const n = this.origin;
          const r = t.get('model');
          const i = t.get('id');
          this.point[i] || (this.point[i] = { x: r.x || 0, y: r.y || 0 });
          const o = { x: e.x - n.x + this.point[i].x, y: e.y - n.y + this.point[i].y };
          this.get('updateEdge') ? this.graph.updateItem(t, o, !1) : t.updatePosition(o);
        },
        updateDelegate(t) {
          this.graph;
          if (this.delegateRect) {
            const e = t.x - this.origin.x + this.originPoint.minX;
            const n = t.y - this.origin.y + this.originPoint.minY;
            this.delegateRect.attr({ x: e, y: n });
          } else {
            const o = this.graph.get('group');
            const a = Object(i.b)({}, l.a.delegateStyle, this.delegateStyle);
            const s = this.calculationGroupPosition(t);
            const u = s.x;
            const c = s.y;
            const h = s.width;
            const f = s.height;
            const d = s.minX;
            const p = s.minY;
            (this.originPoint = { x: u, y: c, width: h, height: f, minX: d, minY: p }),
              (this.delegateRect = o.addShape('rect', {
                attrs: Object(r.a)({ width: h, height: f, x: u, y: c }, a),
                name: 'rect-delegate-shape',
              }));
          }
        },
        calculationGroupPosition(t) {
          const e = this.graph.findAllByState('node', this.selectedState);
          e.length === 0 && e.push(t.item);
          for (var n = 1 / 0, r = -1 / 0, i = 1 / 0, o = -1 / 0, a = 0; a < e.length; a++) {
            const s = e[a].getBBox();
            const u = s.minX;
            const c = s.minY;
            const h = s.maxX;
            const l = s.maxY;
            u < n && (n = u), c < i && (i = c), h > r && (r = h), l > o && (o = l);
          }
          return {
            x: Math.floor(n),
            y: Math.floor(i),
            width: Math.ceil(r) - Math.floor(n),
            height: Math.ceil(o) - Math.floor(i),
            minX: n,
            minY: i,
          };
        },
      };
      const d = {
        getDefaultCfg() {
          return { multiple: !0, selectedState: 'selected' };
        },
        getEvents() {
          return { 'node:tap': 'onClick', 'combo:tap': 'onClick', 'canvas:tap': 'onCanvasClick' };
        },
        onClick(t) {
          const e = this;
          const n = t.item;
          if (n && !n.destroyed) {
            const r = n.getType();
            const o = e.graph;
            const a = e.multiple;
            const s = e.shouldUpdate;
            if (e.shouldBegin.call(e, t)) {
              if (!a) {
                const u = o.findAllByState(r, e.selectedState);
                Object(i.c)(u, (t) => {
                  t !== n && o.setItemState(t, e.selectedState, !1);
                });
              }
              if (n.hasState(e.selectedState)) {
                s.call(e, t) && o.setItemState(n, e.selectedState, !1);
                var c = o.findAllByState('node', e.selectedState);
                var h = o.findAllByState('combo', e.selectedState);
                o.emit('nodeselectchange', {
                  target: n,
                  selectedItems: { nodes: c, combos: h },
                  select: !1,
                });
              } else {
                s.call(e, t) && o.setItemState(n, e.selectedState, !0);
                (c = o.findAllByState('node', e.selectedState)),
                  (h = o.findAllByState('combo', e.selectedState));
                o.emit('nodeselectchange', {
                  target: n,
                  selectedItems: { nodes: c, combos: h },
                  select: !0,
                });
              }
            }
          }
        },
        onCanvasClick() {
          const t = this;
          const e = this.graph;
          const n = e.findAllByState('node', this.selectedState);
          Object(i.c)(n, (n) => {
            e.setItemState(n, t.selectedState, !1);
          });
          const r = e.findAllByState('combo', this.selectedState);
          Object(i.c)(r, (n) => {
            e.setItemState(n, t.selectedState, !1);
          }),
            e.emit('nodeselectchange', {
              selectedItems: { nodes: [], edges: [], combos: [] },
              select: !1,
            });
        },
      };
      const p = {
        firstScale: null,
        getDefaultCfg() {
          return {
            originScale: 1,
            sensitivity: 2,
            minZoom: void 0,
            maxZoom: void 0,
            enableOptimize: !1,
            optimizeZoom: 0.1,
            fixSelectedItems: { fixAll: !1, fixLineWidth: !1, fixLabel: !1, fixState: 'selected' },
          };
        },
        getEvents() {
          const t = this.fixSelectedItems;
          return (
            t.fixState || (t.fixState = 'selected'),
            t.fixAll && ((t.fixLineWidth = !0), (t.fixLabel = !0)),
            { pinchstart: 'onPinch', pinchmove: 'onPinch' }
          );
        },
        onPinch(t) {
          t.preventDefault && t.preventDefault(),
            t.originalEvent.preventDefault && t.originalEvent.preventDefault();
          const e = t.originalEvent.pointers;
          if (!(e.length < 2)) {
            t.type === 'pinchstart' && (this.firstScale = this.graph.getZoom());
            const n = t.originalEvent.scale || t.originalEvent.srcEvent.extra.scale;
            const r = this.firstScale * n;
            this.currentScale = r;
            const i = this.get('minZoom') || this.graph.get('minZoom');
            if (!(r > (this.get('maxZoom') || this.graph.get('maxZoom')) || r < i)) {
              const o = this.graph.get('canvas');
              const a = e[0].clientX;
              const s = e[0].clientY;
              const u = e[1].clientX;
              const c = e[1].clientY;
              const h = o.getPointByClient((a + u) / 2, (s + c) / 2);
              this.graph.zoomTo(r, { x: h.x, y: h.y });
            }
          }
        },
      };
      const g = ['tap', 'dbltap'];
      const v = {
        getDefaultCfg() {
          return { trigger: 'tap', onChange() {} };
        },
        getEvents() {
          let t;
          let e;
          return (
            g.includes(this.trigger)
              ? (e = this.trigger)
              : ((e = 'tap'),
                console.warn(
                  "Behavior collapse-expand 的 trigger 参数不合法，请输入 'click' 或 'dblclick'",
                )),
            ((t = {})[`node:${e}`] = 'onNodeTap'),
            (t.touchstart = 'onNodeTap'),
            t
          );
        },
        onNodeTap(t) {
          const e = t.item;
          const n = this.graph.findDataById(e.get('id'));
          if (n) {
            const r = n.children;
            if (r && r.length !== 0) {
              const i = !n.collapsed;
              if (
                this.shouldBegin(t, i) &&
                ((n.collapsed = i),
                (e.getModel().collapsed = i),
                this.graph.emit('itemcollapsed', { item: t.item, collapsed: i }),
                this.shouldUpdate(t, i))
              ) {
                try {
                  this.onChange(e, i);
                } catch (t) {
                  console.warn(t);
                }
                this.graph.layout();
              }
            }
          }
        },
      };
      const y = a.a.calculationItemsBBox;
      var m = function (t, e) {
        if (!1 !== e(t) && t) {
          const n = t.get('combos');
          if (n.length === 0) return !1;
          Object(i.c)(n, (t) => {
            m(t, e);
          });
        }
      };
      const b = ['click', 'dblclick'];
      const x = ['tap', 'drag'];
      const M = ['shift', 'ctrl', 'control', 'alt', 'meta', void 0];
      const S = {
        bind(t) {
          this.type === 'drag-canvas' && t.get('canvas').set('draggable', !0);
          const e = this.events;
          (this.graph = t),
            Object(i.c)(e, (e, n) => {
              t.on(n, e);
            });
        },
        unbind(t) {
          const e = this.events;
          this.type === 'drag-canvas' && t.get('canvas').set('draggable', !1),
            (this.graph = null),
            Object(i.c)(e, (e, n) => {
              t.off(n, e);
            });
        },
      };
      const w = {
        'drag-canvas': h,
        'zoom-canvas': p,
        'drag-node': f,
        'activate-relations': {
          getDefaultCfg() {
            return {
              activeState: 'active',
              inactiveState: 'inactive',
              resetSelected: !1,
              shouldUpdate() {
                return !0;
              },
            };
          },
          getEvents() {
            return { 'node:tap': 'setAllItemStates', 'canvas:tap': 'clearAllItemStates' };
          },
          setAllItemStates(t) {
            const e = t.item;
            const n = this.graph;
            if (((this.item = e), this.shouldUpdate(t.item, { event: t, action: 'activate' }))) {
              for (
                var r = this.activeState,
                  i = this.inactiveState,
                  o = n.getNodes(),
                  a = n.getEdges(),
                  s = o.length,
                  u = a.length,
                  c = 0;
                c < s;
                c++
              ) {
                const h = o[c];
                const l = h.hasState('selected');
                this.resetSelected && l && n.setItemState(h, 'selected', !1),
                  n.setItemState(h, r, !1),
                  i && n.setItemState(h, i, !0);
              }
              for (c = 0; c < u; c++) {
                var f = a[c];
                n.setItemState(f, r, !1), i && n.setItemState(f, i, !0);
              }
              i && n.setItemState(e, i, !1), n.setItemState(e, r, !0);
              const d = e.getEdges();
              const p = d.length;
              for (c = 0; c < p; c++) {
                let g = void 0;
                (g = (f = d[c]).getSource() === e ? f.getTarget() : f.getSource()),
                  i && n.setItemState(g, i, !1),
                  n.setItemState(g, r, !0),
                  n.setItemState(f, i, !1),
                  n.setItemState(f, r, !0),
                  f.toFront();
              }
              n.emit('afteractivaterelations', { item: t.item, action: 'activate' });
            }
          },
          clearActiveState(t) {
            const e = this.get('graph');
            if (this.shouldUpdate(t.item, { event: t, action: 'deactivate' })) {
              const n = this.activeState;
              const r = this.inactiveState;
              const i = e.get('autoPaint');
              e.setAutoPaint(!1);
              for (
                var o = e.getNodes(), a = e.getEdges(), s = o.length, u = a.length, c = 0;
                c < s;
                c++
              ) {
                const h = o[c];
                e.clearItemStates(h, [n, r]);
              }
              for (c = 0; c < u; c++) {
                const l = a[c];
                e.clearItemStates(l, [n, r, 'deactivate']);
              }
              e.paint(),
                e.setAutoPaint(i),
                e.emit('afteractivaterelations', {
                  item: t.item || this.get('item'),
                  action: 'deactivate',
                });
            }
          },
          clearAllItemStates(t) {
            const e = this.graph;
            if (this.shouldUpdate(t.item, { event: t, action: 'deactivate' })) {
              for (
                var n = this.activeState,
                  r = this.inactiveState,
                  i = e.getNodes(),
                  o = e.getEdges(),
                  a = i.length,
                  s = o.length,
                  u = 0;
                u < a;
                u++
              ) {
                const c = i[u];
                e.clearItemStates(c, [n, r]);
              }
              for (u = 0; u < s; u++) {
                const h = o[u];
                e.clearItemStates(h, [n, r, 'deactivate']);
              }
              e.emit('afteractivaterelations', {
                item: t.item || this.get('item'),
                action: 'deactivate',
              });
            }
          },
        },
        'click-select': d,
        'collapse-expand': v,
        'drag-combo': {
          getDefaultCfg() {
            return {
              enableDelegate: !1,
              delegateStyle: {},
              onlyChangeComboSize: !1,
              activeState: '',
              selectedState: 'selected',
            };
          },
          getEvents() {
            return {
              'combo:dragstart': 'onDragStart',
              'combo:drag': 'onDrag',
              'combo:dragend': 'onDragEnd',
              'combo:drop': 'onDrop',
              'node:drop': 'onNodeDrop',
              'combo:dragenter': 'onDragEnter',
              'combo:dragleave': 'onDragLeave',
            };
          },
          validationCombo(t) {
            const e = t.item;
            return !(!e || e.destroyed) && !!this.shouldUpdate(this, t) && e.getType() === 'combo';
          },
          onDragStart(t) {
            const e = this;
            const n = this.graph;
            const r = t.item;
            if (this.validationCombo(t)) {
              this.targets = [];
              const i = n.findAllByState('combo', this.selectedState);
              const o = r.get('id');
              i.filter((t) => {
                const e = t.get('id');
                return o === e;
              }).length === 0
                ? this.targets.push(r)
                : (this.targets = i),
                this.activeState &&
                  this.targets.map((t) => {
                    const r = t.getModel();
                    if (r.parentId) {
                      const i = n.findById(r.parentId);
                      i && n.setItemState(i, e.activeState, !0);
                    }
                  }),
                (this.point = {}),
                (this.originPoint = {}),
                (this.origin = { x: t.x, y: t.y }),
                (this.currentItemChildCombos = []),
                m(r, (t) => {
                  if (t.destroyed) return !1;
                  const n = t.getModel();
                  return e.currentItemChildCombos.push(n.id), !0;
                });
            }
          },
          onDrag(t) {
            const e = this;
            if (this.origin && this.validationCombo(t))
              if (this.enableDelegate) this.updateDelegate(t);
              else {
                if (this.activeState) {
                  const n = this.graph;
                  const r = t.item;
                  const o = r.getModel();
                  const a = n.getCombos();
                  const s = r.getBBox();
                  const u = s.centerX;
                  const c = s.centerY;
                  const h = s.width;
                  a.filter((t) => {
                    const n = t.getModel();
                    return o.parentId, n.id !== o.id && !e.currentItemChildCombos.includes(n.id);
                  }).map((t) => {
                    const r = t.getBBox();
                    const i = r.centerX;
                    const o = r.centerY;
                    const a = r.width;
                    const s = u - i;
                    const l = c - o;
                    const f = 2 * Math.sqrt(s * s + l * l);
                    h + a - f > 0.8 * h
                      ? n.setItemState(t, e.activeState, !0)
                      : n.setItemState(t, e.activeState, !1);
                  });
                }
                Object(i.c)(this.targets, (n) => {
                  e.updateCombo(n, t);
                });
              }
          },
          updatePositions(t) {
            const e = this;
            this.enableDelegate &&
              Object(i.c)(this.targets, (n) => {
                e.updateCombo(n, t);
              });
          },
          onDrop(t) {
            const e = this;
            const n = t.item;
            if (n && this.targets && !n.destroyed) {
              this.updatePositions(t);
              const r = this.graph;
              const i = n.getModel();
              this.targets.map((t) => {
                t.getModel().parentId !== i.id
                  ? (e.activeState && r.setItemState(n, e.activeState, !1),
                    e.onlyChangeComboSize ? r.updateCombo(t) : r.updateComboTree(t, i.id))
                  : r.updateCombo(n);
              }),
                this.end(n, t),
                (this.endComparison = !0);
            }
          },
          onNodeDrop(t) {
            const e = this;
            if (this.targets && this.targets.length !== 0) {
              this.updatePositions(t);
              let n;
              const r = this.graph;
              const i = t.item.getModel().comboId;
              if (i) {
                if (this.activeState) {
                  const o = r.findById(i);
                  r.setItemState(o, this.activeState, !1);
                }
                this.targets.map((t) => {
                  e.onlyChangeComboSize
                    ? r.updateCombo(t)
                    : i !== t.getID() &&
                      ((n = r.findById(i)), i !== t.getModel().parentId && r.updateComboTree(t, i));
                });
              } else
                this.targets.map((t) => {
                  e.onlyChangeComboSize
                    ? r.updateCombo(t)
                    : t.getModel().comboId && r.updateComboTree(t);
                });
              (this.endComparison = !0), this.end(n, t);
            }
          },
          onDragEnter(t) {
            if (this.origin && this.validationCombo(t)) {
              const e = t.item;
              const n = this.graph;
              this.activeState && n.setItemState(e, this.activeState, !0);
            }
          },
          onDragLeave(t) {
            if (this.origin && this.validationCombo(t)) {
              const e = t.item;
              const n = this.graph;
              this.activeState && n.setItemState(e, this.activeState, !1);
            }
          },
          onDragEnd(t) {
            if (this.targets && this.targets.length !== 0) {
              const e = t.item;
              this.updatePositions(t);
              const n = this.getParentCombo(e.getModel().parentId);
              const r = this.graph;
              n && this.activeState && r.setItemState(n, this.activeState, !1), this.end(void 0, t);
            }
          },
          end(t, e) {
            const n = this;
            if (this.origin) {
              const r = this.graph;
              if (this.delegateShape) r.get('delegateGroup').clear(), (this.delegateShape = null);
              t && this.activeState && r.setItemState(t, this.activeState, !1),
                t ||
                  this.targets.map((t) => {
                    n.onlyChangeComboSize ? r.updateCombo(t) : r.updateComboTree(t);
                  }),
                (this.point = []),
                (this.origin = null),
                (this.originPoint = null),
                (this.targets.length = 0);
            }
          },
          traverse(t, e) {
            const n = this;
            if (!1 !== e(t) && t) {
              const r = t.get('combos');
              Object(i.c)(r, (t) => {
                n.traverse(t, e);
              });
              const o = t.get('nodes');
              Object(i.c)(o, (t) => {
                n.traverse(t, e);
              });
            }
          },
          updateCombo(t, e) {
            const n = this;
            this.traverse(t, (t) => {
              return !t.destroyed && (n.updateSignleItem(t, e), !0);
            });
          },
          updateSignleItem(t, e) {
            const n = this.origin;
            const r = this.graph;
            const i = t.getModel();
            const o = t.get('id');
            this.point[o] || (this.point[o] = { x: i.x, y: i.y });
            const a = e.x - n.x + this.point[o].x;
            const s = e.y - n.y + this.point[o].y;
            r.updateItem(t, { x: a, y: s });
          },
          getParentCombo(t) {
            const e = this.graph;
            if (t) {
              const n = e.findById(t);
              if (n) return n;
            }
          },
          updateDelegate(t) {
            const e = this.graph;
            if (this.delegateShape) {
              const n = t.x - this.origin.x + this.originPoint.minX;
              const i = t.y - this.origin.y + this.originPoint.minY;
              this.delegateShape.attr({ x: n, y: i });
            } else {
              const o = e.get('delegateGroup');
              let a = null;
              const s = (a = this.targets.length > 1 ? y(this.targets) : this.targets[0].getBBox())
                .x;
              const u = a.y;
              const c = a.width;
              const h = a.height;
              const f = a.minX;
              const d = a.minY;
              this.originPoint = { x: s, y: u, width: c, height: h, minX: f, minY: d };
              const p = Object(r.a)(Object(r.a)({}, l.a.delegateStyle), this.delegateStyle);
              this.delegateShape = o.addShape('rect', {
                attrs: Object(r.a)({ width: a.width, height: a.height, x: a.x, y: a.y }, p),
                name: 'combo-delegate-shape',
              });
            }
          },
        },
        'collapse-expand-combo': {
          getDefaultCfg() {
            return { trigger: 'dblclick', relayout: !0 };
          },
          getEvents() {
            let t;
            let e;
            return (
              b.includes(this.trigger)
                ? (e = this.trigger)
                : ((e = 'dblclick'),
                  console.warn(
                    "Behavior collapse-expand-group 的 trigger 参数不合法，请输入 'click' 或 'dblclick'",
                  )),
              ((t = {})[`combo:${e}`] = 'onComboClick'),
              t
            );
          },
          onComboClick(t) {
            const e = t.item;
            const n = this.graph;
            const r = this.relayout;
            if (e && !e.destroyed && e.getType() === 'combo') {
              const i = e.getModel().id;
              i &&
                (n.collapseExpandCombo(i),
                r && n.get('layout') ? n.layout() : n.refreshPositions());
            }
          },
        },
        'create-edge': {
          getDefaultCfg() {
            return { trigger: 'tap', key: void 0, edgeConfig: {} };
          },
          getEvents() {
            let t;
            return (
              x.indexOf(this.trigger.toLowerCase()) > -1 ||
                ((this.trigger = 'tap'),
                console.warn("Behavior create-edge 的 trigger 参数不合法，请输入 'click'，'drag'")),
              this.key &&
                M.indexOf(this.key.toLowerCase()) === -1 &&
                ((this.trigger = void 0),
                console.warn(
                  "Behavior create-edge 的 key 参数不合法，请输入 'shift'，'ctrl'，'alt'，'control'，或 undefined",
                )),
              this.trigger === 'drag'
                ? (t = {
                    'node:dragstart': 'onClick',
                    'combo:dragstart': 'onClick',
                    drag: 'updateEndPoint',
                    'node:drop': 'onClick',
                    'combo:drop': 'onClick',
                    dragend: 'onDragEnd',
                  })
                : this.trigger === 'click' &&
                  (t = {
                    'node:tap': 'onClick',
                    mousemove: 'updateEndPoint',
                    'edge:tap': 'cancelCreating',
                    'canvas:tap': 'cancelCreating',
                    'combo:tap': 'onClick',
                  }),
              this.key && ((t.keydown = 'onKeyDown'), (t.keyup = 'onKeyUp')),
              t
            );
          },
          onDragEnd(t) {
            if (!this.key || this.keydown) {
              const e = t.item;
              (e && e.getID() !== this.source && e.getType() === 'node') ||
                this.cancelCreating({ item: this.edge, x: t.x, y: t.y });
            }
          },
          onClick(t) {
            if (!this.key || this.keydown) {
              const e = t.item;
              const n = this.graph;
              const i = e.getModel();
              if (this.addingEdge && this.edge) {
                if (!this.shouldEnd.call(this, t)) return;
                const o = { target: i.id };
                this.source === i.id && (o.type = 'loop'),
                  n.emit('beforecreateedge', {}),
                  n.updateItem(this.edge, o),
                  n.emit('aftercreateedge', { edge: this.edge }),
                  this.edge.getKeyShape().set('capture', !0),
                  (this.edge = null),
                  (this.addingEdge = !1);
              } else {
                if (!this.shouldBegin.call(this, t)) return;
                (this.edge = n.addItem(
                  'edge',
                  Object(r.a)({ source: i.id, target: i.id }, this.edgeConfig),
                  !1,
                )),
                  (this.source = i.id),
                  (this.addingEdge = !0),
                  this.edge.getKeyShape().set('capture', !1);
              }
            }
          },
          updateEndPoint(t) {
            if (!this.key || this.keydown) {
              const e = { x: t.x, y: t.y };
              this.graph.findById(this.source)
                ? this.addingEdge &&
                  this.edge &&
                  this.graph.updateItem(this.edge, { target: e }, !1)
                : (this.addingEdge = !1);
            }
          },
          cancelCreating(t) {
            if (!this.key || this.keydown) {
              const e = this.graph;
              const n = t.item;
              if (this.addingEdge && t.target && t.target.isCanvas && t.target.isCanvas())
                return e.removeItem(this.edge, !1), (this.edge = null), void (this.addingEdge = !1);
              if (this.addingEdge && this.edge === n) {
                let r = !0;
                if (!e.get('groupByTypes'))
                  for (let i = t.x, o = t.y, a = e.getNodes(), s = a.length, u = 0; u < s; u++) {
                    const c = a[u];
                    const h = c.getModel();
                    const l = c.getBBox();
                    if (i <= l.maxX && i >= l.minX && o <= l.maxY && o >= l.minY) {
                      if (
                        !this.shouldEnd.call(this, {
                          x: t.x,
                          y: t.y,
                          canvasX: t.canvasX,
                          canvasY: t.canvasY,
                          clientX: t.clientX,
                          clientY: t.clientY,
                          item: c,
                        })
                      )
                        return;
                      e.emit('beforecreateedge', {}),
                        e.updateItem(this.edge, { target: h.id }),
                        e.emit('aftercreateedge', { edge: this.edge }),
                        (r = !1);
                      break;
                    }
                  }
                r && e.removeItem(this.edge, !1), (this.edge = null), (this.addingEdge = !1);
              }
            }
          },
          onKeyDown(t) {
            const e = t.key;
            e &&
              (e.toLowerCase() === this.key.toLowerCase()
                ? (this.keydown = !0)
                : (this.keydown = !1));
          },
          onKeyUp() {
            this.addingEdge &&
              this.edge &&
              (this.graph.removeItem(this.edge, !1), (this.addingEdge = !1), (this.edge = null)),
              (this.keydown = !1);
          },
        },
      };
      Object(i.c)(w, (t, e) => {
        Object(o.o)(e, Object(r.a)(Object(r.a)({}, t), S));
      });
    },
  ]).default;
});
// # sourceMappingURL=f6.js.map
